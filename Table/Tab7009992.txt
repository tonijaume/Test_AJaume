OBJECT Table 7009992 Cabecera Importacion MWR
{
  OBJECT-PROPERTIES
  {
    Date=15/01/15;
    Time=12:03:22;
    Modified=Yes;
    Version List=AIC2009;
  }
  PROPERTIES
  {
    OnDelete=VAR
               lrLin@1103355000 : Record 7009993;
             BEGIN
               // Limpiamos las lineas
               CLEAR(lrLin);
               lrLin.SETRANGE("No Importacion", Num);
               IF lrLin.FINDSET(TRUE) THEN
                 lrLin.DELETEALL;
             END;

    CaptionML=[ENU=MWR Importation header;
               ESP=Cabecera Importacion MWR];
    LookupFormID=Form7009983;
    DrillDownFormID=Form7009983;
  }
  FIELDS
  {
    { 1   ;   ;Num                 ;Integer       ;AutoIncrement=Yes;
                                                   CaptionML=[ENU=No.;
                                                              ESP=Num];
                                                   Editable=No }
    { 10  ;   ;Archivo             ;Text250       ;CaptionML=[ENU=File;
                                                              ESP=Archivo] }
    { 11  ;   ;Fecha Desde         ;Date          ;CaptionML=[ENU=Date From;
                                                              ESP=Fecha desde] }
    { 12  ;   ;Fecha Hasta         ;Date          ;CaptionML=[ENU=Date To;
                                                              ESP=Fecha hasta] }
    { 15  ;   ;TTOO                ;Code10        ;TableRelation=TourOperador.TourOperador;
                                                   ValidateTableRelation=No;
                                                   TestTableRelation=No;
                                                   CaptionML=[ENU=TTOO;
                                                              ESP=TTOO] }
    { 20  ;   ;Usuario Importacion ;Code20        ;CaptionML=[ENU=Importation user;
                                                              ESP=Usuario Importacion] }
    { 21  ;   ;Fecha Importacion   ;DateTime      ;CaptionML=[ENU=Importatio date;
                                                              ESP=Fecha Importacion] }
    { 22  ;   ;Fecha Creacion      ;DateTime      ;CaptionML=[ENU=Creation Date;
                                                              ESP=Fecha creacion];
                                                   Description=Fecha de creaci¢n que viene en la cabecera del archivo }
    { 30  ;   ;Traspasado          ;Boolean       ;CaptionML=[ENU=Transferred;
                                                              ESP=Traspasado] }
    { 31  ;   ;Anulado             ;Boolean       ;CaptionML=[ENU=Cancelled;
                                                              ESP=Anulado] }
    { 32  ;   ;Fecha Traspaso      ;DateTime      ;CaptionML=[ENU=Transfer date;
                                                              ESP=Fecha Traspaso];
                                                   Editable=No }
    { 33  ;   ;Fecha Anulacion     ;DateTime      ;CaptionML=[ENU=Cencellation Date;
                                                              ESP=Fecha anulacion];
                                                   Editable=No }
    { 50  ;   ;Delegacion MWR      ;Text250       ;CaptionML=[ENU="MRW Local office ";
                                                              ESP=Delegacion MWR];
                                                   Editable=No }
    { 100 ;   ;Tiene Bono          ;Boolean       ;FieldClass=FlowField;
                                                   CalcFormula=Exist("Lineas Importacion MWR" WHERE (No Importacion=FIELD(Num),
                                                                                                     Bono=FIELD(Filtro Bono)));
                                                   CaptionML=[ENU=Has Voucher;
                                                              ESP=Tiene Bono];
                                                   Description=Flowfield }
    { 150 ;   ;Filtro Bono         ;Code10        ;FieldClass=FlowFilter;
                                                   CaptionML=[ENU=Voucher filter;
                                                              ESP=Filtro Bono];
                                                   Description=FlowFilter;
                                                   Editable=No }
  }
  KEYS
  {
    {    ;Num                                     ;Clustered=Yes }
    {    ;Fecha Traspaso,Traspasado,Anulado       ;KeyGroups=RENUMERING }
  }
  FIELDGROUPS
  {
  }
  CODE
  {
    VAR
      wArchDialog@1103355000 : OCX "{F9043C85-F6F2-101A-A3C9-08002B2F49FB}:'Microsoft Common Dialog Control, version 6.0'";
      Text0001@1103355001 : TextConst 'ENU=Importing @1@@@@@@@@@@@@;ESP=Importando @1@@@@@@@@@@@@';
      rParPer@1103355017 : Record 7009701;
      rTrmpDel@1103355002 : TEMPORARY Record 7009859;
      Text0002@1103355003 : TextConst 'ENU=Any configuration Local Office Importation Company has been found for touroperator MWR;ESP=No se ha encontrado ninguna configuracion Empresa Importacion Delegacion para el touroperador MWR';
      rTempBaja@1103355010 : TEMPORARY Record 7009993;
      rParInt@1103355004 : Record 7010081;
      Text0003@1103355005 : TextConst 'ENU=IMP_MWR_;ESP=IMP_MWR_';
      Text0004@1103355006 : TextConst 'ENU=File %1 already exists;ESP=El archivo %1 ya existe';
      Text0005@1103355008 : TextConst 'ENU=Importation %1 has already been transferred;ESP=La importaci¢n %1 ya ha sido traspasada';
      Text0006@1103355007 : TextConst 'ENU=Importation %1 has already been cancelled;ESP=La importaci¢n %1 ya ha sido Anulada';
      Text0008@1103355009 : TextConst 'ENU=Would you like to transfer the importation %1?;ESP=¨Desea realmente Traspasar la importaci¢n %1?';
      cFunImpLTU@1103355018 : Codeunit 7009748;
      cFunImpLTU2@1103355023 : Codeunit 7009909;
      wVentana@1103355011 : Dialog;
      Text0009@1103355012 : TextConst 'ENU=Creating temporary resigns @1@@@@@@@@@;ESP=Creando temporal de bajas @1@@@@@@@@@';
      wTotal@1103355013 : Integer;
      wCont@1103355014 : Integer;
      Text0010@1103355015 : TextConst 'ENU=This importation cannot be transferred because one has been transferred with later date\Importation %1 %2;ESP=Esta importacion No se puede traspasar ya que ya se ha traspasado una con fecha posterior\Importacion %1 %2';
      Text0011@1103355016 : TextConst 'ENU=This importation cannot be transferred because there is a previous one remaining to be transferred\Importation %1 %2;ESP=Esta importacion No se puede traspasar ya que hay una anteior pendiente de traspasar\Importacion %1 %2';
      Text0012@1103355019 : TextConst 'ENU=Type of person %1 was not found;ESP=No se encuentra tipo de persona %1';
      Text0013@1103355020 : TextConst 'ENU=Would you like to cancel the importation %1?;ESP=¨Desea realmente anular la importaci¢n %1?';
      Text0014@1103355021 : TextConst 'ENU=%1 Vouchers have been transferred;ESP=Se han traspasado %1 Bonos';
      Text0015@1103355022 : TextConst 'ENU=Anything has been transferred;ESP=No se ha traspasado nada.';
      Text0016@1103355024 : TextConst 'ENU=Processing;ESP=Procesando';
      Text0017@1100217000 : TextConst 'ENU=Removing obsolet data...;ESP=Eliminando datos obsoletos...';

    PROCEDURE Importar@1103355000();
    VAR
      lwNomArchivo@1103355000 : Text[1024];
    BEGIN
      // Importar

      CLEAR(rParInt);
      rParInt.FINDFIRST;

      wArchDialog.DefaultExt  := '*.DAT|.DAT';
      wArchDialog.DialogTitle := 'Importacion MWR';
      rParInt.TESTFIELD("MWR Directorio Importacion");
      wArchDialog.InitDir     := rParInt."MWR Directorio Importacion";
      wArchDialog.ShowOpen;
      lwNomArchivo := wArchDialog.FileName;

      IF lwNomArchivo = '' THEN
        EXIT;

      ImportarArchivo(lwNomArchivo);

      MueveArchivo(Num,lwNomArchivo);

      _Depurar; //+$002
    END;

    PROCEDURE ImportarArchivo@1103355003(pwNomArchivo@1103355000 : Text[1024]);
    VAR
      lwArch@1103355001 : File;
      lwText@1103355002 : Text[1024];
      lwCampo@1103355003 : Text[250];
      lwOK@1103355004 : Boolean;
      lwOK1@1103355008 : Boolean;
      lwOKLimite@1103355016 : Boolean;
      lwEv@1103355006 : Boolean;
      lwFecha@1103355011 : Date;
      lwFechaLimite@1103355015 : Date;
      lwHora@1103355012 : Time;
      lrCab@1103355007 : Record 7009992;
      lrLin@1103355005 : Record 7009993;
      lrLinFL@1103355017 : Record 7009869;
      lrSufHot@1103355014 : Record 7009994;
      lwNoLin@1103355010 : Integer;
      lwVentana@1103355009 : Dialog;
      lwInts@1103355013 : ARRAY [3] OF Integer;
    BEGIN
      // ImportarArchivo

      IF pwNomArchivo= '' THEN
        EXIT;

      CLEAR(lwArch);
      lwArch.TEXTMODE:= TRUE;
      lwArch.OPEN(pwNomArchivo);

      CLEAR(lrCab);
      lrCab.Archivo := ExtractFilename(pwNomArchivo);
      lrCab."Usuario Importacion" := USERID;
      lrCab."Fecha Importacion"   := CURRENTDATETIME;
      // Creamos un temporal de Empresas Importacion Delegacion
      lrCab."Delegacion MWR"          := CreaTemporal;
      lrCab.INSERT;
      Rec := lrCab;

      // Borramos las lineas de importacion Fecha Limite
      // Son las que no han entrado por tener una fecha limite posterior a la fecha de la importacion
      CLEAR(lrLinFL);
      lrLinFL.DELETEALL;

      lwVentana.OPEN(Text0001);
      lwOK1:= FALSE;
      CLEAR(lwNoLin);
      REPEAT

        CLEAR(lrLin);
        CLEAR(lwOK);
        lwArch.READ(lwText);
        lwCampo := GetCampo(lwText,1,5);
        lwEv := EVALUATE(lrLin."No Linea", lwCampo);

        // No empezamos a importar hasta haber pasado la cabecera. Miramos encontrar la linea Num. 1
        IF NOT lwOK1 THEN BEGIN
          lwNoLin +=1; // Numero de linea de cabecera
          // Buscamos el touroperador
          BuscaTTOO(lrCab, lwText);
          CASE lwNoLin OF
             5: BEGIN // Fecha Desde del archivo
                  EVALUATE(lwInts[1], COPYSTR(lwText,7,2));
                  EVALUATE(lwInts[2], COPYSTR(lwText,5,2));
                  EVALUATE(lwInts[3], COPYSTR(lwText,1,4));
                  lwFecha := DMY2DATE(lwInts[1], lwInts[2], lwInts[3]);
                  lrCab."Fecha Desde" := lwFecha;
                END;
             6: BEGIN // Fecha de creaci¢n del archivo
                  EVALUATE(lwInts[1], COPYSTR(lwText,9,2));
                  EVALUATE(lwInts[2], COPYSTR(lwText,6,2));
                  EVALUATE(lwInts[3], COPYSTR(lwText,1,4));
                  lwFecha := DMY2DATE(lwInts[1], lwInts[2], lwInts[3]);
                  EVALUATE(lwHora, COPYSTR(lwText,12,5));
                  lrCab."Fecha Creacion" := CREATEDATETIME(lwFecha, lwHora);
                END;
          END;
          lwOK1 := lrLin."No Linea" = 1;
        END;

        // Comprobamos que la delegaci¢n, que es el prefijo que est  en el codigo de hotel corresponde
        // a alguna parametrizada

        IF lwOK1 THEN BEGIN
          lrLin.Hotel := GetCampo(lwText, 81, 15);

          // AJS 17.06.2008
          // Incluimos el tratamiento de la columna Sufijo hotel, en algunos casos al codigo de hotel hay
          // que agregarle el valor de la columna 149

          // AJS 25.06.2008
          // El tratamiento del sufijo solo hay que hacerlo si la linea tiene codigo de hotel
          // las otras lineas son basura por tratarse de un fichero de texto sin formato de exportacion

          IF lrLin.Hotel <> '' THEN BEGIN
            lrLin."Sufijo hotel" := GetCampo(lwText, 149, 2);
            lrSufHot.GET(lrLin."Sufijo hotel");
            IF lrSufHot.Aplicar THEN
              lrLin.Hotel := lrLin.Hotel + lrLin."Sufijo hotel";
          END;

          rTrmpDel.FINDFIRST;
          REPEAT
            lwOK := rTrmpDel.Destino = UPPERCASE(COPYSTR(lrLin.Hotel, 1, STRLEN(rTrmpDel.Destino)));
          UNTIL (rTrmpDel.NEXT = 0) OR lwOK;

          // JPT 19/12/08 Ahora hay una fecha limite que tiene los clientes para modificar una reserva
          // No se van a importar todas aquellas reservas que tienen dicha fecha posterior a la genraci¢n del fichero
          IF lwOK THEN BEGIN
            // Tiene tela que en el mismo fichero vengan fechas en formatos distintos
            lwCampo := COPYSTR(lwText,176,2) + COPYSTR(lwText,174,2) + COPYSTR(lwText,170,4);
            IF EVALUATE(lwFechaLimite, lwCampo) THEN
              lwOKLimite := lwFechaLimite <= DT2DATE(lrCab."Fecha Creacion");
          END;
        END;

        IF lwOK THEN BEGIN
          lrLin."No Importacion"  := lrCab.Num;
          lrLin.Bono              := GetCampo(lwText,6,12);
          // lrLin.Bono             := lrLin.Bono + GetCampo(lwText,18,3);
          lwEv := EVALUATE(lrLin.Item, GetCampo(lwText,19,2));
          lwEv := EVALUATE(lrLin."Fecha Venta", GetCampo(lwText,25,10));
          lrLin."Tipo Persona"    := GetCampo(lwText,39,1);
          lrLin.Nombre            := GetCampo(lwText,41,35);
          lwEv := EVALUATE(lrLin.Edad, GetCampo(lwText,77,3));
          lrLin."Nombre Hotel"    := GetCampo(lwText,96,30);
          lwEv := EVALUATE(lrLin."Fecha Entrada", GetCampo(lwText,127,10));
          lwEv := EVALUATE(lrLin."Fecha Salida" , GetCampo(lwText,138,10));

          // AJS 09.06.2008
          // Se ha incluido un nuevo campo en la posicion 149 [2 caracteres]
          // de momento no lo tratamos, pero hay que mover los campos
          //lwEv := EVALUATE(lrLin."Num Habitaciones" , GetCampo(lwText,149,3));

          lwEv := EVALUATE(lrLin."Num Habitaciones" , GetCampo(lwText, 152, 3));

          // AJS 13.03.2008
          // Al tipo de habitacion hay que sumarle la columna Bel que es la ocupacion
          // para construir el codigo de habitacion

          // AJS 09.06.2008
          // Movemos todos los campos posteriores a la posicion 149
          //rLin."Tipo Habitacion" := GetCampo(lwText,153,4) + GetCampo(lwText, 161, 3);

          lrLin."Tipo Habitacion" := GetCampo(lwText,156,4) + GetCampo(lwText, 164, 3);

          // AJS 09.06.2008
          // Movemos todos los campos posteriores a la posicion 149
          //lrLin.Regimen           := GetCampo(lwText,158,2);

          lrLin.Regimen           := GetCampo(lwText,161,2);
          lrLin.TTOO              := lrCab.TTOO;
          lrLin."Fecha Limite"    := lwFechaLimite;
          IF lwOKLimite THEN
            lrLin.INSERT
          ELSE BEGIN // Si est  por debajo de la fecha limite, creamos el registro en otra tabla
            CLEAR(lrLinFL);
            lrLinFL.TRANSFERFIELDS(lrLin);
            lrLinFL.INSERT;
          END;

          { la fecha desde no la insertamos de las lineas si no de la cabecera
          IF ((lrLin."Fecha Entrada" <> 0D) AND (lrLin."Fecha Entrada" < lrCab."Fecha Desde")) OR
            (lrCab."Fecha Desde"=0D) THEN
            lrCab."Fecha Desde" := lrLin."Fecha Entrada";
          }
          IF lrLin."Fecha Salida" > lrCab."Fecha Hasta" THEN
            lrCab."Fecha Hasta" := lrLin."Fecha Salida";
        END;
        lrCab.MODIFY;
        lwVentana.UPDATE(1, ROUND(lwArch.POS/lwArch.LEN * 10000,1));
      UNTIL lwArch.POS = lwArch.LEN;
      lwVentana.CLOSE;
    END;

    PROCEDURE ExtractFilename@1103355002(pwDir@1103355000 : Text[1024]) : Text[250];
    VAR
      lwArch@1103355001 : Text[1024];
      lwPos@1103355002 : Integer;
    BEGIN
      // ExtractFilename
      // Dado una direcci¢n extraemos solo el nombre del archivo

      lwArch := pwDir;
      lwPos := STRPOS(lwArch,'\');
      WHILE lwPos <> 0 DO BEGIN
        lwArch := COPYSTR(lwArch, lwPos +1, STRLEN(lwArch));
        lwPos := STRPOS(lwArch,'\');
      END;

      EXIT(lwArch);
    END;

    PROCEDURE GetCampo@1103355005(pwTexto@1103355000 : Text[1024];pwPos@1103355001 : Integer;pwWidth@1103355002 : Integer) : Text[250];
    BEGIN
      // GetCampo

      EXIT(DELCHR(COPYSTR(pwTexto,pwPos,pwWidth),'<>'));
    END;

    PROCEDURE CreaTemporal@1103355001() : Text[250];
    VAR
      lrEmpImpDeleg@1103355000 : Record 7009859;
      lwTexto@1103355001 : Text[250];
    BEGIN
      // CreaTemporal
      // Crea temporales Empresa Importacion Delegacion
      // Devuelve un texto concatenado con todas las delegaciones

      CLEAR(rTrmpDel);
      CLEAR(lwTexto);
      rTrmpDel.DELETEALL;

      CLEAR(lrEmpImpDeleg);
      lrEmpImpDeleg.SETRANGE(Tipo   , lrEmpImpDeleg.Tipo::MWR);
      lrEmpImpDeleg.SETRANGE(Empresa, COMPANYNAME);
      IF lrEmpImpDeleg.FINDSET THEN BEGIN
        REPEAT
          rTrmpDel := lrEmpImpDeleg;
          rTrmpDel.INSERT;
          IF lwTexto <> '' THEN
            lwTexto += ',';
          lwTexto += lrEmpImpDeleg.Destino;
        UNTIL lrEmpImpDeleg.NEXT=0;
      END
      ELSE
        ERROR(Text0002);

      EXIT(lwTexto);
    END;

    PROCEDURE MueveArchivo@9(pwNoImportacion@1103355000 : Integer;pwNombreArchivo@1103355001 : Text[150]);
    VAR
      lwDirectorio@1103355002 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
      lwSubdirectorio@1103355003 : Text[250];
      lwArch1@1103355004 : Text[250];
      lwArch2@1103355005 : Text[250];
    BEGIN
      // MueveArchivo
      // Esta funci¢n se encarga de abrir un Subdirectorio para esa importaci¢n y mover
      // all¡ todos los archivos importados
      // pwNoImportacion Es el N§ asignado a esa importaci¢n.

      CREATE(lwDirectorio);

      rParInt.TESTFIELD("MWR Directorio Importados");
      lwSubdirectorio := rParInt."MWR Directorio Importados";
      IF lwSubdirectorio[STRLEN(lwSubdirectorio)] <> '\' THEN
        lwSubdirectorio := lwSubdirectorio + '\';

      lwSubdirectorio := lwSubdirectorio + FORMAT(TODAY,0,'<Month Text><Year>') + '\';

      IF NOT lwDirectorio.FolderExists(lwSubdirectorio) THEN
        lwDirectorio.CreateFolder(lwSubdirectorio);

      lwSubdirectorio := STRSUBSTNO('%1%2%3_%4',lwSubdirectorio, Text0003, Ponceros(pwNoImportacion , 4), DELCHR(FORMAT(TODAY),'=','/'))
      ;

      IF NOT lwDirectorio.FolderExists (lwSubdirectorio) THEN
        lwDirectorio.CreateFolder (lwSubdirectorio);

      IF EXISTS(pwNombreArchivo) THEN BEGIN
        lwArch2 := lwSubdirectorio + '\' + lwDirectorio.GetFileName(pwNombreArchivo);
        IF EXISTS(lwArch2) THEN
          ERROR(STRSUBSTNO(Text0004),lwArch2);
        lwDirectorio.MoveFile(pwNombreArchivo , lwArch2);
      END;

      CLEAR(lwDirectorio);
    END;

    PROCEDURE Ponceros@5(pwNumero@1103355000 : Integer;pwCuantos@1103355001 : Integer) : Code[20];
    VAR
      lwTexto@1103355002 : Code[20];
    BEGIN
      // PonCeros
      // A partir del entero pasado como parametro "pwNumero" devuelve un code, pero CON ceros delante en "pwCuantos" cifras


      lwTexto := FORMAT (pwNumero);

      IF STRLEN (lwTexto) < pwCuantos THEN
        REPEAT
          lwTexto := '0' + lwTexto;
        UNTIL STRLEN (lwTexto) >= pwCuantos;

      EXIT(lwTexto);
    END;

    PROCEDURE Traspasar@1103355004(pwNumImp@1103355000 : Integer;pwPrimera@1103355022 : Boolean);
    VAR
      lrCab@1103355001 : Record 7009992;
      lrLin@1103355002 : Record 7009993;
      lrLin2@1103355010 : Record 7009993;
      lrTmpLin@1103355008 : TEMPORARY Record 7009993;
      lrTmpLinAnt@1103355020 : TEMPORARY Record 7009993;
      lrTmpBono@1103355011 : TEMPORARY Record 7009993;
      lrFich@1103355003 : Record 7010082;
      lrCabInt@1103355005 : Record 7010076;
      lrPaxInt@1103355006 : Record 7010079;
      lrHotel@1103355012 : Record 7010078;
      lrServInt@1103355015 : Record 7010080;
      lrTempPaxsdia@1103355018 : TEMPORARY Record 7010079;
      lrConvTO@1103355024 : Record 7010161;
      lwIdCab@1103355007 : Integer;
      lwNumFichero@1103355004 : Integer;
      lwId@1103355009 : Integer;
      lwIdHotel@1103355013 : Integer;
      lwIDServ@1103355016 : Integer;
      lwIdPax@1103355017 : Integer;
      lwTipPer@1103355014 : ',Adulto,Ni¤o,Infant';
      lwExiste@1103355019 : Boolean;
      lwOk@1103355021 : Boolean;
      lwTTOOAg@1103355023 : Code[10];
    BEGIN
      // Traspasar

      // pwPrimera indica que es el primer traspaso de la importacion
      // en caso contrario la funci¢n viene para traspasar las lineas de importacion "Fecha Limite"

      IF pwNumImp =0 THEN
        EXIT;

      CLEAR(lrCab);
      lrCab.GET(pwNumImp);

      IF pwPrimera THEN BEGIN
        IF lrCab.Traspasado THEN
          ERROR(Text0005);
      END;

      IF lrCab.Anulado THEN
        ERROR(Text0006);

      IF pwPrimera THEN BEGIN
        IF NOT CONFIRM(Text0008, FALSE, pwNumImp) THEN
          EXIT;
      END;

      rParInt.FINDFIRST;

      CLEAR(lrTempPaxsdia);
      lrTempPaxsdia.DELETEALL;

      CLEAR(lwIdHotel);
      CLEAR(lwIdPax);
      ComprobarOrden(lrCab); // Comprobaciones
      IF pwPrimera THEN // Las bajas solo las comprobamos la primera vez
        CreaTempBajas(lrCab);
      // Creamos un temporal con todos los bonos afectados
      CLEAR(lrTmpBono);
      lrTmpBono.DELETEALL;

      // Juntamos las importaciones y las bajas en un solo temporal para tenerlo todo junto
      CLEAR(lrTmpLin);
      lrTmpLin.DELETEALL;
      CLEAR(lrTmpLinAnt);
      lrTmpLinAnt.DELETEALL;
      CLEAR(lrLin); // Lineas importacion
      lrLin.SETRANGE("No Importacion", lrCab.Num);
      lrLin.SETRANGE(Traspasado, FALSE);
      lrLin.SETRANGE(Anulado   , FALSE);
      IF lrLin.FINDSET THEN BEGIN
        wVentana.OPEN(Text0016 + ' @1@@@@@@@@@');
        wTotal := lrLin.COUNT;
        CLEAR(wCont);
        REPEAT
          lrTmpLin := lrLin;

          lwOk := PuedeTraspasar(lrTmpLin); // Establece condiciones por las que se puede traspasar
          IF lwOk THEN BEGIN
            // Miramos en este momento si se traba de una insercci¢n o una modificacion
            // JPT 14/07/08 Para ello creamos un segundo temporal para los bonos anteriores
            CLEAR(lrTmpLinAnt);
            lrTmpLinAnt.SETCURRENTKEY("No Importacion",Bono);
            lrTmpLinAnt.SETRANGE(Bono, lrLin.Bono);
            IF NOT lrTmpLinAnt.FIND('-') THEN BEGIN
              CLEAR(lrLin2);
              lrLin2.SETCURRENTKEY("No Importacion",Bono);
              lrLin2.SETFILTER("No Importacion", '<>%1', lrCab.Num);
              lrLin2.SETRANGE(Bono   , lrLin.Bono);
              lrLin2.SETRANGE(Anulado , FALSE);
              lrLin2.SETRANGE(Traspasado, TRUE);
              IF lrLin2.FINDLAST THEN BEGIN
                // Copiamos todos los registros del bono de la ultima importacion
                lrLin2.SETRANGE("No Importacion", lrLin2."No Importacion");
                lrLin2.FINDSET; // Posicionamos al principio
                REPEAT
                  lrTmpLinAnt := lrLin2;
                  lrTmpLinAnt.INSERT;
                UNTIL lrLin2.NEXT=0;
              END;
            END;

            { JPT 14/07/08 modifico el procedimiento a¤adiendo un nuevo temporal
            ya que se ha dado el caso de registros que entran con el mismo nombre hombre y mujer
            por lo que no busca el correcto

            CLEAR(lrLin2);
            lrLin2.SETCURRENTKEY("No Importacion",Bono);
            lrLin2.SETFILTER("No Importacion", '<>%1', lrCab.Num);
            lrLin2.SETRANGE(Bono   , lrLin.Bono);
            lrLin2.SETRANGE(Item   , lrLin.Item);
            lrLin2.SETRANGE(Nombre , lrLin.Nombre);
            lrLin2.SETRANGE(Anulado , FALSE);
            lrLin2.SETRANGE(Traspasado, TRUE);
            lrLin2.SETRANGE("Modificado Importacion",0);
            IF lrLin2.FINDLAST THEN BEGIN // Es una modificacion
            }

            lrTmpLinAnt.SETRANGE(Item   , lrLin.Item);
            lrTmpLinAnt.SETRANGE(Nombre , lrLin.Nombre);
            lrTmpLinAnt.SETRANGE(Anulado , FALSE);
            lrTmpLinAnt.SETRANGE(Traspasado, TRUE);
            lrTmpLinAnt.SETRANGE("Modificado Importacion",0);
            lrTmpLinAnt.SETRANGE("Tipo Persona", lrLin."Tipo Persona");
            IF lrTmpLinAnt.FINDFIRST THEN BEGIN // Es una modificacion
              // Comprobamos si son iguales
              IF ComparaLineas(lrLin,lrTmpLinAnt) THEN BEGIN
                lrTmpLin."No hay Cambios" := TRUE; // Con eso queremos se¤alar que ya existe y que no se ha modificado nada
                lrLin."No hay Cambios" := TRUE;
                lrLin.MODIFY;
              END
              ELSE BEGIN
                lrTmpLin."Tipo Registro"  := lrTmpLin."Tipo Registro"::Modificacion;
                // Aqui utilizamos "Modificado Importacion" y "Modificado Linea" "al reves"
                // para saber que lineas estamos modificando (solo en el temporal)
                lrTmpLin."Modificado Importacion" := lrTmpLinAnt."No Importacion";
                lrTmpLin."Modificado Linea"       := lrTmpLinAnt."No Linea";
              END;
              lrTmpLinAnt."Modificado Importacion" := 1; // Para que no vuelva a cojer este registro en la siguiente busqueda
              lrTmpLinAnt.MODIFY;
            END;

            InsertaTempBono(lrTmpBono, lrLin);
            lrTmpLin.INSERT;
          END;
          wCont +=1;
          IF wCont MOD 10 = 0 THEN
            wVentana.UPDATE(1, ROUND(wCont/wTotal*10000,1));
        UNTIL lrLin.NEXT=0;
        wVentana.CLOSE;
      END;

      // Utilizamos "Modificado Importacion" temporalmente para rellenar el campo
      // "Tipo Registro" de tipo Option. Asi 0=OK(inserccion), 1= Cancelacion, 2= Error, 3= Modificiacion

      CLEAR(rTempBaja); // Bajas
      IF rTempBaja.FINDSET THEN BEGIN
        lwId := lrTmpLin."No Linea";
        REPEAT
          CLEAR(lrTmpLin);
          lrTmpLin := rTempBaja;
          lwOk := PuedeTraspasar(lrTmpLin); // Establece condiciones por las que se puede traspasar
          IF lwOk THEN BEGIN
            lwId += 1;
            lrTmpLin."No Linea"       := lwId;
            lrTmpLin."No Importacion" := lrCab.Num;
            lrTmpLin.Anulado          := TRUE; // Utilizamos este campo para otros fines
            lrTmpLin.Traspasado       := FALSE;
            lrTmpLin."Tipo Registro"  := lrTmpLin."Tipo Registro"::Cancelacion; // Cancelacion
            // Aqui utilizamos "Modificado Importacion" y "Modificado Linea" "al reves"
            // para saber que lineas estamos modificando (solo en el temporal)
            lrTmpLin."Modificado Importacion" := rTempBaja."No Importacion";
            lrTmpLin."Modificado Linea"       := rTempBaja."No Linea";
            lrTmpLin."No hay Cambios" := FALSE;
            lrTmpLin.INSERT;

            // Modificamos las lineas del mismo bono que no se han modificado para que
            // aparezcan junto con las anulaciones
            lrTmpLin.SETRANGE(Bono, rTempBaja.Bono);
            lrTmpLin.SETRANGE("No hay Cambios", TRUE);
            IF lrTmpLin.FINDSET THEN BEGIN
              lrTmpLin.MODIFYALL("Tipo Registro" , lrTmpLin."Tipo Registro"::Modificacion);
              lrTmpLin.MODIFYALL("No hay Cambios", FALSE);
            END;

            InsertaTempBono(lrTmpBono, rTempBaja);
          END;
        UNTIL rTempBaja.NEXT=0;
      END;

      // Las reservas (bonos) que son exactamente iguales, que no ha sufrido ninguna modificaci¢n
      // no los traspasamos
      CLEAR(lrTmpBono);
      CLEAR(lrTmpLin);
      lrTmpLin.SETCURRENTKEY("No Importacion",Bono);
      IF lrTmpBono.FINDSET THEN BEGIN
        REPEAT
          lrTmpLin.SETRANGE(Bono, lrTmpBono.Bono);
          lrTmpLin.SETRANGE("No hay Cambios", FALSE);
          IF NOT lrTmpLin.FINDFIRST THEN BEGIN
            lrTmpLin.SETRANGE("No hay Cambios");
            lrTmpLin.DELETEALL;

            lrTmpBono.Anulado := TRUE; // As¡ sabemos que bonos no se han traspasado
            lrTmpBono.MODIFY;
          END;
        UNTIL lrTmpBono.NEXT=0;
      END;

      //. Realizamos la comprobacion previa de hoteles
      lwTTOOAg := lrConvTO.ConversionTouroperador(lrCab.TTOO, ''); //+$005

      //-$005lrConvTO.GET(lrCab.TTOO);
      //-$005lrConvTO.TESTFIELD("Touroperador Atennea");
      //-$005lwTTOOAg:= lrConvTO."Touroperador Atennea";

      IF ComprobarHoteles(lrTmpLin, lwTTOOAg, TRUE) THEN
        EXIT;

      // Seguidamente pasamos al traspaso propiamente dicho
      CLEAR(lrPaxInt);
      CLEAR(lrCabInt);
      CLEAR(lwIdCab);
      CLEAR(lrTmpLin);
      CLEAR(lrLin);
      CLEAR(lrTmpLinAnt); // Registro Anterior
      lrTmpLinAnt.DELETEALL; // Utilizamos el temporal para otra cosa totalmente distinta
      lrTmpLin.SETCURRENTKEY("No Importacion",Bono, Item);
      IF lrTmpLin.FIND('-') THEN BEGIN
        // Creamos un registro de importaciones. Buscamos el numero de importacion
        lwNumFichero := 1; // Por defecto si no se encuentra nada
        CLEAR(lrFich);
        IF lrFich.FINDLAST THEN
          lwNumFichero := lrFich."N§ Fichero" + 1;
        // Creamos el nuevo registro
        CLEAR(lrFich);
        lrFich."N§ Fichero"        := lwNumFichero;
        lrFich."Fecha importacion" := TODAY;
        lrFich."Hora importacion"  := TIME;
        lrFich.Usuario             := USERID;
        lrFich."Importacion MWR"   := lrCab.Num;
        lrFich.INSERT;
        REPEAT
          // Si es una anulaci¢n o un modificacion
          // Marcamos los registros anteriores modificados
          IF (lrTmpLin."Tipo Registro" IN [1,3]) THEN BEGIN
            CLEAR(lrLin2);
            IF lrLin2.GET(lrTmpLin."Modificado Importacion" , lrTmpLin."Modificado Linea") THEN BEGIN
              lrLin2."Modificado Importacion" := lrTmpLin."No Importacion";
              IF lrTmpLin."Tipo Registro" = lrTmpLin."Tipo Registro"::Cancelacion THEN
                lrLin2."Anulado Importacion"    := TRUE
              ELSE
                lrLin2."Modificado Linea"       := lrTmpLin."No Linea"; // Si es modificacion
              lrLin2.MODIFY;
            END;
          END
          ELSE
            lrTmpLin."Tipo Registro" := lrTmpLin."Tipo Registro"::Ok; // Inserccion

          IF (lrCabInt.TourOperador <> lrCab.TTOO) OR (lrCabInt.Bono <> lrTmpLin.Bono) THEN BEGIN
            // Insertamos una cabecera
            CLEAR(lrCabInt);
            lrCabInt.INIT;
            lrCabInt.Fichero           := lrFich."N§ Fichero";
            lwIdCab +=1;
            lrCabInt."ID Cabecera"     := lwIdCab;
            lrCabInt.TourOperador      := lrCab.TTOO;
            lrCabInt.Bono              := lrTmpLin.Bono;

            //-$001lrCabInt.Temporada         := rParInt."Temporada Importacion";
            lrCabInt.Temporada         := FORMAT(DATE2DMY(lrTmpLin."Fecha Venta", 3)); //+$001

            lrCabInt."Usuario proceso" := USERID;
            lrCabInt."Tipo Registro"   := -1; // Eso es para instanciarlo a indeterminado
            lrCabInt."Fecha creacion"  := lrTmpLin."Fecha Venta";
            lrCabInt.INSERT;
          END;
          // Paxes
          CLEAR(lrPaxInt);
          lrPaxInt.Fichero            := lrFich."N§ Fichero";
          lrPaxInt.TourOperador       := lrCab.TTOO;
          lrPaxInt.Bono               := lrTmpLin.Bono;

          //-$001lrPaxInt.Temporada          := rParInt."Temporada Importacion";
          lrPaxInt.Temporada := FORMAT(DATE2DMY(lrTmpLin."Fecha Venta", 3)); //+$001

          lrPaxInt.Contador           := ContPax(lrPaxInt);
          lrPaxInt.Edad               := lrTmpLin.Edad;

          // JPT 23/07/08 Como tipo de persona solo viene si es hombre o mujer
          // A trav‚s de la edad configuramos su tipo de persona
          // Si no encuentra su configuraci¢n le ponemos el tipo de viene que ser  adulto H o F
          //lrPaxInt."Tipo Persona"     := lrTmpLin."Tipo Persona";
          lrPaxInt."Tipo Persona" := BuscaTipoPers(lrPaxInt.TourOperador, lrPaxInt.Edad);
          IF lrPaxInt."Tipo Persona" = '' THEN
            lrPaxInt."Tipo Persona"     := lrTmpLin."Tipo Persona";

          // No puede tener una longitud mayor a 30 ya que toda la aplicaci¢n tiene este limite
          lrPaxInt.Nombre             := COPYSTR(lrTmpLin.Nombre,1,30);
          lrPaxInt."Tipo Registro"    := lrTmpLin."Tipo Registro";
          lrPaxInt."Fecha Entrada"    := lrTmpLin."Fecha Entrada";
          lrPaxInt."Fecha Salida"     := lrTmpLin."Fecha Salida";
          lrPaxInt.Habitacion         := lrTmpLin."Tipo Habitacion";

          lwExiste:= BuscaNombre(lrPaxInt,lrTmpLin."Fecha Entrada",lrTmpLin."Fecha Salida",lwIdPax, lrTempPaxsdia);

          IF lwExiste THEN BEGIN
            lrPaxInt.FIND; // recuperamos el puntero
            // Controla fechas en Pax
            IF (lrPaxInt."Fecha Entrada"=0D) OR (lrPaxInt."Fecha Entrada" > lrTmpLin."Fecha Entrada") THEN
              lrPaxInt."Fecha Entrada" := lrTmpLin."Fecha Entrada";
            IF lrPaxInt."Fecha Salida"< lrTmpLin."Fecha Salida" THEN
              lrPaxInt."Fecha Salida":= lrTmpLin."Fecha Salida";
            IF lrTmpLin."Tipo Registro" <> lrPaxInt."Tipo Registro" THEN
              lrPaxInt."Tipo Registro" := lrPaxInt."Tipo Registro"::Modificacion;
            lrPaxInt.MODIFY;
          END
          ELSE BEGIN // Si no existe crea un nuevo ocupante
            // Ya se le ha insertado el IdPax
            lrPaxInt.INSERT;
          END;



          // Ahora determinamos el campo "Tipo Registro" de la cabecera
          CASE lrPaxInt."Tipo Registro" OF
            0 : lwId:= 0;
            1 : lwId:= 2;
            3 : lwId:= 1;
          END;
          IF lrCabInt."Tipo Registro" <> lwId THEN BEGIN
            IF lrCabInt."Tipo Registro" = -1 THEN // Indeterminado
              lrCabInt."Tipo Registro" :=lwId
            ELSE
              lrCabInt."Tipo Registro" := 1; // Modificacion

            IF lrCabInt."Tipo Registro"= lrCabInt."Tipo Registro"::Borrado THEN
              lrCabInt."Fecha cancelacion" := TODAY
            ELSE
              lrCabInt."Fecha cancelacion" := 0D;

            IF lrCabInt."Tipo Registro"= lrCabInt."Tipo Registro"::Modificacion THEN
              lrCabInt."Fecha modificacion" := TODAY
            ELSE
              lrCabInt."Fecha modificacion" := 0D;

          END;

          // Insertamos pax por tipo persona
          lwTipPer := TipoPax(lrCab.TTOO , lrTmpLin."Tipo Persona");
          CASE lwTipPer OF
            lwTipPer::Adulto : lrCabInt.Adultos+=1;
            lwTipPer::Ni¤o   : lrCabInt.Ni¤os  +=1;
            lwTipPer::Infant : lrCabInt.Infants+=1;
            ELSE cFunImpLTU.inserta_error(lrCabInt,STRSUBSTNO(Text0012 , lrTmpLin."Tipo Persona"));
          END;

          // Insertamos los datos de Hotel
          { JPT 25/03/08 necesitamos introducir tantos "Hoteles Importacion" como Items
            de forma que los ocupantes vayan juntos seg£n Item
          IF (lrTmpLinAnt.Item <> lrTmpLin.Item) OR (lrTmpLinAnt.Bono <> lrTmpLin.Bono) OR
            (lrTmpLinAnt.Hotel <> lrTmpLin.Hotel) THEN BEGIN
            lrCabInt."No Servicios" +=1;
            JPT 22/12/08 Volvemos al sistema anterior. El sistema finalmente los metia en un solo
            peridodo 9 personas en una sola habitacion
          }

          CLEAR(lrHotel);
          lrHotel.SETCURRENTKEY(Fichero,Touroperador,Bono,Temporada);
          lrHotel.SETRANGE(Fichero        , lrFich."N§ Fichero");
          lrHotel.SETRANGE(Touroperador   , lrCab.TTOO);
          lrHotel.SETRANGE(Bono           , lrTmpLin.Bono);
          lrHotel.SETRANGE(Temporada      , lrPaxInt.Temporada);
          lrHotel.SETRANGE(Habitacion     , lrTmpLin."Tipo Habitacion");
          lrHotel.SETRANGE(Regimen        , lrTmpLin.Regimen);
          lrHotel.SETRANGE(Hotel          , lrTmpLin.Hotel);
          lrHotel.SETRANGE("Fecha entrada", lrTmpLin."Fecha Entrada");
          lrHotel.SETRANGE("Fecha salida" , lrTmpLin."Fecha Salida");
          IF NOT lrHotel.FIND('-') THEN BEGIN
            lrCabInt."No Servicios" +=1;

            CLEAR(lrHotel);
            lrHotel.Fichero         := lrFich."N§ Fichero";
            lwIdHotel +=1;

            lrHotel."ID Hotel"      := lwIdHotel;
            lrHotel.Touroperador    := lrCab.TTOO;
            lrHotel.Bono            := lrTmpLin.Bono;
            lrHotel.Temporada       := lrPaxInt.Temporada;
            lrHotel.Hotel           := lrTmpLin.Hotel;
            lrHotel.Habitacion      := lrTmpLin."Tipo Habitacion";
            lrHotel.Regimen         := lrTmpLin.Regimen;
            lrHotel."Fecha entrada" := lrTmpLin."Fecha Entrada";
            lrHotel."Fecha salida"  := lrTmpLin."Fecha Salida";
            lrHotel."N§ Servicio"   := lrCabInt."No Servicios";


            IF lrTmpLin.Hotel[9] = 'P' THEN
              lrHotel."Paquete asociado" := rParInt."Paquete Solo Hotel"
            ELSE
              lrHotel."Paquete asociado"  := rParInt."Paquete Hotel + Transfer";

            lrHotel."Tipo Registro" := ConvTipoRegPaxHotel(lrPaxInt."Tipo Registro");
            lrHotel.INSERT;

            IF lrCabInt.Paquete = '' THEN
              lrCabInt.Paquete := lrHotel."Paquete asociado";
          END;

          // Resulta que el numero de habitaciones que viene en el archivo el numero
          // de habitaciones por Item
          IF (lrTmpLinAnt.Item <> lrTmpLin.Item) OR (lrTmpLinAnt.Bono <> lrTmpLin.Bono) THEN
            lrHotel."N§ Habitaciones" += lrTmpLin."Num Habitaciones";

          IF lrHotel."Tipo Registro" <> ConvTipoRegPaxHotel(lrTmpLin."Tipo Registro") THEN
            lrHotel."Tipo Registro" := lrHotel."Tipo Registro"::Ok;  // Modificacion
          lrHotel.MODIFY;

          // Insertamos los servicios Hotel
          CLEAR(lrServInt);
          lrServInt.Fichero         := lrFich."N§ Fichero";
          lwIDServ +=1;
          lrServInt."ID Servicio"   := lwIDServ;
          lrServInt.Touroperador    := lrCabInt.TourOperador;
          lrServInt.Bono            := lrCabInt.Bono;
          lrServInt.Temporada       := lrCabInt.Temporada;
          lrServInt.Persona        := lrPaxInt.Contador;
          lrServInt."N§ Servicio"   := lrHotel."N§ Servicio";
          lrServInt."Tipo Servicio" := lrServInt."Tipo Servicio"::Hotel;
          lrServInt.INSERT;

          lrCabInt.MODIFY;

          // Marcamos el registro real
          lrLin := lrTmpLin;
          IF lrLin.FIND THEN BEGIN
            lrLin.VALIDATE(Traspasado, TRUE);
            lrLin."Tipo Registro" := lrTmpLin."Tipo Registro";
            lrLin."No hay Cambios":= lrTmpLin."No hay Cambios";
            lrLin.MODIFY;
          END;
          lrTmpLinAnt := lrTmpLin; // Registro anterior
        UNTIL lrTmpLin.NEXT=0;
      END;

      lrCab.Traspasado := TRUE;
      lrCab.MODIFY;

      IF lwIdCab= 0 THEN
        MESSAGE(Text0015)
      ELSE
        MESSAGE(Text0014, lwIdCab);

      // Funci¢n temporal para avisar al usuario de bonos ya importados
      // JPT 28/01/09 La desactivo ya que ha pasado el tiempo suficiente
      // CompImportacionesAntiguas(lrTmpBono);
    END;

    PROCEDURE Anular@1103355008();
    VAR
      lrLin@1103355000 : Record 7009993;
      lrLinFL@1103355001 : Record 7009869;
    BEGIN
      // Anular
      // Anula la importacion

      IF Anulado THEN
        ERROR(Text0006, Num);

      IF Traspasado THEN
        ERROR(Text0005, Num);

      IF NOT CONFIRM (Text0013, FALSE,  Num) THEN
        EXIT;

      CLEAR(lrLin);
      lrLin.SETRANGE("No Importacion", Num);
      IF lrLin.FINDSET THEN
        lrLin.MODIFYALL(Anulado, TRUE);

      Anulado:= TRUE;
      MODIFY;

      // Borramos las lineas de importacion Fecha Limite
      // Son las que no han entrado por tener una fecha limite posterior a la fecha de la importacion
      CLEAR(lrLinFL);
      lrLinFL.DELETEALL;
    END;

    PROCEDURE CreaTempBajas@1103355011(prCab@1103355001 : Record 7009992);
    VAR
      lrLin@1103355000 : Record 7009993;
      lrLin2@1103355002 : Record 7009993;
      lwBaja@1103355003 : Boolean;
    BEGIN
      // CreaTempBajas

      // Esta funci¢n crea un temporal con todas las reservas que se importaron una vez pero que no vienen
      // en este importaci¢n por lo que se consideraran baja

      CLEAR(rTempBaja);
      rTempBaja.DELETEALL;

      CLEAR(lrLin);
      CLEAR(lrLin2);

      lrLin2.SETCURRENTKEY("No Importacion",Bono, Item); // Importacion Actual
      lrLin2.SETRANGE("No Importacion", prCab.Num);

      wVentana.OPEN(Text0009);
      //  Buscamos en importaciones anteriores de las mismas fechas las reservas que no vengan en esta
      lrLin.SETCURRENTKEY("No Importacion","Fecha Entrada","Fecha Salida");
      lrLin.SETFILTER("No Importacion", '<%1', prCab.Num);
      lrLin.SETFILTER("Fecha Entrada", '>=%1', prCab."Fecha Desde");
      lrLin.SETRANGE(Anulado                 , FALSE);
      lrLin.SETRANGE("Modificado Importacion", 0);
      lrLin.SETRANGE(Traspasado              , TRUE);
      lrLin.SETRANGE(TTOO                    , prCab.TTOO);
      IF lrLin.FINDSET THEN BEGIN
        wTotal := lrLin.COUNT;
        wCont  := 0;
        REPEAT
          lrLin2.SETRANGE(Bono  , lrLin.Bono);
          lrLin2.SETRANGE(Item  , lrLin.Item);
          lrLin2.SETRANGE(Nombre, lrLin.Nombre);
          lwBaja := NOT lrLin2.FINDFIRST;
          IF lwBaja THEN BEGIN
            rTempBaja := lrLin;
            rTempBaja.INSERT;
          END;
          wCont     +=1;
          wVentana.UPDATE(1, ROUND(wCont/wTotal*10000,1));
        UNTIL lrLin.NEXT=0;
      END;
      wVentana.CLOSE;
    END;

    PROCEDURE BuscaTTOO@1103355006(VAR prCab@1103355000 : Record 7009992;pwText@1103355001 : Text[1024]);
    VAR
      lText001@1103355002 : TextConst 'ENU=Mandant;ESP=Mandant';
      lwText@1103355003 : Text[1024];
      lwPos@1103355004 : Integer;
      lwChar@1103355005 : Char;
      lwCont@1103355006 : Integer;
      lwOk@1103355007 : Boolean;
      lwTTOO@1103355008 : Code[10];
      lText002@1103355009 : TextConst 'ENU=Touroperator %1 has not been entered;ESP=No se ha insertado Touroperador en %1';
    BEGIN
      // BuscaTTOO

      // Buscamos el Touroperador en la cabecera del archivo y luego buscamos la conversi¢n
      lwText := pwText;
      lwPos := STRPOS(lwText, lText001);
      lwOk  := FALSE;
      CLEAR(lwTTOO);
      IF lwPos <> 0 THEN BEGIN
        lwText := DELSTR(lwText, lwPos, STRLEN(lText001));
        FOR lwCont := 1 TO STRLEN(lwText) DO BEGIN
          lwChar := lwText[lwCont];
          IF lwChar = 39 THEN // Comilla simple
            lwOk := NOT lwOk;
          IF lwOk AND (lwChar <> 39) THEN
            lwTTOO := lwTTOO + FORMAT(lwChar);
        END;
        IF lwTTOO = '' THEN
          ERROR(lText002, prCab.Archivo);

        prCab.VALIDATE(TTOO, lwTTOO);
        prCab.MODIFY;
      END;
    END;

    PROCEDURE ComprobarOrden@1103355007(VAR prCab@1103355000 : Record 7009992);
    VAR
      lrCab2@1103355001 : Record 7009992;
    BEGIN
      // ComprobarOrden
      // No dejamos traspasar importaciones si ya se ha traspasado una importacion posterior

      CLEAR(lrCab2);
      lrCab2.SETCURRENTKEY("Fecha Traspaso", Traspasado, Anulado);
      lrCab2.SETRANGE(Traspasado, TRUE);
      lrCab2.SETRANGE(Anulado   , FALSE);
      lrCab2.SETRANGE(TTOO      , prCab.TTOO);
      lrCab2.SETFILTER("Fecha Creacion", '>=%1', prCab."Fecha Creacion");
      lrCab2.SETFILTER(Num, '<>%1', prCab.Num);
      IF lrCab2.FINDFIRST THEN
        ERROR(Text0010, lrCab2.Num, lrCab2."Fecha Creacion");

      // Tampoco dejamos si hay importaciones anteriores sin traspasar ni anular
      CLEAR(lrCab2);
      lrCab2.SETCURRENTKEY("Fecha Traspaso", Traspasado, Anulado);
      lrCab2.SETRANGE(TTOO      , prCab.TTOO);
      lrCab2.SETRANGE(Traspasado, FALSE);
      lrCab2.SETRANGE(Anulado   , FALSE);
      lrCab2.SETFILTER("Fecha Creacion", '<%1', prCab."Fecha Creacion");
      lrCab2.SETFILTER(Num , '<>%1', prCab.Num);
      IF lrCab2.FINDFIRST THEN
        ERROR(Text0011, lrCab2.Num, lrCab2."Fecha Creacion");
    END;

    PROCEDURE ContPax@2(prPaxs@1103355000 : Record 7010079) : Integer;
    VAR
      lrPaxs@1103355001 : Record 7010079;
    BEGIN
      // ContPax
      // Devuelve el numero de contador de pax

      lrPaxs.RESET;
      lrPaxs.SETCURRENTKEY(Fichero,TourOperador,Bono,Temporada);
      lrPaxs.SETRANGE(Fichero     , prPaxs.Fichero);
      lrPaxs.SETRANGE(TourOperador, prPaxs.TourOperador);
      lrPaxs.SETRANGE(Bono        , prPaxs.Bono);
      lrPaxs.SETRANGE(Temporada   , prPaxs.Temporada);
      IF NOT lrPaxs.FINDLAST THEN
        CLEAR(lrPaxs);

      EXIT(lrPaxs.Contador + 1);
    END;

    PROCEDURE ComparaLineas@1103355010(VAR prLin@1103355000 : Record 7009993;VAR prLin2@1103355001 : Record 7009993) : Boolean;
    VAR
      lwOk@1103355002 : Boolean;
    BEGIN
      // ComparaLineas
      // Devuelve True si Son iguales, eso es si no tienen ninguna modificaci¢n

      lwOk := TRUE;

      lwOk := lwOk AND (prLin.Bono               = prLin2.Bono);
      lwOk := lwOk AND (prLin."Fecha Venta"      = prLin2."Fecha Venta");
      lwOk := lwOk AND (prLin."Tipo Persona"     = prLin2."Tipo Persona");
      lwOk := lwOk AND (prLin.Nombre             = prLin2.Nombre);
      lwOk := lwOk AND (prLin.Edad               = prLin2.Edad);
      lwOk := lwOk AND (prLin.Hotel              = prLin2.Hotel);
      //-$003lwOk := lwOk AND (prLin."Nombre Hotel"     = prLin2."Nombre Hotel");
      lwOk := lwOk AND (prLin."Fecha Entrada"    = prLin2."Fecha Entrada");
      lwOk := lwOk AND (prLin."Fecha Salida"     = prLin2."Fecha Salida");
      lwOk := lwOk AND (prLin."Num Habitaciones" = prLin2."Num Habitaciones");
      lwOk := lwOk AND (prLin."Tipo Habitacion"  = prLin2."Tipo Habitacion");
      lwOk := lwOk AND (prLin.Regimen            = prLin2.Regimen);

      EXIT(lwOk);
    END;

    PROCEDURE InsertaTempBono@1103355019(VAR prTmpBono@1103355000 : TEMPORARY Record 7009993;prLin@1103355002 : Record 7009993);
    BEGIN
      // InsertaTempBono
      // Inserta un registro de temporal de bono si no existe

      CLEAR(prTmpBono);
      prTmpBono.SETCURRENTKEY("No Importacion",Bono,Item);
      prTmpBono.SETRANGE(Bono, prLin.Bono);
      IF NOT prTmpBono.FINDFIRST THEN BEGIN
        prTmpBono."No Importacion" := prLin."No Importacion";
        prTmpBono."No Linea"       := prLin."No Linea";
        prTmpBono.Bono             := prLin.Bono;
        prTmpBono.INSERT;
      END;
    END;

    PROCEDURE TipoPax@3(pwTTOO@1103355000 : Code[10];pwPers@1103355001 : Code[10]) : Integer;
    VAR
      lrConv@1103355002 : Record 7009722;
      lrConvTO@1103355004 : Record 7010161;
      lwTipPer@1103355003 : ',Adulto,Ni¤o,Infant';
      lwTO@1000000000 : Code[10];
    BEGIN
      // TipoPax
      // Devuelve el tipo de persona que es
      // 0:No se encuentra
      // 1:Adulto
      // 2:Ni¤o
      // 3.Infant

      rParPer.GET;

      CLEAR(lwTipPer);

      //+$005 <
      lwTO := lrConvTO.ConversionTouroperador(pwTTOO, '');
      IF lwTO = '' THEN
        EXIT;
      //+$005 >

      //-$005lrCnvTTOO.GET(pwTTOO);
      //-$005lrCnvTTOO.TESTFIELD("Touroperador Atennea");

      //-$005IF lrConv.GET(lrCnvTTOO."Touroperador Atennea", pwPers) THEN
      IF lrConv.GET(lwTO, pwPers) THEN
      BEGIN
        CASE lrConv."Tipo Persona" OF
          rParPer."Codigo Adulto" : lwTipPer := 1;
          rParPer."Codigo Ni¤o"   : lwTipPer := 2;
          rParPer."Codigo Infant" : lwTipPer := 3;
          ELSE lwTipPer := 0;
        END;
      END;
      EXIT(lwTipPer);
    END;

    PROCEDURE BuscaNombre@13(VAR prPaxs@1103355000 : Record 7010079;pwFechaEntrada@1103355001 : Date;pwFechaSalida@1103355002 : Date;VAR pwIdPax@1103355003 : Integer;VAR prTempPaxsdia@1103355017 : TEMPORARY Record 7010079) : Boolean;
    VAR
      lwNombre@1103355005 : Text[50];
      lwContOcup@1103355006 : Integer;
      lwSalida@1103355007 : Boolean;
      lwDistintos@1103355008 : Boolean;
      lwOk@1103355009 : Boolean;
      lwFecha@1103355010 : Date;
      lwFechaSalida2@1103355004 : Date;
      lwNo@1103355011 : Integer;
      lwExiste@1103355012 : Boolean;
      lwExiste1@1103355013 : Boolean;
      lwExiste2@1103355014 : Boolean;
      lwIdPax@1103355015 : Integer;
      lwModifica@1103355016 : Boolean;
      lwModifica2@1103355019 : Boolean;
      lwLen@1103355018 : Integer;
    BEGIN
      // BuscaNombre
      // Esta funci¢n busca si ya existe nombre en el temporal
      // Si existe con el mismo hotel y habitaci¢n le incrementa un numero el nombre

      // ----  Comprobar si el nuevo nombre existe, en el mismo dia. Si se solapa en el tiempo quiere decir que son
      //       personas distintas

      // ----  para no duplicar
      // En todo caso devolvemos el ID pax . El existente si existe o el nuevo si corresponde

      CLEAR(lwContOcup);
      CLEAR(lwModifica);
      CLEAR(lwModifica2);

      REPEAT
        CLEAR(lwSalida);
        CLEAR(lwExiste); // Es la variable que vamos a devolver
        CLEAR(lwExiste1);// Es si existe con el nombre
        CLEAR(lwExiste2);// Es si existe con el nombre pero duplicando, por lo que se le a¤adir  un numero al nombre
        lwContOcup+=1;
        lwNombre := DELCHR(prPaxs.Nombre, '<>');
        IF lwContOcup > 1  THEN BEGIN
          lwLen := STRLEN(lwNombre) + STRLEN(FORMAT(lwContOcup)) + 1;
          IF lwLen > 30 THEN // Es el maximo que puede tener el nombre
            lwNombre := COPYSTR(lwNombre, 30 - (lwLen-30));
          lwNombre :=  lwNombre + '/' + FORMAT(lwContOcup);
        END;
        prTempPaxsdia.RESET;
        prTempPaxsdia.SETRANGE(Nombre    , lwNombre);
        prTempPaxsdia.SETRANGE(Bono      , prPaxs.Bono);

        lwExiste1:= prTempPaxsdia.FIND('-'); // Si existe el con el nombre
        IF lwExiste1 THEN BEGIN
          lwIdPax := prTempPaxsdia."ID Pax Real";
          // Miramos si es una modificacion
          // Para lo cual lo consideraremos si uno es Ok y otro Cancela (la suma de los dos da 1)
          REPEAT
            lwModifica := (prTempPaxsdia."Tipo Registro" = prTempPaxsdia."Tipo Registro"::Modificacion) OR
                          (prTempPaxsdia."Tipo Registro" + prPaxs."Tipo Registro"=1);
          UNTIL (prTempPaxsdia.NEXT=0) OR lwModifica;
        END;

        // Si existe el nombre miramos que no se duplique en su estancia, por los cual consideraremos otra persona
        IF lwExiste1 THEN BEGIN

          // Si es Ok filtra por cancelaci¢n, si es cancelaci¢n por Ok
          CLEAR(lwOk);
          // La fecha de salida no cuenta
          lwFechaSalida2 := pwFechaSalida;
          IF lwFechaSalida2 > pwFechaEntrada THEN //
            lwFechaSalida2 := lwFechaSalida2 -1;

          FOR lwFecha:= pwFechaEntrada TO lwFechaSalida2 DO BEGIN
            prTempPaxsdia.SETRANGE("Fecha Nacimiento", lwFecha);
            IF prTempPaxsdia.FIND('-') THEN BEGIN
              REPEAT
                // Considera que existe si lo encuentra para las mismas fechas pero que no sea un Borra/inserta
                // osea una modificacion
                // lwOk indica que es un Borra/inserta
                // Para lo cual lo consideraremos si uno es Ok y otro Cancela (la suma de los dos da 1)
                lwOk := prTempPaxsdia."Tipo Registro" + prPaxs."Tipo Registro" = 1;
                lwModifica2 := lwModifica2 OR lwOk;
                IF lwOk THEN BEGIN
                  prTempPaxsdia."Tipo Registro" := prTempPaxsdia."Tipo Registro"::Modificacion;
                  prTempPaxsdia.MODIFY;
                END;
              UNTIL prTempPaxsdia.NEXT=0;
              lwExiste2 := NOT lwModifica2;
            END;
          END;

        END;
        lwExiste := lwExiste1 AND (NOT lwExiste2);
      UNTIL NOT lwExiste2;

      prPaxs.Nombre := lwNombre;

      IF lwExiste THEN
        prPaxs."ID Pax" := lwIdPax
      ELSE BEGIN
        pwIdPax  +=1;
        prPaxs."ID Pax" := pwIdPax;
      END;

      IF lwExiste AND lwModifica THEN
        prPaxs."Tipo Registro" := prPaxs."Tipo Registro"::Modificacion;

      // Se crea un registro x dia en cualquier caso
      CLEAR(lwNo);
      prTempPaxsdia.RESET;
      prTempPaxsdia.ASCENDING(FALSE);
      IF prTempPaxsdia.FIND('-') THEN  // Buscamos el £ltimo identificador
        lwNo := prTempPaxsdia."ID Pax";

      // Utilizamos la fecha de nacimiento para tener una reserva x dia
      lwFechaSalida2 := pwFechaSalida;
      IF lwFechaSalida2 > pwFechaEntrada THEN // La fecha de salida no cuenta
        lwFechaSalida2 := lwFechaSalida2 -1;
      FOR lwFecha:= pwFechaEntrada TO lwFechaSalida2 DO BEGIN
        prTempPaxsdia:= prPaxs;
        lwNo +=1;
        prTempPaxsdia."ID Pax" := lwNo;
        prTempPaxsdia."Fecha Nacimiento" := lwFecha;
        prTempPaxsdia."ID Pax Real"      := prPaxs."ID Pax";
        prTempPaxsdia.INSERT;
      END;

      EXIT(lwExiste);
    END;

    PROCEDURE ConvTipoRegPaxHotel@1103355009(pwValor@1103355000 : Integer) : Integer;
    VAR
      lwVal@1103355001 : Integer;
    BEGIN
      // ConvTipoRegPaxHotel
      // Resulta que el campo tipo de Registro no vale igual en los Pax que en la cabecra
      // ni en los hoteles. La siguiente funci¢n convierte los valores de Pax a Hotel

      CLEAR(lwVal);

      CASE pwValor OF
        0 : lwVal := 0;
        1 : lwVal := 2;
        2 : lwVal := 3;
        3 : lwVal := 0;
      END;

      EXIT(lwVal);
    END;

    PROCEDURE CompImportacionesAntiguas@1103355013(VAR prTmpBono@1103355000 : TEMPORARY Record 7009993);
    VAR
      lrExcel@1103355001 : TEMPORARY Record 7009785;
      lrCab@1103355004 : Record 7009741;
      lwFila@1103355002 : Integer;
      lwCol@1103355003 : Integer;
      lwEnc@1103355005 : Boolean;
      lwText001@1103355006 : TextConst 'ENU=WARNING;ESP=ATENCION';
      lwText002@1103355007 : TextConst 'ENU=The next vouchers have already been transferred;ESP=Los siguientes Bonos ya han sido traspasados con anterioriodad.';
      lwText003@1103355008 : TextConst 'ENU=Check Vouchers;ESP=Comprobar Bonos';
      lwText004@1103355009 : TextConst 'ENU=Check them out before transferring to bookings;ESP=Compruebelos antes de traspasar definitivamente a reservas';
    BEGIN
      // CompImportacionesAntiguas

      // ESTAN FUNCIàN SOLO TIENE SENTIDO LOS 20 PRIMEROS DIAS DE FUNCIONAR EL INTERFASE
      // YA QUE NO SE COMPRUEBA LAS RESERVAS REALES PARA SABER SI SE TRATA DE UNA MODIFICACION
      // SI NO QUE SE TRABAJA SOBRE LOS REGISTROS PREVIOS DE IMPORTACION MWR
      // ESTA FUNCIàN AVISA AL USUARIO SI SE HA MODIFICADO ALGéN BONO YA EXISTENTE
      // PASADO ESTE TIEMPO, LA FUNCION PUEDE ELIMINARSE TRANQUILAMENTE

      CLEAR(lrExcel);
      lrExcel.DELETEALL;
      CLEAR(lwFila);

      lwFila +=1;
      lrExcel.VALIDATE("Row No."    , lwFila);
      lrExcel.VALIDATE("Column No." , 1);
      lrExcel."Cell Value as Text" := lwText001;
      lrExcel."Tama¤o Fuente" := 20;
      lrExcel.Bold            := TRUE;
      lrExcel.INSERT;

      CLEAR(lrExcel);
      lwFila +=1;
      lrExcel.VALIDATE("Row No."    , lwFila);
      lrExcel.VALIDATE("Column No." , 1);
      lrExcel."Cell Value as Text" := lwText002;
      lrExcel."Tama¤o Fuente" := 12;
      lrExcel.INSERT;

      lwFila +=1;
      lrExcel.VALIDATE("Row No."    , lwFila);
      lrExcel."Cell Value as Text" := lwText004;
      lrExcel.INSERT;
      CLEAR(lrExcel);

      lwFila +=2;

      CLEAR(lwEnc);
      CLEAR(prTmpBono);
      prTmpBono.SETRANGE(Anulado, FALSE); // Quitamos los que no se van a traspasar por no tener cambios
      IF prTmpBono.FINDSET THEN BEGIN
        REPEAT
          CLEAR(lrCab);
          lrCab.SETCURRENTKEY(TourOperador,Bono,Temporada);
          lrCab.SETRANGE(Bono, prTmpBono.Bono);
          IF lrCab.FINDFIRST THEN BEGIN
            lwFila +=1;
            lrExcel.VALIDATE("Row No."    , lwFila);
            lrExcel.VALIDATE("Column No." , 1);
            lrExcel."Cell Value as Text" := prTmpBono.Bono;
            lrExcel.INSERT;

            lwEnc := TRUE;
          END;
        UNTIL prTmpBono.NEXT=0;
      END;


      IF lwEnc THEN BEGIN // Si se ha encontrado alg£n caso se lanza el excel
        lrExcel.CreateBook;
        lrExcel.CreateSheet(lwText003,'',COMPANYNAME,USERID,FALSE,FALSE,'');
        lrExcel.GiveUserControl;
      END;
    END;

    PROCEDURE PuedeTraspasar@1103355012(prTmpLin@1103355000 : TEMPORARY Record 7009993) : Boolean;
    VAR
      lwOk@1103355001 : Boolean;
    BEGIN
      // PuedeTraspasar

      // No se van a traspasar determinadas reservas que tengan la fecha reserva o
      // fecha venta anterior de una fecha determinada seg£n la delegaci¢n

      lwOk := TRUE;
      IF (rParInt."MWR Desde Fecha Llegada" <> 0D) AND (prTmpLin."Fecha Entrada" < rParInt."MWR Desde Fecha Llegada") THEN
        lwOk := FALSE;

      IF (rParInt."MWR Desde Fecha Venta" <> 0D) AND (prTmpLin."Fecha Venta" < rParInt."MWR Desde Fecha Venta") THEN
        lwOk := FALSE;

      EXIT(lwOk);
    END;

    PROCEDURE BuscaTipoPers@1103355014(pwTTOO@1103355000 : Code[10];pwEdad@1103355001 : Integer) : Code[10];
    VAR
      lwTipo@1103355002 : Code[10];
      lwTO@1000000000 : Code[10];
      lrConv@1103355003 : Record 7009722;
      lrConvTo@1103355004 : Record 7010161;
    BEGIN
      // BuscaTipoPers

      CLEAR(lwTipo);
      IF (pwTTOO = '') OR (pwEdad = 0) THEN
        EXIT;

      //+$005 <
      lwTO := lrConvTo.ConversionTouroperador(pwTTOO, '');
      IF lwTO = '' THEN
        EXIT;
      //+$005 >

      //-$005IF NOT lrConvTo.GET(pwTTOO) THEN
      //-$005  EXIT;

      CLEAR(lrConv);
      //-$005lrConv.SETRANGE(TourOperador, lrConvTo."Touroperador Atennea");
      lrConv.SETRANGE(TourOperador  , lwTO);
      lrConv.SETFILTER("Edad Minima", '<=%1', pwEdad);
      lrConv.SETFILTER("Edad Maxima", '>=%1', pwEdad);
      IF lrConv.FINDFIRST THEN
        lwTipo := lrConv."Tipo Persona TO";

      EXIT(lwTipo);
    END;

    PROCEDURE ComprobarHoteles@1103355015(VAR prTmpLin@1103355001 : TEMPORARY Record 7009993;pwTTOO@1103355009 : Code[10];pwMostrar@1103355000 : Boolean) : Boolean;
    VAR
      lwCasos@1103355002 : Boolean;
      rTemp@1103355003 : TEMPORARY Record 7009724;
      lfForm@1103355004 : Form 7010011;
      lText0003@1103355005 : TextConst 'ENU=Checking Hotels;ESP=Comprobando Hoteles';
      wVentana2@1103355006 : Dialog;
      lwTotal@1103355007 : Integer;
      lwCont@1103355008 : Integer;
    BEGIN
      // ComprobarHoteles
      // Esta funci¢n realiza una comprobaci¢n previa de los hoteles del archivo
      // Si encuentra alguno sin codificar Devuelve true
      // Adem s rellena un archivo temporal con los nombre de los hoteles y su descripci¢n
      // pwMostrar indica que debe ense¤ar dicho temporal en una ventana

      rParInt.TESTFIELD("Touroperador importacion");

      CLEAR(lwCasos);
      CLEAR(prTmpLin);
      IF prTmpLin.FINDSET THEN BEGIN
        wVentana2.OPEN(lText0003 + ' @1@@@@@@@@@@@');
        lwTotal := prTmpLin.COUNT;
        CLEAR(lwCont);
        REPEAT
          IF NOT cFunImpLTU2.CompHot(rParInt."Touroperador importacion", pwTTOO, prTmpLin.Hotel,
                                    prTmpLin."Nombre Hotel", '', rTemp)  THEN
            lwCasos := TRUE;
          lwCont +=1;
          wVentana2.UPDATE(1, ROUND(lwCont/lwTotal*10000,1));
        UNTIL prTmpLin.NEXT=0;
        wVentana2.CLOSE;
      END;

      IF pwMostrar AND lwCasos THEN BEGIN
        CLEAR(lfForm);
        lfForm.SetTemp(rTemp);
        lfForm.RUN;
      END;

      EXIT(lwCasos)
    END;

    LOCAL PROCEDURE _Depurar@1100217000();
    VAR
      lrLin@1100217000 : Record 7009993;
      lwFechaLimite@1100217001 : Date;
      lwDialog@1100217002 : Dialog;
    BEGIN
      // _Depurar

      lwFechaLimite := TODAY - (3 * 365);

      lwDialog.OPEN(Text0017);

      lrLin.RESET;
      lrLin.SETCURRENTKEY("No Importacion", "Fecha Entrada", "Fecha Salida");
      lrLin.SETFILTER("Fecha Salida", '<=%1', lwFechaLimite);
      IF lrLin.FINDSET(TRUE) THEN
        lrLin.DELETEALL;

      lwDialog.CLOSE;
    END;

    BEGIN
    {
      $001 AJS 26102011 Modifico el proceso para no utilizar el parametro Temporada Importacion, se toma de la fecha de creacion

      $002 AJS 14102012 Nueva funcion _Depurar para eliminar informacion obsoleta despues de importar

      $003 AJS 19032014 Modifico la funcion ComparaLineas para que no revise el nombre del hotel

      $004 AJS 28102014 Amplio la variable lwNombre de la funcion BuscaNombre a Text50

      $005 AJS 15012015 Utilizar la funcion de conversion de touroperador de la tabla de conversiones
    }
    END.
  }
}
