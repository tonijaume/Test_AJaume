OBJECT Codeunit 7009736 Funciones agrupaciones
{
  OBJECT-PROPERTIES
  {
    Date=17/06/15;
    Time=16:47:26;
    Modified=Yes;
    Version List=AIC2009,OC-14044;
  }
  PROPERTIES
  {
    OnRun=BEGIN
            ExportacionProvXML(0);
          END;

  }
  CODE
  {
    VAR
      Text000@1103355006 : TextConst 'ENU=Generate current,Generate filtered;ESP=Generar actual,Generar filtradas';
      Text001@1103355007 : TextConst 'ENU=Return current,Return filtered;ESP=Retroceder actual,Retroceder filtradas';
      Text002@1103355008 : TextConst 'ENU=Confirm current,Confirm filtered;ESP=Confirmar actual,Confirmar filtradas';
      Text003@1103355009 : TextConst 'ENU=Cancel current,Cancel filtered;ESP=Desconfirmar actual,Desconfirmar filtradas';
      Text004@1103355010 : TextConst 'ENU=TRNC;ESP=TRNC';
      Text005@1103355011 : TextConst 'ENU=Unable to Cancel the service %1 due to validated costs;ESP=No se puede desconfirmar la agrupacion %1 porque tiene costes validados.';
      Text006@1103355012 : TextConst 'ENU=TRNI;ESP=TRNI';
      Text007@1103355013 : TextConst 'ENU=Invoiced lines in service %1 have been detected,\;ESP=Se han detectado lineas facturadas de la agrupaci¢n %1,\';
      Text008@1103355014 : TextConst 'ENU=Would you like to create credit memos for this lines?;ESP=¨desea crear abonos para estas lineas?';
      Text009@1103355015 : TextConst 'ENU=Unable to Cancel the service %1 due to invoiced lines;ESP=No se puede desconfirmar la agrupacion %1, porque tiene lineas facturadas.';
      Text010@1103355016 : TextConst 'ENU=Do you want to calculate again the cost of service %1?;ESP=Esta seguro de que desea recalcular el coste de la agrupacion %1';
      Text011@1103355017 : TextConst 'ENU=Unable to calculate again the service %1, due to validated lines;ESP=No se puede recalcular la agrupacion %1, porque tiene lineas validadas.';
      Text016@1103355022 : TextConst 'ENU=Surcharge %1 is going to be add to all bookings of services, continue;ESP=Se va a a¤adir el suplemento %1 a todas las reservas de las agrupaciones, continuar';
      Text017@1103355023 : TextConst 'ENU=&Current service,&Filtered services;ESP=Agrupacion &actual,Agruciones &Filtradas';
      Text018@1103355024 : TextConst 'ENU=CANCEL IBR GRO. #1##### SUPPL #2#####################;ESP=ANULA FPR AGR. #1##### PROV #2#####################';
      Text021@1103355027 : TextConst 'ENU=Accounts setup for Touroperator %1 does not exist \;ESP=No existe el fichero de Cuentas para el Touroperador %1 \';
      Text022@1103355028 : TextConst 'ENU=in destination %2.;ESP=en la Delegacion %2, ni la ficha generica.';
      Text023@1103355029 : TextConst 'ENU=Supplier posting group %1 does not exist;ESP=No existe el Grupo contable proveedor %1.';
      Text024@1103355030 : TextConst 'ENU=Supplier %1 does not exist;ESP=No existe el proveedor %1';
      Text025@1103355031 : TextConst 'ENU=Carrier %1 does not exist;ESP=No existe el transportista %1.';
      cCalTra@1103355000 : Codeunit 7009734;
      opcion@1103355005 : Integer;
      Text026@1103355032 : TextConst 'ENU=RESTRICT THE ASSIGNMENT BY TYPE OF PERSON\TYPE OF PERSON #1########;ESP=RESTRINGIR LA ASIGNACION POR TIPO PERSONA\TIPO PERSONA #1########';
      Text029@1103355034 : TextConst 'ENU=Surcharge %1 is going to be add to all bookings of person type %2 of service, continue;ESP=Se va a a¤adir el suplemento %1 a todas las reservas de tipo persona %2 de las agrupaciones, continuar';
      Text030@1100253000 : TextConst 'ENU=No Porter Rate found;ESP=No se encontr¢ Tarifa Maletero para %1';
      Text031@1100253001 : TextConst 'ENU="There is no price in the porter rate number %1 for %2 Persons ";ESP=No se encontr¢ precio en la Tarifa Maletero %1 para %2 Paxes';
      Text032@1100253002 : TextConst 'ENU=No Transfer Guide Rate found;ESP=No se encontr¢ Tarifa Guia Transfer para %1';
      Text033@1100253003 : TextConst 'ENU=No price found for %2 Paxes;ESP=No se encontr¢ precio en la Tarifa Guia Traslado %1 para %2 Paxes';
      Text034@1100217000 : TextConst 'ENU=You cannot confirm the service, there are contract errors.;ESP=No se puede confirmar el servicio, hay errores de contrato.';
      autXML@1000000001 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 6.0:{F6D90F11-9C73-11D3-B32E-00C04F990BB4}:'Microsoft XML, v6.0'.Unknown Class";
      Text035@1000000000 : TextConst 'ENU="Are you sure to ";ESP=¨Est  seguro de que desea fusionar las dos agrupaciones seleccionadas?';

    PROCEDURE calcular_margenes@1(solo_visualizar@1103355000 : Boolean;VAR rAgr@1103355001 : Record 7009796);
    VAR
      lcFunSeg@1100217000 : Codeunit 7009751;
      lrMargen@1000000000 : Record 7009808;
      lrCab@1000000001 : Record 7009806;
      lfCabCal@1000000002 : Form 7009931;
    BEGIN
      // calcular_margenes

      lcFunSeg.TienePermiso('TRF-CAL-AGR', TRUE);

      IF NOT solo_visualizar THEN
      BEGIN
        lrMargen.RESET;
        lrMargen.SETRANGE(Agrupacion, rAgr."N§ Agrupacion");
        IF lrMargen.FINDSET(TRUE) THEN
          lrMargen.DELETEALL;

        rAgr."Tipo Calculo" := rAgr."Tipo Calculo"::Margenes;
        rAgr.MODIFY;
        COMMIT;
        cCalTra.calcular_agrupacion(rAgr, FALSE);
        COMMIT;
      END;

      lrCab.RESET;
      lrCab.SETRANGE(Usuario   , USERID);
      lrCab.SETRANGE(Agrupacion, rAgr."N§ Agrupacion");

      CLEAR(lfCabCal);
      lfCabCal.SETTABLEVIEW(lrCab);
      lfCabCal.RUNMODAL;
    END;

    PROCEDURE calcular_margenesSin@10(VAR rAgr@1103355000 : Record 7009796);
    VAR
      lrMargen@1000000000 : Record 7009808;
    BEGIN
      // calcular_margenesSin
      // JPT 08/08/05 Calcula los margenes de la agrupaci¢n sin visualizar

      lrMargen.RESET;
      lrMargen.SETRANGE(Agrupacion, rAgr."N§ Agrupacion");
      IF lrMargen.FINDSET(TRUE) THEN
        lrMargen.DELETEALL;
      rAgr."Tipo Calculo" := rAgr."Tipo Calculo"::Margenes;
      rAgr.MODIFY;

      cCalTra.calcular_agrupacion(rAgr, FALSE);
    END;

    PROCEDURE generar_servicios@2(VAR rAgr@1103355000 : Record 7009796);
    VAR
      agrupacion@1103355001 : Record 7009796;
      agrupacion2@1103355002 : Record 7009796;
      lrMargen@1000000000 : Record 7009808;
    BEGIN
      // generar_servicios

      agrupacion.RESET;
      opcion := STRMENU(Text000, 1);
      CASE opcion OF
        0, 3: EXIT;
        1: agrupacion.SETRANGE("N§ Agrupacion", rAgr."N§ Agrupacion");
        2: agrupacion.COPYFILTERS(rAgr);
      END;
      IF agrupacion.FINDSET(TRUE) THEN BEGIN
        REPEAT
          lrMargen.RESET;
          lrMargen.SETRANGE(Agrupacion, agrupacion."N§ Agrupacion");
          IF lrMargen.FINDSET(TRUE) THEN
            lrMargen.DELETEALL;
          agrupacion."Tipo Calculo" := rAgr."Tipo Calculo"::Margenes;
          agrupacion.MODIFY;
          COMMIT;

          cCalTra.calcular_agrupacion(agrupacion, FALSE);
          agrupacion.GET(agrupacion."N§ Agrupacion");
          agrupacion2 := agrupacion;
          agrupacion2.Estado := agrupacion2.Estado::Generado;
          agrupacion2.MODIFY;
        UNTIL agrupacion.NEXT = 0;
      END;
    END;

    PROCEDURE retroceder_servicios@3(VAR rAgr@1103355000 : Record 7009796);
    VAR
      agrupacion@1103355001 : Record 7009796;
      lrMargen@1000000000 : Record 7009808;
    BEGIN
      // retroceder_servicios

      agrupacion.RESET;
      opcion := STRMENU(Text001, 1);
      CASE opcion OF
        0, 3: EXIT;
        1: agrupacion.SETRANGE("N§ Agrupacion", rAgr."N§ Agrupacion");
        2: agrupacion.COPYFILTERS(rAgr);
      END;
      IF agrupacion.FINDSET(TRUE) THEN BEGIN
        REPEAT
          lrMargen.RESET;
          lrMargen.SETRANGE(Agrupacion, agrupacion."N§ Agrupacion");
          IF lrMargen.FINDSET(TRUE) THEN
            lrMargen.DELETEALL;
          agrupacion.Estado := agrupacion.Estado::Pendiente;
          agrupacion.MODIFY;
        UNTIL agrupacion.NEXT = 0;
      END;
    END;

    PROCEDURE confirmar_servicios@4(VAR rAgr@1103355000 : Record 7009796);
    VAR
      agrupacion@1103355001 : Record 7009796;
      agrupacion2@1103355002 : Record 7009796;
      rError@1103355003 : Record 7009807;
      lrICD@1100217000 : Record 7010264;
      locrCab@1100253000 : Record 7009806;
      locrLinTO@1100253001 : Record 7009804;
      locrLinZon@1100253002 : Record 7009812;
      lrMargen@1000000000 : Record 7009808;
    BEGIN
      // confirmar_servicios

      agrupacion.RESET;
      opcion := STRMENU(Text002, 1);
      CASE opcion OF
        0, 3: EXIT;
        1: agrupacion.SETRANGE("N§ Agrupacion", rAgr."N§ Agrupacion");
        2: agrupacion.COPYFILTERS(rAgr);
      END;
      IF agrupacion.FINDSET(TRUE) THEN BEGIN
        REPEAT
          lrMargen.RESET;
          lrMargen.SETRANGE(Agrupacion, agrupacion."N§ Agrupacion");
          IF lrMargen.FINDSET(TRUE) THEN
            lrMargen.DELETEALL;
          agrupacion."Tipo Calculo" := rAgr."Tipo Calculo"::"Coste/Ingreso";
          agrupacion.MODIFY;
          COMMIT;

          cCalTra.calcular_agrupacion(agrupacion, FALSE);

          //+$005 <
          rError.RESET;
          rError.SETRANGE(Agrupacion     , agrupacion."N§ Agrupacion");
          rError.SETRANGE("Error critico", TRUE);
          IF NOT rError.ISEMPTY THEN
            ERROR(Text034);
          //+$005 >

          agrupacion.GET(agrupacion."N§ Agrupacion");
          agrupacion2 := agrupacion;
          agrupacion2.Estado                 := agrupacion2.Estado::Confirmado;
          agrupacion2."Usuario confirmacion" := USERID;
          agrupacion2.MODIFY;

          //+$001
          //. Eliminamos los temporales del calculo

          locrCab.RESET;
          locrCab.SETRANGE(Agrupacion, agrupacion."N§ Agrupacion");
          IF locrCab.FINDSET(TRUE) THEN
            locrCab.DELETEALL;

          locrLinTO.RESET;
          locrLinTO.SETRANGE(Agrupacion, agrupacion."N§ Agrupacion");
          IF locrLinTO.FINDSET(TRUE) THEN
            locrLinTO.DELETEALL;

          locrLinZon.RESET;
          locrLinZon.SETRANGE(Agrupacion, agrupacion."N§ Agrupacion");
          IF locrLinZon.FINDSET(TRUE) THEN
            locrLinZon.DELETEALL;
          //+$001

         // $002 JPT 02/05/12 CNT-CAR12004-05
         _BuscaTarifaMaleteros(agrupacion);
         // $003 JPT 09/05/12 CNT-CAR-12004-TRA06
         _BuscaTarifaGuiasTransf(agrupacion);

         lrICD.MarkPeriodTrf(agrupacion.Fecha); //+$010
        UNTIL agrupacion.NEXT = 0;
      END;
      agrupacion.RESET;
    END;

    PROCEDURE desconfirmar_servicios@5(VAR rAgr@1103355000 : Record 7009796);
    VAR
      agrupacion@1103355001 : Record 7009796;
      agrupacion2@1103355002 : Record 7009796;
      lrICD@1100217000 : Record 7010264;
      lrCI@1000000000 : Record 7009805;
      cAnulAgr@1103355003 : Codeunit 7009740;
      TextoConfirm@1103355004 : Text[150];
    BEGIN
      // desconfirmar_servicios

      agrupacion.RESET;
      opcion := STRMENU(Text003, 1);
      CASE opcion OF
        0, 3: EXIT;
        1: agrupacion.SETRANGE("N§ Agrupacion", rAgr."N§ Agrupacion");
        2: agrupacion.COPYFILTERS(rAgr);
      END;

      IF agrupacion.FINDSET(TRUE) THEN
      BEGIN
        REPEAT
          lrCI.RESET;
          lrCI.SETRANGE (Agrupacion   , agrupacion."N§ Agrupacion");
          lrCI.SETRANGE (Concepto     , Text004);
          lrCI.SETFILTER("N§ Factura" , '<>%1', '');
          IF lrCI.FINDFIRST THEN
            ERROR(Text005, agrupacion."N§ Agrupacion");

          lrCI.SETRANGE (Concepto     , Text006);
          IF lrCI.FINDFIRST THEN
          BEGIN
            TextoConfirm := STRSUBSTNO(Text007 +
                                       Text008, agrupacion."N§ Agrupacion");
            IF NOT CONFIRM(TextoConfirm) THEN
              ERROR(Text009,
                    agrupacion."N§ Agrupacion")
            ELSE
              cAnulAgr.Anular_Agrupacion(agrupacion);
          END;

          retroceder_fpr(agrupacion."N§ Agrupacion");
          lrCI.SETRANGE("N§ Factura");
          lrCI.SETRANGE(Concepto);
          IF lrCI.FINDSET(TRUE) THEN
            lrCI.DELETEALL;

          agrupacion2 := agrupacion;
          agrupacion2.Estado := agrupacion2.Estado::Generado;
          agrupacion2.MODIFY;

          lrICD.MarkPeriodTrf(agrupacion.Fecha); //+$010
        UNTIL agrupacion.NEXT = 0;
      END;
      agrupacion.RESET;
    END;

    PROCEDURE recalcular_coste@6(VAR rAgr@1103355000 : Record 7009796);
    BEGIN
      // recalcular_coste

      IF NOT CONFIRM(STRSUBSTNO(Text010, rAgr."N§ Agrupacion")) THEN
        EXIT;

      RecalculaCosteAgrupacion(rAgr); //+$016
    END;

    PROCEDURE RecalculaCosteAgrupacion@1000000001(VAR prAgr@1000000000 : Record 7009796);
    VAR
      lrCI@1000000002 : Record 7009805;
      lrICD@1000000001 : Record 7010264;
    BEGIN
      // RecalculaCosteAgrupacion

      lrCI.RESET;
      lrCI.SETRANGE (Agrupacion  , prAgr."N§ Agrupacion");
      lrCI.SETRANGE (Concepto    , 'TRNC');
      lrCI.SETFILTER("N§ Factura", '<>%1', '');
      IF lrCI.FINDFIRST THEN
        ERROR(Text011, prAgr."N§ Agrupacion");

      retroceder_fpr(prAgr."N§ Agrupacion");

      IF lrCI.FINDSET(TRUE) THEN
        lrCI.DELETEALL;

      prAgr."Tipo Calculo"         := prAgr."Tipo Calculo"::"Coste/Ingreso";
      prAgr."Pendiente recalcular" := FALSE;
      prAgr.MODIFY;
      COMMIT;

      cCalTra.calcular_agrupacion(prAgr, TRUE);

      lrICD.MarkPeriodTrf(prAgr.Fecha); //+$010
    END;

    PROCEDURE asignar_suplemento@7(VAR par_agr@1103355000 : Record 7009796);
    VAR
      rRsv@1103355001 : Record 7009744;
      rEle@1103355002 : Record 7009792;
      rEleAux@1103355003 : Record 7009792;
      lrTip@1103355004 : Record 7009715;
      lfSuplementos@1000000000 : Form 7009719;
      lrTipPersona@1103355011 : Record 7009715;
      lfTipoPersona@1000000001 : Form 7009712;
      lrAgr@1103355005 : Record 7009796;
      ventana@1103355006 : Dialog;
      w_personas@1103355007 : Integer;
      w_opcion@1103355008 : Integer;
      w_tipo@1103355009 : Code[10];
      texto_confirm@1103355010 : Text[250];
    BEGIN
      // asignar_suplemento

      //. Pedimos el suplemento
      lrTip.RESET;
      lrTip.SETRANGE(Humano, FALSE);

      CLEAR(lfSuplementos);
      lfSuplementos.SETTABLEVIEW(lrTip);
      lfSuplementos.LOOKUPMODE(TRUE);
      IF lfSuplementos.RUNMODAL <> ACTION::LookupOK THEN
        EXIT
      ELSE
        lfSuplementos.GETRECORD(lrTip);

      //. Vamos a permitir al usuario seleccionar si solo quiere aplicar el suplemento a un tipo de persona
      lrTipPersona.RESET;
      lrTipPersona.SETRANGE (Humano         , TRUE);
      lrTipPersona.SETFILTER("Tipo elemento", '<>%1', '');

      CLEAR(lfTipoPersona);
      lfTipoPersona.SETTABLEVIEW(lrTipPersona);
      lfTipoPersona.LOOKUPMODE(TRUE);
      IF lfTipoPersona.RUNMODAL <> ACTION::LookupOK THEN
        CLEAR(lrTipPersona)
      ELSE
        lfTipoPersona.GETRECORD(lrTipPersona);

      IF lrTipPersona."Tipo elemento" = '' THEN
        texto_confirm := STRSUBSTNO(Text016, lrTip."Tipo elemento")
      ELSE
        texto_confirm := STRSUBSTNO(Text029, lrTip."Tipo elemento", lrTipPersona."Tipo elemento");

      IF NOT CONFIRM(texto_confirm) THEN
        EXIT;

      // Posibilidad de seleccionar una agrupacion o todas las filtradas

      lrAgr.RESET;
      w_opcion := STRMENU(Text017);
      CASE w_opcion OF
        0: EXIT;
        1: BEGIN
             lrAgr.COPY(par_agr);
             lrAgr.SETRECFILTER;
           END;
        2: BEGIN
             lrAgr.COPY(par_agr);
           END;
      END;
      IF lrAgr.FINDSET THEN
      BEGIN
        REPEAT
          CLEAR(rRsv);
          IF lrAgr."Tipo transfer" = lrAgr."Tipo transfer"::Entrada THEN
          BEGIN
            rRsv.SETCURRENTKEY("Agrupacion entrada");
            rRsv.SETRANGE("Agrupacion entrada", lrAgr."N§ Agrupacion");
          END
          ELSE
          BEGIN
            rRsv.SETCURRENTKEY("Agrupacion salida");
            rRsv.SETRANGE("Agrupacion salida", lrAgr."N§ Agrupacion");
          END;
          IF rRsv.FINDSET THEN
          BEGIN
            REPEAT

              // AJS 19.02.2007
              // Hemos incluido la posibilidad de aplicar el suplemento solo a un tipo de persona

              IF (rRsv."N§ Personas" <> 0) AND
                 ((lrTipPersona."Tipo elemento" = '') OR (lrTipPersona."Tipo elemento" = rRsv."Tipo Persona")) THEN
              BEGIN
                CLEAR(rEleAux);
                rEleAux.SETRANGE(Delegacion     , rRsv.Delegacion);
                rEleAux.SETRANGE("N§ Reserva"   , rRsv."N§ Reserva");
                rEleAux.SETRANGE("Tipo elemento", lrTip."Tipo elemento");
                IF NOT rEleAux.FINDFIRST THEN
                BEGIN
                  CLEAR(rEle);
                  rEle.Delegacion   := rRsv.Delegacion;
                  rEle."N§ Reserva" := rRsv."N§ Reserva";
                  rEle.INSERT(TRUE);

                  rEle.VALIDATE("Tipo elemento"   , lrTip."Tipo elemento");
                  rEle.VALIDATE("Numero elementos", rRsv."N§ Personas");
                  rEle.MODIFY(TRUE);
                END;
              END;
            UNTIL rRsv.NEXT = 0;
          END;
        UNTIL lrAgr.NEXT = 0;
      END;
    END;

    PROCEDURE retroceder_fpr@11(pw_agrupacion@1103355000 : Integer);
    VAR
      lrPro@1103355001 : Record 23;
      lrCond@1103355002 : Record 7010087;
      lrCtas@1103355003 : Record 7009705;
      lrGrup@1103355004 : Record 93;
      lrPar@1103355005 : Record 7009700;
      lrRsv@1103355006 : Record 7009744;
      lrCI@1103355007 : Record 7009805;
      LCval_agr@1103355008 : Codeunit 7009738;
      lw_touroperadores@1103355009 : ARRAY [50] OF Code[10];
      lw_sumaimportes@1103355010 : ARRAY [50] OF Decimal;
      lw_sumaimportes_cir@1103355011 : ARRAY [50] OF Decimal;
      lw_i@1103355012 : Integer;
      lw_asiento@1103355013 : Integer;
      lw_fecha@1103355014 : Date;
      lw_texto@1103355015 : Text[60];
      lw_documento@1103355016 : Code[20];
      lwImporteLinea@1100217000 : Decimal;
    BEGIN
      // retroceder_fpr

      // AJS --> Funcion que crea unos contraasientos de FPR para el caso de que se retroceda una
      //         agrupacion o se recalcule su coste

      lrPar.FINDFIRST;

      CLEAR(lw_touroperadores);
      CLEAR(lw_sumaimportes);

      lrCI.RESET;
      lrCI.SETRANGE(Agrupacion     , pw_agrupacion);
      lrCI.SETRANGE(Concepto       , Text004);
      lrCI.SETRANGE("Pendiente FPR", FALSE);
      IF lrCI.FINDSET THEN
      BEGIN
        // ----  Rellenar la fecha con la fecha del servicio y sera la rutina de insercio de  ----
        // ----  asientos la que decidira que fecha aplicar en funcion de parametros  ----

        lw_fecha := lrCI.Fecha;

        // ----  Obtener el departamento al que imputar los costes  ----

        IF NOT lrCond.GET(USERID) THEN
          lrCond.INSERT;

        lrCond.INIT;
        lrCond.Usuario := USERID();
        lrCond.Delegacion := lrPar.Delegacion;
        lrCond.MODIFY;
        COMMIT;

        lrCond.FILTERGROUP(2);
        lrCond.SETRANGE(Usuario, USERID());
        lrCond.FILTERGROUP(0);
        FORM.RUNMODAL(7010126, lrCond);
        lrCond.GET(USERID);
        IF lrCond.Delegacion = '' THEN
          lrCond.Delegacion := lrPar.Delegacion;

        // ----  Buscar todos los touroperadores del servicio y sus costes asociados  ----
        // ----  Separar los ingresos dependiendo si son de circuito o no             ----

        REPEAT
          IF lrPar."Registrar FPR con impuestos" THEN
            lwImporteLinea := lrCI."Importe con impuestos (DL)"
          ELSE
            lwImporteLinea := lrCI."Importe sin impuestos (DL)";

          IF lrCI.Circuito THEN
            buscar_touroperador(lrCI.TourOperador, lw_touroperadores, lw_sumaimportes_cir, lwImporteLinea)
          ELSE
            buscar_touroperador(lrCI.TourOperador, lw_touroperadores, lw_sumaimportes, lwImporteLinea);
        UNTIL lrCI.NEXT = 0;

        // ----  Generar un asiento de contra-FPR por cada touroperador  ----

        lw_i := 1;
        WHILE lw_touroperadores[lw_i] <> '' DO
        BEGIN

          // ----  Buscar las cuentas contables para el asiento de FPR  ----

          buscar_cuentas(lrPar.Delegacion, lw_touroperadores[lw_i], lrCI.Transportista, lrCtas, lrGrup,
                         lrPro);

          // ----  Crear la descripcion que va a acompa¤ar al asiento  ----

          lw_texto := STRSUBSTNO(Text018, lrCI.Agrupacion,
                                 COPYSTR(lrPro.Name, 1, 23));

          // ----  Crear el numero de documento de contabilidad  ----

          lw_documento := FORMAT(lrCI.Agrupacion) + '-' +FORMAT(TODAY);

          lw_asiento := LCval_agr.busca_asiento(lrPar.GetLibroDiarioGeneral, lw_fecha);
          IF lw_sumaimportes[lw_i] <> 0 THEN
          BEGIN
            LCval_agr.genera_asiento(0, lrCtas."Cta. compra transfer", lw_sumaimportes[lw_i],
                                     lrCond.Delegacion, lw_fecha, lw_asiento,
                                     lw_touroperadores[lw_i], lw_texto, lw_documento, lrPro."No.");
            LCval_agr.genera_asiento(1, lrGrup."Cta. FPR Transfer", lw_sumaimportes[lw_i],
                                     lrCond.Delegacion, lw_fecha, lw_asiento,
                                     lw_touroperadores[lw_i], lw_texto, lw_documento, lrPro."No.");
          END;
          IF lw_sumaimportes_cir[lw_i] <> 0 THEN
          BEGIN
            LCval_agr.genera_asiento(0, lrCtas."Cta. compra circuito", lw_sumaimportes_cir[lw_i],
                                     lrCond.Delegacion, lw_fecha, lw_asiento,
                                     lw_touroperadores[lw_i], lw_texto, lw_documento, lrPro."No.");
            LCval_agr.genera_asiento(1, lrGrup."Cta. FPR Circuito", lw_sumaimportes_cir[lw_i],
                                     lrCond.Delegacion, lw_fecha, lw_asiento,
                                     lw_touroperadores[lw_i], lw_texto, lw_documento, lrPro."No.");
          END;
          lw_i += 1;
        END;
      END;
    END;

    PROCEDURE buscar_touroperador@9(pw_touroperador@1103355000 : Code[10];VAR pw_touroperadores@1103355001 : ARRAY [50] OF Code[10];VAR pw_sumaimportes@1103355002 : ARRAY [50] OF Decimal;pw_importe@1103355003 : Decimal);
    VAR
      lw_i@1103355004 : Integer;
    BEGIN
      // buscar_touroperador

      //. Rutina para rellenar la tabla de touroperadores, para cada touroperador un
      //. asiento de FPR.

      lw_i := 0;
      REPEAT
        lw_i += 1;
        IF pw_touroperadores[lw_i] = '' THEN
          pw_touroperadores[lw_i] := pw_touroperador;
      UNTIL pw_touroperadores[lw_i] = pw_touroperador;
      pw_sumaimportes[lw_i] := pw_sumaimportes[lw_i] + pw_importe;
    END;

    PROCEDURE buscar_cuentas@8(pw_delegacion@1103355000 : Code[10];pw_touroperador@1103355001 : Code[10];pw_transportista@1103355002 : Code[10];VAR prCtas@1103355003 : Record 7009705;VAR prGrup@1103355004 : Record 93;VAR prPro@1103355005 : Record 23);
    VAR
      lrTrans@1103355006 : Record 7009801;
    BEGIN
      // buscar_cuentas

      IF NOT prCtas.GET(pw_delegacion, pw_touroperador) THEN BEGIN
        IF NOT prCtas.GET(pw_delegacion, '') THEN
          ERROR(Text021+
                Text022, pw_touroperador, pw_delegacion);
      END;

      // asegurar_cuentas

      IF lrTrans.GET(pw_transportista) THEN BEGIN
        IF prPro.GET(lrTrans.Proveedor) THEN BEGIN
          IF prGrup.GET(prPro."Vendor Posting Group") THEN BEGIN
            prGrup.TESTFIELD("Cta. FPR Transfer");
            prGrup.TESTFIELD("Cta. FPR Circuito");
          END
          ELSE
            ERROR(Text023, prPro."Vendor Posting Group");
        END
        ELSE
          ERROR(Text024, lrTrans.Proveedor);
      END
      ELSE
        ERROR(Text025, pw_transportista);
    END;

    PROCEDURE invitados_touroperador@1103355000(pwAgr@1103355000 : Integer;pwTipoTransfer@1103355001 : 'Entrada,Salida') : Decimal;
    VAR
      lrRsv@1103355002 : Record 7009744;
    BEGIN
      // invitados_touroperador

      CASE pwTipoTransfer OF
        pwTipoTransfer::Entrada:
        BEGIN
          lrRsv.RESET;
          lrRsv.SETCURRENTKEY("Agrupacion entrada");
          lrRsv.SETRANGE("Agrupacion entrada"   , pwAgr);
          lrRsv.SETRANGE("Invitado TourOperador", TRUE);
          IF lrRsv.FINDSET THEN
            EXIT(lrRsv.COUNT);
        END;
        pwTipoTransfer::Salida:
        BEGIN
          lrRsv.RESET;
          lrRsv.SETCURRENTKEY("Agrupacion salida");
          lrRsv.SETRANGE("Agrupacion salida"    , pwAgr);
          lrRsv.SETRANGE("Invitado TourOperador", TRUE);
          IF lrRsv.FINDSET THEN
            EXIT(lrRsv.COUNT);
        END;
      END;
    END;

    PROCEDURE invitados_transportista@1103355001(pwAgr@1103355001 : Integer;pwTipoTransfer@1103355000 : 'Entrada,Salida') : Decimal;
    VAR
      lrRsv@1103355002 : Record 7009744;
    BEGIN
      // invitados_transportista

      CASE pwTipoTransfer OF
        pwTipoTransfer::Entrada:
        BEGIN
          lrRsv.RESET;
          lrRsv.SETCURRENTKEY("Agrupacion entrada");
          lrRsv.SETRANGE("Agrupacion entrada"    , pwAgr);
          lrRsv.SETRANGE("Invitado Transportista", TRUE);
          IF lrRsv.FINDSET THEN
            EXIT(lrRsv.COUNT);
        END;
        pwTipoTransfer::Salida:
        BEGIN
          lrRsv.RESET;
          lrRsv.SETCURRENTKEY("Agrupacion salida");
          lrRsv.SETRANGE("Agrupacion salida"     , pwAgr);
          lrRsv.SETRANGE("Invitado Transportista", TRUE);
          IF lrRsv.FINDSET THEN
            EXIT(lrRsv.COUNT);
        END;
      END;
    END;

    PROCEDURE SumaIngresoPaxAgrupacion@1103355002(prAgr@1103355000 : Record 7009796) : Decimal;
    VAR
      lrRsv@1103355001 : Record 7009744;
    BEGIN
      // SumaIngresoPaxAgrupacion

      // @. prAgr : Agrupacion de la que queremos sumar el ingreso prorrateado que se almacena en las reservas

      // @. Decimal : Suma del campo Importe Margen de las reservas de la agrupacion


      CASE prAgr."Tipo transfer" OF

        prAgr."Tipo transfer"::Entrada:
        BEGIN
          lrRsv.SETCURRENTKEY("Agrupacion entrada");
          lrRsv.SETRANGE("Agrupacion entrada", prAgr."N§ Agrupacion");
          lrRsv.CALCSUMS("Importe margen");
        END;

        prAgr."Tipo transfer"::Salida:
        BEGIN
          lrRsv.SETCURRENTKEY("Agrupacion salida");
          lrRsv.SETRANGE("Agrupacion salida", prAgr."N§ Agrupacion");
          lrRsv.CALCSUMS("Importe margen");
        END;

      END;

      EXIT(lrRsv."Importe margen");
    END;

    LOCAL PROCEDURE _BuscaTarifaMaleteros@1100253000(prAgrp@1100253000 : Record 7009796);
    VAR
      lrMalt@1100253001 : Record 7009903;
      lrTarf@1100253002 : Record 7009901;
      lrPrec@1100253003 : Record 7009902;
      lwPax@1100253004 : Decimal;
      lwEnc@1100253005 : Boolean;
    BEGIN
      // _BuscaTarifaMaleteros
      // $002 JPT 02/05/12 CNT-CAR12004-05
      // Si la agrupacion tiene informaci¢n de maleteros buscamos que tenga una tarifa
      // Si no encuentra la tarifa genera un error

      CLEAR(lrMalt);
      lrMalt.SETRANGE("Num Agrupacion", prAgrp."N§ Agrupacion");
      IF NOT lrMalt.FINDFIRST THEN
        EXIT;

      // Buscamos las tarifa
      CLEAR(lrTarf);
      lrTarf.SETRANGE("Tipo Tarifa", lrTarf."Tipo Tarifa"::Maletero);
      lrTarf.SETFILTER("Fecha Inicial", '<=%1', prAgrp.Fecha);
      lrTarf.SETFILTER("Fecha Final"  , '>=%1', prAgrp.Fecha);
      lwEnc := lrTarf.FINDFIRST;

      IF NOT lwEnc THEN
        ERROR(Text030, prAgrp.Fecha);

      // Buscamos el precio en la tarifa
      IF lwEnc THEN BEGIN
        CLEAR(lwPax);
        prAgrp.CALCFIELDS("Personas entrada", "Personas salida");
        lwPax := prAgrp."Personas entrada" + prAgrp."Personas salida";
        CLEAR(lrPrec);
        lrPrec.SETRANGE("ID Tarifa"       , lrTarf.ID);
        lrPrec.SETFILTER("Rango desde", '<=%1', lwPax);
        lrPrec.SETFILTER("Rango Hasta", '>=%1', lwPax);
        lwEnc := lrPrec.FINDFIRST;
        IF NOT lwEnc THEN BEGIN
          lrPrec.SETRANGE("Rango Hasta", 0);
          lwEnc := lrPrec.FINDFIRST;
        END;
      END;

      IF NOT lwEnc THEN
        ERROR(Text031, lrTarf.ID, lwPax);
    END;

    LOCAL PROCEDURE _BuscaTarifaGuiasTransf@1100253001(prAgrp@1100253000 : Record 7009796);
    VAR
      lrGuiaAgp@1100253001 : Record 7009905;
      lrTarf@1100253002 : Record 7009901;
      lrPrec@1100253003 : Record 7009902;
      lwPax@1100253004 : Decimal;
      lwEnc@1100253005 : Boolean;
    BEGIN
      // _BuscaTarifaGuiasTransf
      // $003 JPT 09/05/12 CNT-CAR-12004 // TRA06- Transfer Guides in Transfer Services
      // Si la agrupacion tiene informaci¢n de Guias Traslado buscamos que tenga una tarifa
      // Si no encuentra la tarifa genera un error

      CLEAR(lrGuiaAgp);
      lrGuiaAgp.SETRANGE("Num.Agrupacion", prAgrp."N§ Agrupacion");
      IF NOT lrGuiaAgp.FINDFIRST THEN
        EXIT;

      // Buscamos las tarifa
      CLEAR(lrTarf);
      lrTarf.SETRANGE("Tipo Tarifa", lrTarf."Tipo Tarifa"::"Guia Traslado");
      lrTarf.SETFILTER("Fecha Inicial", '<=%1', prAgrp.Fecha);
      lrTarf.SETFILTER("Fecha Final"  , '>=%1', prAgrp.Fecha);
      lwEnc := lrTarf.FINDFIRST;

      IF NOT lwEnc THEN
        ERROR(Text032, prAgrp.Fecha);

      // Buscamos el precio en la tarifa
      IF lwEnc THEN BEGIN
        CLEAR(lwPax);
        prAgrp.CALCFIELDS("Personas entrada", "Personas salida");
        lwPax := prAgrp."Personas entrada" + prAgrp."Personas salida";
        CLEAR(lrPrec);
        lrPrec.SETRANGE("ID Tarifa"       , lrTarf.ID);
        lrPrec.SETFILTER("Rango desde", '<=%1', lwPax);
        lrPrec.SETFILTER("Rango Hasta", '>=%1', lwPax);
        lwEnc := lrPrec.FINDFIRST;
        IF NOT lwEnc THEN BEGIN
          lrPrec.SETRANGE("Rango Hasta", 0);
          lwEnc := lrPrec.FINDFIRST;
        END;
      END;

      IF NOT lwEnc THEN
        ERROR(Text033, lrTarf.ID, lwPax);
    END;

    PROCEDURE ExportacionProvXML@1000000000(pwNumExportacion@1000000004 : Integer);
    VAR
      lrTransport@1000000002 : Record 7009801;
      lrAgrup@1000000003 : Record 7009796;
      lrAgrup2@1000000023 : Record 7009796;
      lrHotelAG@1000000008 : Record 7009798;
      lrTempHotelAG@1000000021 : TEMPORARY Record 7009798;
      lrVuelosAG@1000000015 : Record 7009797;
      lrHorasRec@1000000016 : Record 7009800;
      lrComAG@1000000022 : Record 7009813;
      lrCond@1000000000 : Record 7010085;
      lrExport@1000000005 : Record 7010272;
      lrPar@1000000006 : Record 7009700;
      lrDelegacion@1000000013 : Record 7009718;
      lfCond@1000000001 : Form 7009974;
      lNodo@1000000009 : ARRAY [10] OF Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 6.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v6.0'.IXMLDOMNode";
      lwNomArchivo@1000000007 : Text[250];
      lwTexto@1000000011 : Text[250];
      lwContador@1000000010 : Integer;
      lwContador2@1000000019 : Integer;
      lwTouroperador@1000000012 : Code[10];
      lwHora@1000000014 : Time;
      lwDiaSiguiente@1000000017 : Boolean;
      lwListaVuelos@1000000018 : Text[250];
      lwVuelo@1000000020 : Text[30];
      lwTipoServicioVenta@1000000024 : Text[30];
      lwPersonas@1000000025 : Integer;
    BEGIN
      // ExportacionProvXML

      //. Vamos a generar un XML para que Transfer lo pueda importar

      //. Comprobar si tenemos ruta donde dejar el fichero XML generado
      lrPar.FINDFIRST;
      lrPar.TESTFIELD("Ruta exportacion XML transfer");

      lrDelegacion.FINDFIRST;

      //. Si estamos regenerando una exportacion volvemos a pedir los datos al usuario
      IF pwNumExportacion = 0 THEN
      BEGIN
        //. El usuario tiene que seleccionar el dia que vamos a exportar

        IF NOT lrCond.GET(USERID) THEN
        BEGIN
          lrCond.INIT;
          lrCond.Usuario := USERID;
          lrCond.INSERT;
        END
        ELSE
        BEGIN
          lrCond."Fecha desde" := 0D;
          lrCond."Fecha hasta" := 0D;
          lrCond.MODIFY;
        END;
        COMMIT;

        lrCond.SETRECFILTER;

        CLEAR(lfCond);
        lfCond.SETTABLEVIEW(lrCond);
        IF lfCond.RUNMODAL <> ACTION::OK THEN
          EXIT;

        lfCond.GETRECORD(lrCond);
        IF lrCond."Fecha desde" = 0D THEN
          EXIT;

        //. El usuario tiene que seleccionar un transportista

        lrTransport.RESET;
        IF FORM.RUNMODAL(0, lrTransport) <> ACTION::LookupOK THEN
          EXIT;
      END
      //+$011 <
      ELSE
      BEGIN
        lrExport.GET(pwNumExportacion);
        lrTransport.GET(lrExport.Transportista);
        lrCond."Fecha desde" := lrExport.Dia;
      END;
      //+$011 >

      //. Vamos a filtrar sobre las agrupaciones para exportar

      lrAgrup.RESET;
      lrAgrup.SETRANGE(Transportista         , lrTransport.Codigo);
      lrAgrup.SETRANGE(Fecha                 , lrCond."Fecha desde");
      lrAgrup.SETRANGE("Num. Exportacion XML", pwNumExportacion);
      IF lrAgrup.FINDSET THEN
      BEGIN
        //. Si no estamos regenerando un fichero, hay que crear el registro de exportacion
        IF pwNumExportacion = 0 THEN
        BEGIN
          lrExport.INIT;
          lrExport.Transportista := lrTransport.Codigo;
          lrExport.Dia           := lrCond."Fecha desde";
          lrExport.INSERT(TRUE);
        END;

        //. Le damos nombre al archivo

        //-$012lwNomArchivo := 'TRANSF' + FORMAT(lrExport.ID) + '_' + FORMAT(TODAY,0,'<day><Month><Year>' + '.XML');
        lwNomArchivo := 'TRANSF' + FORMAT(lrExport.ID) + '_' + FORMAT(lrCond."Fecha desde", 0, '<day><Month><Year>' + '.XML'); //+$012
        lwNomArchivo := lrPar."Ruta exportacion XML transfer" + '\' + lwNomArchivo;

        //. Trabajamos con el automation de XML
        CLEAR(autXML);
        CLEAR(lNodo);

        CREATE(autXML);

        autXML.loadXML := '<?xml version="1.0"?><Reservas FinBus/>';
        lNodo[1] := autXML.createNode('Element', 'Partes', '');
        autXML.appendChild(lNodo[1]);

        lwContador := 0;
        REPEAT
          lwContador += 1;

          _AddElement(lNodo[1], STRSUBSTNO('Parte%1', lwContador), '', '', lNodo[2]);
          _AddAttribute(lNodo[2], 'NoParte', FORMAT(lrAgrup."N§ Agrupacion"));
          lwTipoServicioVenta := FORMAT(lrAgrup."Tipo Servicio venta");
          lwTipoServicioVenta := COPYSTR(lwTipoServicioVenta, 1, 1);

          lrHotelAG.RESET;
          lrHotelAG.SETRANGE("N§ Agrupacion", lrAgrup."N§ Agrupacion");
          IF lrHotelAG.FINDFIRST THEN
          BEGIN
            lwTouroperador := _GetTouroperadorAgr(lrAgrup."N§ Agrupacion", lrAgrup."Tipo transfer");

            CLEAR(lwTexto);
            _AddAttribute(lNodo[2], 'Garaje', COMPANYNAME);
            _AddAttribute(lNodo[2], 'Cliente', lrDelegacion.Codigo);
            _AddAttribute(lNodo[2], 'TTOO'   , lwTouroperador); //+$001
            _AddAttribute(lNodo[2], 'CodigoServicio', FORMAT(lrAgrup."Tipo transfer") + lwTipoServicioVenta);
            _AddAttribute(lNodo[2], 'Fecha', FORMAT(lrAgrup.Fecha));
            _AddAttribute(lNodo[2], 'Guia' , '');
            _AddAttribute(lNodo[2], 'ZonaTrabajo', lrAgrup.Zona);

            IF lrAgrup."Hora presentacion" <> 0T THEN
              lwHora := lrAgrup."Hora presentacion"
            ELSE
            BEGIN
              // Buscamos la primera hora
              CLEAR(lwHora);
              IF lrHotelAG."Tipo transfer" = lrHotelAG."Tipo transfer"::Entrada THEN
              BEGIN
                lrVuelosAG.RESET;
                lrVuelosAG.SETRANGE("N§ Agrupacion", lrAgrup."N§ Agrupacion");
                IF lrVuelosAG.FINDFIRST THEN
                  lwHora := lrVuelosAG.Hora;
              END
              ELSE
              BEGIN
                // Buscamos la hora de recogida de la tabla de horas recogida
                lrHorasRec.RESET;
                lrHorasRec.SETRANGE("N§ Agrupacion", lrAgrup."N§ Agrupacion");
                IF lrHorasRec.FINDFIRST THEN
                  lwHora := lrHorasRec."Hora recogida"
              END;
            END;

            _AddAttribute(lNodo[2],'HoraInicio',FORMAT(lwHora,0,'<Hour,2>:<Minutes,2>'));

            IF lrAgrup."Lugar presentacion" <> '' THEN
              _AddAttribute(lNodo[2], 'LugarPresentacion', lrAgrup."Lugar presentacion")
            ELSE
            BEGIN
              IF lrAgrup."Tipo transfer" = lrAgrup."Tipo transfer"::Entrada THEN
                _AddAttribute(lNodo[2], 'LugarPresentacion', lrAgrup."Origen/Destino transfer")
              ELSE
                _AddAttribute(lNodo[2], 'LugarPresentacion', lrHorasRec.NomHotel);
            END;

            // VUELOS
            // Evitamos repetir el vuelo aunque venga con IATA o TTOO distintos
            CLEAR(lwDiaSiguiente);
            CLEAR(lwListaVuelos);
            CLEAR(lwContador2);

            lrVuelosAG.RESET;
            lrVuelosAG.SETRANGE("N§ Agrupacion", lrAgrup."N§ Agrupacion");
            IF lrVuelosAG.FINDSET THEN
            BEGIN
              _AddElement(lNodo[2], 'Vuelos', '', '', lNodo[3]);

              lwDiaSiguiente:= TRUE;
              REPEAT
                CLEAR(lwVuelo);
                IF STRLEN(lrVuelosAG.Vuelo) <= 5 THEN
                  lwVuelo := lrVuelosAG.Compa¤ia;
                lwVuelo := lwVuelo + lrVuelosAG.Vuelo;

                IF STRPOS(lwListaVuelos, lwVuelo) = 0 THEN
                BEGIN
                  lwContador2 += 1;
                  _AddElement(lNodo[3], STRSUBSTNO('Vuelo%1', lwContador2), '', '', lNodo[4]);

                  _AddAttribute(lNodo[4], 'RefVuelo', lwVuelo);
                  _AddAttribute(lNodo[4], 'Hora'    , FORMAT(lrVuelosAG.Hora, 0, '<Hour,2>:<Minutes,2>'));
                  _AddAttribute(lNodo[4], 'IATA'    , lrVuelosAG.IATA);
                  _AddAttribute(lNodo[4], 'TTOO'    , lwTouroperador);
                  _AddAttribute(lNodo[4], 'EntSal'  , FORMAT(lrVuelosAG."Tipo transfer"));
                  _AddAttribute(lNodo[4], 'Fecha'   , FORMAT(lrVuelosAG.Fecha));

                  lwListaVuelos :=lwListaVuelos + lwVuelo + ',';

                  // Solo ser  Parte d¡a siguiente si todos los vuelos est n marcados as¡
                END;
                lwDiaSiguiente := lwDiaSiguiente AND lrVuelosAG."Vuelo dia siguiente";
              UNTIL lrVuelosAG.NEXT = 0;
            END;
            // Se graba el campo de cabecera "Dia siguiente"
            _AddAttribute(lNodo[2], 'DiaSiguiente', FORMAT(lwDiaSiguiente));

            // VAMOS A POR LAS LINEAS
            // Creamos un temporal ya que debemos ordenar las lineas es salidas por hora de recogida,
            // hora que por otro lado hay que ir a buscar a otra tabla
            IF lrHotelAG.FINDSET THEN
            BEGIN
              REPEAT
                CLEAR(lwHora);
                IF lrHotelAG."Tipo transfer" = lrHotelAG."Tipo transfer":: Salida THEN
                BEGIN
                  // Buscamos la hora de recogida de la tabla de horas recogida
                  lrHorasRec.RESET;
                  IF lrHorasRec.GET(lrHotelAG."N§ Agrupacion",
                                    lrHotelAG.Fecha,
                                    lrHotelAG."Orden zona",
                                    lrHotelAG."Orden recogida",
                                    lrHotelAG.Hotel,
                                    lrHotelAG.Compa¤ia,
                                    lrHotelAG.Vuelo,
                                    lrHotelAG.IATA) THEN
                    lwHora := lrHorasRec."Hora recogida"
                  ELSE
                    lwHora := lrHotelAG."Hora recogida";
                END;

                //+$015 <
                IF lrHotelAG."Tipo transfer" = lrHotelAG."Tipo transfer"::Entrada THEN
                BEGIN
                  lrHotelAG.CALCFIELDS("Personas entrada");
                  lwPersonas := lrHotelAG."Personas entrada";
                END
                ELSE
                BEGIN
                  lrHotelAG.CALCFIELDS("Personas salida");
                  lwPersonas := lrHotelAG."Personas salida";
                END;

                IF lwPersonas <> 0 THEN
                BEGIN
                  lrTempHotelAG := lrHotelAG;
                  lrTempHotelAG."Hora recogida":= lwHora;
                  lrTempHotelAG.INSERT;
                END;
                //+$015 >
              UNTIL lrHotelAG.NEXT = 0;
            END;

            // Ahora rellenamos los campos desde el temporal
            lrTempHotelAG.SETRANGE("N§ Agrupacion", lrAgrup."N§ Agrupacion");
            lrTempHotelAG.SETCURRENTKEY("N§ Agrupacion", "Orden zona");
            IF lrTempHotelAG.FINDSET THEN
            BEGIN
              lrComAG.RESET;
              lrComAG.SETRANGE(Agrupacion, lrAgrup."N§ Agrupacion");
              IF NOT lrComAG.FINDFIRST THEN
                CLEAR(lrComAG);

              _AddElement(lNodo[2], 'Lineas', '', '', lNodo[3]);
              CLEAR(lwContador2);
              REPEAT
                IF lrTempHotelAG."Primer Hotel" THEN
                BEGIN
                  lwContador2 +=1;

                  _AddElement(lNodo[3], STRSUBSTNO('Punto%1', lwContador2), '', '', lNodo[4]);

                  _AddAttribute(lNodo[4], 'PuntoRecogida', lrTempHotelAG.Hotel);
                  _AddAttribute(lNodo[4], 'NombrePunto', lrTempHotelAG.NombreHotel);
                  _AddAttribute(lNodo[4], 'Hora', FORMAT(lrTempHotelAG."Hora recogida" , 0, '<Hour,2>:<Minutes,2>'));
                  _AddAttribute(lNodo[4], 'TTOO', lwTouroperador);
                  _AddAttribute(lNodo[4], 'ZonaFisica', lrTempHotelAG.Zona);
                  _AddAttribute(lNodo[4], 'Adultos', FORMAT(lrTempHotelAG.ContarPersonas(0)));
                  _AddAttribute(lNodo[4], 'Ni¤os'  , FORMAT(lrTempHotelAG.ContarPersonas(1)));
                  _AddAttribute(lNodo[4], 'Vuelos', lrTempHotelAG.Vuelo);
                  _AddAttribute(lNodo[4], 'Observaciones', lrComAG.Comentario);

                  // Las observaciones van a nivel de "Parte" por lo que introducimos una linea en cada Punto
                  IF lrComAG.NEXT = 0 THEN
                    lrComAG.INIT;
                END;
              UNTIL lrTempHotelAG.NEXT = 0;
            END;
          END;

          lrAgrup2 := lrAgrup;
          lrAgrup2."Num. Exportacion XML" := lrExport.ID;
          lrAgrup2.MODIFY;
        UNTIL lrAgrup.NEXT = 0;

        autXML.save(lwNomArchivo);
      END;
    END;

    LOCAL PROCEDURE _AddElement@1000000005(VAR DOMNode@1000000000 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 6.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v6.0'.IXMLDOMNode";Name@1000000001 : Text[250];Value@1000000002 : Text[250];NameSpace@1000000003 : Text[250];VAR CreatedDOMNode@1000000004 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 6.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v6.0'.IXMLDOMNode") Status : Integer;
    VAR
      TempElement@1000000005 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 6.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v6.0'.IXMLDOMNode";
    BEGIN
      // _AddElement

      TempElement := autXML.createNode('Element', Name, NameSpace);

      IF TempElement.nodeName='' THEN BEGIN
        Status := 50;
        EXIT(Status)
      END;
      IF Value <> '' THEN BEGIN
        TempElement.text := Value;
      END;
      DOMNode.appendChild(TempElement);
      CreatedDOMNode := TempElement;
      CLEAR(TempElement);
      Status := 0;
    END;

    LOCAL PROCEDURE _AddAttribute@1000000006(VAR DOMNode@1000000000 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 6.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v6.0'.IXMLDOMNode";Name@1000000001 : Text[250];Value@1000000002 : Text[250]) Status : Integer;
    VAR
      TempAttribute@1000000003 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 6.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v6.0'.IXMLDOMNode";
    BEGIN
      // _AddAttribute

      TempAttribute := DOMNode.ownerDocument.createAttribute(Name);
      IF TempAttribute.nodeName='' THEN BEGIN
        Status := 60;
        EXIT(Status)
      END;

      IF Value <> '' THEN BEGIN
        TempAttribute.nodeValue := Value;
      END;
      DOMNode.attributes.setNamedItem(TempAttribute);
      CLEAR(TempAttribute);
    END;

    LOCAL PROCEDURE _GetTouroperadorAgr@1000000011(pwAgrupacion@1000000000 : Integer;pwTipoTransfer@1000000001 : Integer) : Code[10];
    VAR
      lrRsv@1000000002 : Record 7009744;
    BEGIN
      // _GetTouroperadorAgr

      IF pwTipoTransfer = 0 THEN  //. Entrada
      BEGIN
        lrRsv.RESET;
        lrRsv.SETCURRENTKEY("Agrupacion entrada");
        lrRsv.SETRANGE("Agrupacion entrada", pwAgrupacion);
        IF NOT lrRsv.FINDFIRST THEN
          CLEAR(lrRsv);
      END
      ELSE
      BEGIN
        lrRsv.RESET;
        lrRsv.SETCURRENTKEY("Agrupacion salida");
        lrRsv.SETRANGE("Agrupacion salida", pwAgrupacion);
        IF NOT lrRsv.FINDFIRST THEN
          CLEAR(lrRsv);
      END;

      EXIT(lrRsv.TourOperador);
    END;

    PROCEDURE FusionarAgrupaciones@1000000002(VAR prAgr@1000000000 : Record 7009796);
    VAR
      lrAgrup@1000000001 : Record 7009796;
      lrRes@1000000002 : Record 7009744;
      lrRes2@1000000003 : Record 7009744;
    BEGIN
      // $013
      lrAgrup.RESET;
      lrAgrup.FILTERGROUP(2);
      lrAgrup.SETRANGE (Fecha                , prAgr.Fecha);
      lrAgrup.SETRANGE ("Tipo transfer"      , prAgr."Tipo transfer");
      lrAgrup.SETRANGE ("Tipo Servicio venta", prAgr."Tipo Servicio venta");
      lrAgrup.SETRANGE ("Traslado en destino", prAgr."Traslado en destino");
      lrAgrup.SETRANGE ("Tipo vehiculo"      , prAgr."Tipo vehiculo");
      lrAgrup.SETFILTER(Estado               , 'Pendiente|Generado');
      lrAgrup.SETRANGE (Transportista        , prAgr.Transportista);
      lrAgrup.SETFILTER("N§ Agrupacion"      , '<>%1', prAgr."N§ Agrupacion");
      lrAgrup.FILTERGROUP(0);
      IF lrAgrup.FINDFIRST THEN
      BEGIN
        IF FORM.RUNMODAL(0, lrAgrup) = ACTION::LookupOK THEN
        BEGIN
          IF NOT CONFIRM(Text035, FALSE) THEN
            EXIT;

          IF prAgr."Tipo transfer" = prAgr."Tipo transfer"::Entrada THEN
          BEGIN
            lrRes.RESET;
            lrRes.SETCURRENTKEY("Agrupacion entrada");
            lrRes.SETRANGE("Agrupacion entrada", lrAgrup."N§ Agrupacion");
            IF lrRes.FINDSET THEN
            BEGIN
              REPEAT
                lrRes2 := lrRes;
                lrRes2.VALIDATE("Agrupacion entrada", prAgr."N§ Agrupacion");
                lrRes2.MODIFY;
              UNTIL lrRes.NEXT = 0;
            END;
          END;

          IF prAgr."Tipo transfer" = prAgr."Tipo transfer"::Entrada THEN
          BEGIN
            lrRes.RESET;
            lrRes.SETCURRENTKEY("Agrupacion salida");
            lrRes.SETRANGE("Agrupacion salida", lrAgrup."N§ Agrupacion");
            IF lrRes.FINDSET THEN
            BEGIN
              REPEAT
                lrRes2 := lrRes;
                lrRes2.VALIDATE("Agrupacion salida", prAgr."N§ Agrupacion");
                lrRes2.MODIFY;
              UNTIL lrRes.NEXT = 0;
            END;
          END;

          lrAgrup.DELETE(TRUE);
        END;
      END;
    END;

    EVENT autXML@1000000001::ondataavailable@198();
    BEGIN
    END;

    EVENT autXML@1000000001::onreadystatechange@-609();
    BEGIN
    END;

    BEGIN
    {
      ## AJS 05.10.2009

        .- Nueva funcion SumaIngresoPaxAgrupacion que retorna la suma del campo Importe margen de las
           reservas de la agrupacion que se pase por parametro

      $001 AJS 16042012 Al confirmar el servicio se eliminan las tablas temporales del calculo

      $002 JPT 02/05/12 CNT-CAR12004-05 Si la agrupaci¢n tiene maleteros nos aseguramos que tenga tarifa

      $003 JPT 09/05/12 CNT-CAR-12004 // TRA06- Si la agrupaci¢n tiene Guias Transfer nos aseguramos que tenga tarifa

      $004 AJS 20082012 Solo los usuarios autorizados podr n calcular las agrupaciones

      $005 AJS 24032013 Si el calculo termina con errores no confirmamos la agrupacion

      $006 AJS 03092013 Modifico las llamadas a la funcion generar asiento porque se ha eliminado el parametro de maestro de claves

      $007 AJS 23102013 Quito el control de no poder confirmar con errores porque hay suplementos que solo aplican en venta
                        y en el contrato de compra no estan definidos

      $008 AJS 29102013 Modifico el control establecido en 005 para que lo haga solo si tienen la marca de error critico

      $009 AJS 09052014 Los asientos de FPR se tienen que hacer en Divisa local

      $010 AJS 30052014 Modifico las funciones confirmar_servicios, desconfirmar_servicios y recalcular_coste
                        para marcar el registro de ICD Periodo

      $011 AJS 17032015 Corrijo error de la opcion Regrabar en la funcion ExportacionProvXML

      $012 AJS 01042015 En la funcion ExportacionProvXML el nombre del archivo debe hacer referencia a la fecha de los servicios no
                        al dia que se genera el fichero

      $013 ARM 01042015 CNT-OC-14115 Fusionar agrupaciones

      $014 AJS 28042015 Hago un cambio en la funcion de agrupaciones para llamar al validate de los campos

      $015 AJS 04062015 Corrijo la funci¢n ExportacionProvXML para no exportar hoteles que se han quedado sin pasajeros

      $016 AJS 17062015 Corregir error en el recalculo de servicios
    }
    END.
  }
}
