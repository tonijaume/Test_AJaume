OBJECT Codeunit 7010318 Funciones Partes
{
  OBJECT-PROPERTIES
  {
    Date=18/06/15;
    Time=13:18:59;
    Modified=Yes;
    Version List=TRANSFER;
  }
  PROPERTIES
  {
    OnRun=BEGIN
            generar_prevision;
          END;

  }
  CODE
  {
    VAR
      Text50000@1103355010 : TextConst 'ESP=CONF-PARTES';
      Text50001@1103355011 : TextConst 'ESP=MALETA';
      Text50002@1103355012 : TextConst 'ESP=FACTURAR';
      Text50003@1103355013 : TextConst 'ESP=RESULTADO\';
      Text50004@1103355014 : TextConst 'ESP=PARTE     #1########\';
      Text50005@1103355015 : TextConst 'ESP=CONDUCTOR #2#############\';
      Text50006@1103355016 : TextConst 'ESP=VEHICULO  #3########\';
      Text50007@1103355017 : TextConst 'ESP=HORA      #4####';
      Text50008@1103355018 : TextConst 'ESP=PROV';
      Text50009@1103355019 : TextConst 'ESP=.XML';
      Text50010@1103355020 : TextConst 'ESP=PARTES-CONF';
      Text50011@1103355021 : TextConst 'ESP="<?xml version=""1.0""?><Reservas Atennea Transfer/>"';
      Text50012@1103355022 : TextConst 'ESP="<?xml version=""1.0""?><Partes confirmados Atennea Transfer/>"';
      Text50013@1103355023 : TextConst 'ESP=Partes1';
      Text50014@1103355024 : TextConst 'ESP=Element';
      Text50015@1103355025 : TextConst 'ESP=Partes';
      Text50016@1103355026 : TextConst 'ESP=Parte%1';
      Text50017@1103355027 : TextConst 'ESP=NoParte';
      Text50018@1103355028 : TextConst 'ESP=Garaje';
      Text50019@1103355029 : TextConst 'ESP=Cliente';
      Text50020@1103355030 : TextConst 'ESP=TTOO';
      Text50021@1103355031 : TextConst 'ESP=CodigoServicio';
      Text50022@1103355032 : TextConst 'ESP=Fecha';
      Text50023@1103355033 : TextConst 'ESP=Guia';
      Text50024@1103355034 : TextConst 'ESP=ZonaTrabajo';
      Text50025@1103355035 : TextConst 'ESP=HoraInicio';
      Text50026@1103355036 : TextConst 'ESP=<Hour,2>:<Minutes,2>';
      Text50027@1103355037 : TextConst 'ESP=DiaSiguiente';
      Text50028@1103355038 : TextConst 'ESP=LugarPresentacion';
      Text50029@1103355039 : TextConst 'ESP=Observaciones';
      Text50030@1103355040 : TextConst 'ESP=Referencia';
      Text50031@1103355041 : TextConst 'ESP=Letreros';
      Text50032@1103355042 : TextConst 'ESP=Origen-Destino';
      Text50033@1103355043 : TextConst 'ESP=Conductor';
      Text50034@1103355044 : TextConst 'ESP=Vehiculo';
      Text50035@1103355045 : TextConst 'ESP=IngresoParte';
      Text50036@1103355046 : TextConst 'ESP=Vuelos';
      Text50037@1103355047 : TextConst 'ESP=Vuelo%1';
      Text50038@1103355048 : TextConst 'ESP=RefVuelo';
      Text50039@1103355049 : TextConst 'ESP=Hora';
      Text50040@1103355050 : TextConst 'ESP=IATA';
      Text50041@1103355051 : TextConst 'ESP=EntSal';
      Text50042@1103355052 : TextConst 'ESP=FechaLlegadaVuelo';
      Text50043@1103355053 : TextConst 'ESP=Lineas';
      Text50044@1103355054 : TextConst 'ESP=Punto%1';
      Text50045@1103355055 : TextConst 'ESP=PuntoRecogida';
      Text50046@1103355056 : TextConst 'ESP=NombrePunto';
      Text50047@1103355057 : TextConst 'ESP=ZonaFisica';
      Text50048@1103355058 : TextConst 'ESP=Adultos';
      Text50049@1103355059 : TextConst 'ESP=Ni¤os';
      Text50050@1103355060 : TextConst 'ESP=AdultosInvitados';
      Text50051@1103355061 : TextConst 'ESP=Ni¤osInvitados';
      Text50052@1103355062 : TextConst 'ESP=HoraVuelo';
      Text50053@1103355063 : TextConst 'ESP=NombreCliente';
      Text50054@1103355064 : TextConst 'ESP=Reserva';
      Text50055@1103355065 : TextConst 'ESP=Suplementos';
      Text50056@1103355066 : TextConst 'ESP=Suplemento%1';
      Text50057@1103355067 : TextConst 'ESP=CodigoSupl';
      Text50058@1103355068 : TextConst 'ESP=Cantidad';
      Text50059@1103355069 : TextConst 'ESP=Extras';
      Text50060@1103355070 : TextConst 'ESP=Extra%1';
      Text50061@1103355071 : TextConst 'ESP=Codigo';
      Text50062@1103355072 : TextConst 'ESP=element';
      Text50063@1103355073 : TextConst 'ESP=c:\bleh\';
      Text50064@1103355074 : TextConst 'ESP=.txt';
      err1@1100244001 : TextConst 'ESP=La agrupacion %1 no se puede desconfirmar porque alguna linea esta validada.';
      err2@1100244002 : TextConst 'ESP=No se puede crear una linea de ajuste con importe cero.';
      err3@1100244003 : TextConst 'ESP=Solo se pueden borrar las lineas de ajuste de coste.';
      no_validacion_en_ajuste@1100244004 : TextConst 'ESP=No se puede cambiar el importe de validacion en una linea de ajuste manual';
      text1@1100244005 : TextConst 'ESP=%1 &actual,%1 &filtradas';
      text2@1100244006 : TextConst 'ESP=Desconfirmar &actual,Desconfirmar &filtradas';
      text3@1100244007 : TextConst 'ESP=El total sin impuestos de las lineas filtradas es';
      text9@1100244008 : TextConst 'ESP="El total sin impuestos en divisas es             "';
      text4@1100244009 : TextConst 'ESP=El total de las lineas marcadas por';
      text10@1100244010 : TextConst 'ESP="El total de las marcadas en divisas es           "';
      text5@1100244011 : TextConst 'ESP=es';
      text6@1100244012 : TextConst 'ESP=Seguro que desea que borrar esta linea de ajuste';
      text7@1100244013 : TextConst 'ESP=El %1 del parte %2 esta facturado, desea generar lineas de abono y continuar.';
      text8@1100244014 : TextConst 'ESP=Sobre este parte ya se han generado prefacturas./ ¨Quiere deshacerlas?';
      Text11@1103355004 : TextConst 'ESP=El coste del parte %1 esta facturado, desea generar lineas de abono y continuar.';
      Text12@1103355003 : TextConst 'ESP=No hay nada pendiente de factura de este parte de trabajo.';
      text13@1103355001 : TextConst 'ESP=Coste';
      text14@1103355002 : TextConst 'ESP=Ingreso';
      pre_ya_facturada@1100244015 : TextConst 'ESP=No se puede borrar una prefactura ya facturada.';
      pre_desactivada@1100244016 : TextConst 'ESP=No se puede imprimir una prefactura Desactivada';
      confirma1@1100244017 : TextConst 'ESP=Desea deshacer la prefactura %1';
      pre_ya_facturada2@1100244018 : TextConst 'ESP=No se puede reimprimir una prefactura ya facturada. Debe reimprimir la factura.';
      no_punto@1100244019 : TextConst 'ESP=Debe indicar un punto de recogida para la busqueda.';
      err4@1100244020 : TextConst 'ESP=No se puede borrar una linea ya facturada';
      err5@1100244021 : TextConst 'ESP=No puede marcarse una linea ya validada';
      msg1@1100244022 : TextConst 'ESP=La Reimpresi¢n de las prefacturas asignadas No coincidir  con la copia anterior.';
      msg2@1100244023 : TextConst 'ESP=Este parte esta incluido en una prefactura, si continua se va a deshacer';
      ya_abonado@1100244024 : TextConst 'ESP=El parte %1 ya ha sido abonado una vez.';
      errNoEncontrado@1100244025 : TextConst 'ESP=El dia %1 no se encuentra en la tabla Dias Abiertos.';
      errNocerrado@1100244026 : TextConst 'ESP=el dia %1 no ha sido cerrado.\\No se pueden confirmar partes de dias no cerrados.';
      cCalR@1100253006 : Codeunit 7010407;
      cCalCost@1100253007 : Codeunit 7010409;
      cFunBas@1103350002 : Codeunit 7010310;
      cCont@1103350012 : Codeunit 13;
      cImpTRN@1103355000 : Codeunit 7010402;
      cFunRec@1103355009 : Codeunit 7010413;
      rPar@1100244028 : Record 7010311;
      rParUEX@1100244032 : Record 7035332;
      rParAux@1100253010 : Record 7010433;
      rInfEmp@1100253009 : Record 79;
      wVentana@1100244031 : Dialog;
      XML@1100244030 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{F6D90F11-9C73-11D3-B32E-00C04F990BB4}:'Microsoft XML, v4.0'.DOMDocument";
      Text0001@1100244039 : TextConst 'ESP="¨Desea Realmente Comenzar el proceso de exportaci¢n? "';
      Text0002@1100244038 : TextConst 'ESP=Fecha Desde no puede ser Superior a Fecha Hasta';
      Text0003@1100244037 : TextConst 'ESP=Ya existe el archivo %1, ¨Desea sobreescribirlo?';
      Text0004@1100244036 : TextConst 'ESP=No pudo crearse el archivo %1';
      Text0005@1100244035 : TextConst 'ESP=Exportacion Partes a Proveedor';
      Text0006@1100244034 : TextConst 'ESP=No se encontr¢ ning£n Parte para exportar';
      Text0007@1100244033 : TextConst 'ESP=Exportando @1@@@@@@@@@';
      Text0008@1100244048 : TextConst 'ESP=No se ha encontrado contrato para %1';
      Text0009@1100244049 : TextConst 'ESP=Mostrar Productos';
      Text0010@1100244050 : TextConst 'ESP=No se ha encontrado ninguna coincidencia';
      Text0011@1103350000 : TextConst 'ESP=Debe rellenarse el campo Proveedor';
      Text0012@1103350001 : TextConst 'ESP=Servicios (%3) de %1 a %2';
      Text0013@1103350004 : TextConst 'ESP=Condiciones Partes';
      Text0014@1103350005 : TextConst 'ESP=Confirmar';
      Text0015@1103350006 : TextConst 'ESP=Recalcular';
      Text0016@1103350008 : TextConst 'ESP=OPCION RESTRINGIDA';
      Text0017@1103350009 : TextConst 'ESP=COBRO DIR';
      Text0018@1103350010 : TextConst 'ESP=Cobros Serv. Contado Parte %1';
      Text0019@1103350011 : TextConst 'ESP=Cobros Directos';
      Text0020@1103350013 : TextConst 'ESP=El Parte %1 No se puede desconfirmar ya que el Garaje %2 es de cobro directo.';
      Text0021@1100253001 : TextConst 'ESP=Indique precio manual: #1###########';
      Text0022@1100253000 : TextConst 'ESP=Cambiar Precio Actual,Cambiar Precio Filtrados';
      Text0023@1100253002 : TextConst 'ESP=Cambiando Precio Manual\Parte #1###########\#2######\@3@@@@@@@@@@@@@';
      Text0024@1100253003 : TextConst 'ESP=%1 de %2';
      Text0025@1100253004 : TextConst 'ESP=Los partes seleccionados deben tener el mismo cliente.';
      Text0026@1100253005 : TextConst 'ESP=¨Seguro que quiere marcar el precio manual a 0?';
      Text0027@1100253008 : TextConst 'ESP=Usuario No autorizado para la confirmaci¢n de partes';
      Text0028@1103355006 : TextConst 'ESP=Existen modificaciones manuales %1 en las lineas de producci¢n\¨Desea guardarlas para que se apliquen a un nuevo calculo?';
      Text0029@1103355007 : TextConst 'ESP=Existen modificaciones manuales %1 en las lineas de producci¢n\¨Desea cargarlas para que se apliquen a este calculo?';
      err6@1100244040 : TextConst 'ESP=El Parte pertenece a un grupo sin confirmar.';
      err7@1100244041 : TextConst 'ESP=No ha introducido precio manual en ningun parte del grupo %1.';
      err8@1100244042 : TextConst 'ESP=Introduzca precio manual venta en el parte %1.';
      err9@1100244043 : TextConst 'ESP=El parte %1 debe estar marcado como no facturable.';
      err10@1100244044 : TextConst 'ESP=Solo puede confirmar partes asociados al grupo %1 desde la ficha de Grupos.';
      err11@1100244045 : TextConst 'ESP=Hay m s de un parte con precio manual en el grupo %1. Comprobar marca facturable.';
      err12@1100244046 : TextConst 'ESP=Solo puede desconfirmar partes asociados al grupo %1 desde la ficha de Grupos.';
      err13@1100244047 : TextConst 'ESP=No se han podido confirmar los partes del grupo %1.';
      wCreacion@1103355005 : 'Servicio,ImpTRN,ImpUEX,Regulares,Grupos,Shuttle,ImpShuttle';
      rUsu@1103355008 : Record 7010420;

    PROCEDURE calculo_margenes@1(prParte@1100244000 : Record 7010360);
    VAR
      lwOpc@1100253000 : Integer;
    BEGIN
      // calculo_margenes
      //
      // AJS --> Llamar a la rutina de calculo indicando que se trata de una simulacion de los margenes
      //         del parte.
      //

      prParte."Tipo Calculo" := prParte."Tipo Calculo"::Margen;
      prParte.MODIFY(TRUE);
      COMMIT;

      // JPT 27/12/05 Cambiamos la codeunit de las funciones de calculo, a la de calculo con temporales
      // cCal.calculo_parte(prParte, TRUE, TRUE, TRUE, FALSE);
      cCalR.CalculoParte(prParte, TRUE, TRUE, TRUE, FALSE, TRUE);
    END;

    PROCEDURE confirmar_partes@2(VAR prParte@1100244000 : Record 7010360;pw_pideopciones@1100244001 : Boolean;pw_grupo@1100244019 : Code[10];pwRecalcular@1103350002 : 'Confirmar,Todo,Solo Coste,Solo Ingreso');
    VAR
      w_opcion@1100244002 : Integer;
      rParte@1100244003 : Record 7010360;
      rParte2@1100244004 : Record 7010360;
      rUsu@1100244005 : Record 7010420;
      rAcc@1100244006 : Record 7010422;
      lrProdCoste@1100244007 : Record 7035393;
      lrProdIng@1103355000 : Record 7035392;
      lrTipoSer@1100244008 : Record 7010319;
      lrTTOOxParte@1103350001 : Record 7010365;
      lrError@1103350005 : Record 7010413;
      OPCION_RESTRINGIDA@1100244010 : TextConst 'ESP=Se ha restringido el uso de esta opcion. Dirijase a su administrador.';
      vHayConfirmacion@1100244011 : Boolean;
      rDiasCerrados@1100244012 : Record 7035341;
      lrParte3@1100244013 : Record 7010360;
      lrMod@1103355004 : Record 7035330;
      lwFechaConfirmacionAnt@1103350000 : DateTime;
      lwAccion@1103350003 : Text[30];
      lwEsConfirmacion@1103350004 : Boolean;
      lwPrimero@1100253000 : Boolean;
      lwCargaModf_I@1103355003 : ',Si,No';
      lwCargaModf_C@1103355002 : ',Si,No';
      lwTieneModf@1103355001 : Boolean;
    BEGIN
      // confirmar_partes
      //
      // AJS --> Llamar a la rutina de calculo indicando que se trata del calculo real de costes
      //         ingresos del parte y si no se han producido errores en el calculo se confirma
      //         el parte.
      //         pwRecalcular - Indica si se quiere Confirmar, o recalcular el parte confirmado y en ese caso si todo,solo coste o
      //         solo ingreso JPT 03.05.05

      // JPT 03/05/05 Puede ser una llamada a la confirmaci¢n (lwEsConfirmacion) o al recalculo

      lwEsConfirmacion:= pwRecalcular = pwRecalcular::Confirmar;
      IF lwEsConfirmacion THEN
        lwAccion := Text0014
      ELSE
        lwAccion := Text0015;


      //BRM 25/05/04 Solo podemos confirmar partes de grupo desde la pantalla de Grupos
      IF (prParte."Cod Grupo"<>'') THEN
        ERROR(err10,prParte."Cod Grupo");

      //BRM 25/05/04 Partes q vamos a confirmar si es un grupo
      IF (pw_grupo <> '') THEN BEGIN
        rParte.RESET;
        rParte.SETCURRENTKEY("Cod Grupo");
        rParte.SETRANGE("Cod Grupo",pw_grupo);
        rParte.SETRANGE(Confirmado , FALSE);
        validar_conf_partes(pw_grupo);

      END ELSE BEGIN
        rParte.COPY(prParte);

        IF pw_pideopciones THEN
          w_opcion := STRMENU(STRSUBSTNO(text1,lwAccion), 1)
        ELSE
          w_opcion := 1;

        CASE w_opcion OF
          0: EXIT;
          1: rParte.SETRECFILTER;
        END;
      END;

      IF rUsu.GET(USERID) THEN
        IF rAcc.GET(rUsu."Perfil Transfer",Text50000) THEN
           ERROR(Text0027);

      // AJS 04.02.2004
      // Obtenemos el registro de parametros

      rPar.FINDFIRST;

      vHayConfirmacion := FALSE;
      lwPrimero := TRUE;

      // JPT 03/12/08 Indica si se tienen que cargar las lineas de modificaciones manuales
      // para que dichas modificaciones viajen a las nuevas lineas

      CLEAR(lwCargaModf_I);
      CLEAR(lwCargaModf_C);
      IF rParte.FINDSET THEN BEGIN
        REPEAT
          lrTipoSer.GET(rParte."Tipo Servicio");

          // AJS 04.02.2004
          // En los partes de excursi¢n (si se marca el parametro) al confirmar se pone como fecha facturacion la
          // fecha de confirmacion, tomamos la fecha de trabajo de Navision

          rParte2.COPY(rParte);

          IF lwEsConfirmacion THEN BEGIN
            // JPT 22/06/09 DRF IBZ 09001 Valoraci¢n de partes de recogida
            cFunRec.CompConf(rParte); // Comprueba que no sea un parte de recogida
            IF rPar."Cambiar Fecha Exc." THEN BEGIN
              IF (lrTipoSer.GET(rParte."Tipo Servicio")) AND (lrTipoSer."Tipo fijo" = lrTipoSer."Tipo fijo"::Excursion) THEN
                rParte2.VALIDATE("Fecha facturacion", WORKDATE);
            END;
          END;

          rParte2."Tipo Calculo" := rParte2."Tipo Calculo"::Confirmacion;
          lwFechaConfirmacionAnt := rParte2."Fecha Confirmacion";
          rParte2."Fecha Confirmacion" := CREATEDATETIME(TODAY,TIME);

          // AJF 28/07/08
          // Antes de confirmar actualizamos el touroperador principal

          IF pwRecalcular = pwRecalcular::Confirmar THEN BEGIN
            cCalR.RepasaTTOOs(rParte2);
            ActualizarTTOOPrincipal(rParte2);
          END;

          rParte2.MODIFY; // No validar
          COMMIT;

          cCalR.CalculoParte(rParte2, FALSE, pwRecalcular <> pwRecalcular::"Solo Ingreso", pwRecalcular <> pwRecalcular::"Solo Coste",
                             pwRecalcular>0, lwPrimero);

          // JPT 03/12/08 Se recargan las modificaciones

          IF pwRecalcular <> pwRecalcular::"Solo Coste" THEN BEGIN // INGRESO
            CLEAR(lrMod);
            lrMod.SETCURRENTKEY("N§ Parte", "N§ Linea", Tipo, "No Campo");
            lrMod.SETRANGE("N§ Parte", rParte2."N§ Parte");
            lrMod.SETRANGE(Tipo      , lrMod.Tipo::Ingreso);
            lrMod.SETRANGE("N§ Linea", 0);
            lwTieneModf := lrMod.FINDFIRST;
            IF lwTieneModf AND (lwCargaModf_I =0) THEN BEGIN
              IF CONFIRM(Text0029, FALSE, lrMod.Tipo) THEN
                lwCargaModf_I := lwCargaModf_I::Si
              ELSE
                lwCargaModf_I := lwCargaModf_I::No;
            END;
            IF lwTieneModf THEN BEGIN
              lwTieneModf := lwTieneModf AND (lwCargaModf_I = lwCargaModf_I::Si);
              IF lwTieneModf THEN
                AddModificaciones(rParte2."N§ Parte", 0)
              ELSE
                DelModificaciones(rParte2."N§ Parte", 0);
            END;
          END;

          IF pwRecalcular <> pwRecalcular::"Solo Ingreso" THEN BEGIN // COSTE
            CLEAR(lrMod);
            lrMod.SETCURRENTKEY("N§ Parte", "N§ Linea", Tipo, "No Campo");
            lrMod.SETRANGE("N§ Parte", rParte2."N§ Parte");
            lrMod.SETRANGE(Tipo      , lrMod.Tipo::Coste);
            lrMod.SETRANGE("N§ Linea", 0);
            lwTieneModf := lrMod.FINDFIRST;
            IF lwTieneModf AND (lwCargaModf_C =0) THEN BEGIN
              IF CONFIRM(Text0029, FALSE, lrMod.Tipo) THEN
                lwCargaModf_C := lwCargaModf_C::Si
              ELSE
                lwCargaModf_C := lwCargaModf_C::No;
            END;
            IF lwTieneModf THEN BEGIN
              lwTieneModf := lwTieneModf AND (lwCargaModf_C = lwCargaModf_C::Si);
              IF lwTieneModf THEN
                AddModificaciones(rParte2."N§ Parte", 1)
              ELSE
                DelModificaciones(rParte2."N§ Parte", 1);
            END;
          END;

          rParte2.GET(rParte2."N§ Parte");
          rParte2.CALCFIELDS(Errores);

          IF NOT rParte2.Errores THEN BEGIN
            SumarPre(rParte2);
            vHayConfirmacion := TRUE;
            IF lwEsConfirmacion THEN BEGIN
              rParte2.VALIDATE(Confirmado , TRUE);
              rParte2.MODIFY;

              // Marcamos tambien los registros asociados en Touroperador x Parte.
              Tratar_TTOOxParte(rParte."N§ Parte", TRUE);

              // JPT 22/06/09 DRF IBZ 09001 Valoraci¢n de partes de recogida
              cFunRec.ConfirmarParteRecogida(rParte2);
            END;
          END

          // ----  AJS 3.12.2002 Hay que borrar posibles lineas de produccion pendientes en confirmaciones que se  ----
          // ----  quedan a medias                                                                                 ----

          ELSE BEGIN
            // JPT 03/05/05 Si no es confirmaci¢n generamos un error con el primer mensaje que encontramos
            // para provocar el ROLLBACK

            IF NOT lwEsConfirmacion THEN BEGIN
              CLEAR(lrError);
              lrError.SETRANGE("N§ Parte",rParte2."N§ Parte");
              lrError.SETRANGE(Tipo , lrError.Tipo::Error);
              IF lrError.FINDFIRST THEN
                ERROR(lrError.Texto);
            END;

            // Si se han generado errores vuelve a la fecha de confirmacion anterior

            rParte2."Fecha Confirmacion" := lwFechaConfirmacionAnt;
            rParte2.MODIFY;

            // ## Borramos las lineas de produccion Coste

            lrProdCoste.RESET;
            lrProdCoste.SETCURRENTKEY("N§ Parte", "N§ Prefactura", "N§ Factura");
            lrProdCoste.SETRANGE("N§ Parte"      , rParte."N§ Parte");
            lrProdCoste.SETRANGE("Linea abono"   , FALSE);
            lrProdCoste.SETRANGE("N§ Factura"    ,'');
            lrProdCoste.SETRANGE("N§ Prefactura" ,'');
            IF lrProdCoste.FINDFIRST THEN
              lrProdCoste.DELETEALL(TRUE);

            // ## Borramos las lineas de produccion Ingreso

            lrProdIng.RESET;
            lrProdIng.SETRANGE("N§ Parte"   , rParte."N§ Parte");
            lrProdIng.SETRANGE("Linea abono", FALSE);
            IF lrProdIng.FINDFIRST THEN
              lrProdIng.DELETEALL(TRUE);

            // BRM 25/05/04 Tenemos q incluir un control para no deje confirmar ning£n parte si se han
            //             producido errores

            IF (rParte2.Errores) AND (pw_grupo <> '') THEN BEGIN
              lrParte3.INIT;
              desconfirmar_partes(lrParte3, FALSE, pw_grupo, 0);
              MESSAGE(err13, pw_grupo);
              EXIT;
            END;

            // JPT 27/12/05 Eliminamos las lineas de Movs. Otros Gastos

            cCalCost.EliminaMovOG(rParte);
          END;

          COMMIT;
          lwPrimero:= FALSE;

          // JPT 18/07/05 TER - Contabilizamos los cobros directos

          ContabilizaServicioContado(rParte);
        UNTIL rParte.NEXT = 0;
      END;

      // JPT 27/12/05 Borramos las tablas temporales de calculo

      cCalR.BorraTemps(TRUE);
    END;

    PROCEDURE desconfirmar_partes@3(VAR prParte@1100244000 : Record 7010360;pw_pideopciones@1100244001 : Boolean;pw_Grupo@1100244013 : Code[10];pwRecalcular@1103350000 : 'Desconfirmar,Todo,Solo Coste,Solo Ingreso') : Boolean;
    VAR
      lw_opcion@1100244002 : Integer;
      lrParte@1100244003 : Record 7010360;
      lrParte2@1100244004 : Record 7010360;
      lrCI@1100244005 : Record 7010414;
      lrProdIng@1103355000 : Record 7035392;
      lrProdCoste@1103355001 : Record 7035393;
      lrProdCoste2@1103355002 : Record 7035393;
      lrUsu@1100244007 : Record 7010420;
      lrAcc@1100244008 : Record 7010422;
      OPCION_RESTRINGIDA@1100244009 : TextConst 'ESP=Se ha restringido el uso de esta opci¢n. Dirijase a su administrador';
      lrGaraje@1103350003 : Record 7010310;
      lrMod@1103355006 : Record 7035330;
      lw_facturado_ingreso@1100244010 : Boolean;
      lw_facturado_coste@1100244011 : Boolean;
      lwAnulaCoste@1103350001 : Boolean;
      lwAnulaIngreso@1103350002 : Boolean;
      lwGuardaModf_I@1103355004 : ',Si,No';
      lwGuardaModf_C@1103355007 : ',Si,No';
      lwTieneModf@1103355005 : Boolean;
      lrHistorico@1103355003 : Record 7035352;
    BEGIN
      // desconfirmar_partes
      //
      // AJS --> Funcion encargada de retroceder el parte al estado de pendiente, hay que comprobar
      //         que ninguna de las lineas de C/I ha sido validada. Hay que comprobar si se ha
      //         generado la prevision en cuyo caso hay que generar una prevision en negativo.
      //         pwRecalcular - Indica si se desconfirma todo o solo el coste o el ingreso

      lwAnulaCoste   :=  pwRecalcular <> pwRecalcular::"Solo Ingreso";
      lwAnulaIngreso :=  pwRecalcular <> pwRecalcular::"Solo Coste";

      // BRM 25/05/04 Solo podemos desconfirmar partes de grupo desde la pantalla de Grupos
      // JPT 26/09/06 Ahora dejamos desconfirmar partes de grupo
      {
      IF (prParte."Cod Grupo" <> '') THEN
        ERROR(err12, prParte."Cod Grupo");
      }

      // BRM 25/05/04 Partes q vamos a desconfirmar si pertenecen a un grupo

      IF (pw_Grupo <> '') THEN BEGIN
        lrParte.RESET;
        lrParte.SETCURRENTKEY("Cod Grupo");
        lrParte.SETRANGE("Cod Grupo", pw_Grupo);
        lrParte.SETRANGE(Confirmado , TRUE);
      END ELSE BEGIN
        lrParte.COPY(prParte);
        IF pw_pideopciones THEN
          lw_opcion := STRMENU(text2, 1)
        ELSE
          lw_opcion := 1;
        CASE lw_opcion OF
          0: EXIT;
          1: lrParte.SETRECFILTER;
        END;
      END;

      IF lrUsu.GET(USERID) THEN
        IF lrAcc.GET(lrUsu."Perfil Transfer", Text50000) THEN
           ERROR(OPCION_RESTRINGIDA);

      // JPT 03/12/08 Indica si se tienen que guardar las lineas de modificaciones manuales
      // para que dichas modificaciones viajen a las nuevas lineas

      CLEAR(lwGuardaModf_I);
      CLEAR(lwGuardaModf_C);
      IF lrParte.FINDSET THEN BEGIN
        REPEAT
          // JPT 22/06/09 DRF IBZ 09001 - Valoraci¢n de partes de recogida
          // Esto es para evitar que el bucle genere un mensaje de error al confimar Parte Recogida
          IF prParte."Origen creacion" <>-1 THEN
            cFunRec.CompDesc(lrParte); // Comprobamos que no sea un parte de recogida

          // JPT- 19/07/05 TER No permitimos desconfirmar un parte cuyo garaje sea de Cobro Directo

          CLEAR(lrGaraje);
          lrGaraje.GET(lrParte.Garaje);
          IF lrGaraje."Cobro Directo" THEN
            ERROR(Text0020, lrParte."N§ Parte", lrGaraje.Garaje);

          // ----  Comprobar si el ingreso esta facturado en cuyo caso hay que preguntar si se  ----
          // ----  desea continuar y en caso afirmativo hay que generar lineas de abono         ----

          IF lwAnulaIngreso THEN BEGIN
            lw_facturado_ingreso := FALSE;

            lrCI.RESET;
            lrCI.SETRANGE("N§ Parte"   , lrParte."N§ Parte");
            lrCI.SETRANGE (Concepto    , lrCI.Concepto::Ingreso);
            IF lrCI.FINDFIRST THEN BEGIN
              IF NOT CONFIRM(text7, FALSE, text14, lrParte."N§ Parte") THEN
                EXIT(FALSE);
              lw_facturado_ingreso := TRUE;
            END;

            // ----  Si se habia prefacturado generar  un aviso para saber si quiere deshacer la  ----
            // ----  o las prefacturas                                                            ----

            lrProdIng.RESET;
            lrProdIng.SETRANGE ("N§ Parte"     , lrParte."N§ Parte");
            lrProdIng.SETFILTER("N§ Prefactura", '<>%1', '');
            IF lrProdIng.FINDFIRST THEN BEGIN
              IF CONFIRM(msg2, TRUE) THEN BEGIN
                Deshacer_Varias_Prefacturas(lrProdIng);
              END
              ELSE
                MESSAGE(msg1);
            END;
          END;

          // ----  AJS 23.04.03 Comprobar si el coste esta facturado en cuyo caso hay que preguntar si se  ----
          // ----  desea continuar y en caso afirmativo hay que generar lineas de abono                    ----

          IF lwAnulaCoste THEN BEGIN
            lw_facturado_coste := FALSE;

            lrProdCoste.RESET;
            lrProdCoste.SETCURRENTKEY("N§ Parte","N§ Prefactura","N§ Factura");
            lrProdCoste.SETRANGE("N§ Parte"   , lrParte."N§ Parte");
            lrProdCoste.SETFILTER ("N§ Factura",'<>%1','');
            IF lrProdCoste.FINDFIRST THEN BEGIN
              IF NOT CONFIRM(text7, FALSE, text13, lrParte."N§ Parte") THEN
                EXIT(FALSE);
              lw_facturado_coste := TRUE;
            END;

            // ----  Si se habia prefacturado generar  un aviso para saber si quiere deshacer la  ----
            // ----  o las prefacturas                                                            ----

            lrProdCoste.RESET;
            lrProdCoste.SETCURRENTKEY("N§ Parte" ,"N§ Prefactura","N§ Factura");
            lrProdCoste.SETRANGE ("N§ Parte"     , lrParte."N§ Parte");
            lrProdCoste.SETFILTER("N§ Prefactura", '<>%1', '');
            lrProdCoste.SETRANGE("N§ Factura"    , '');
            IF lrProdCoste.FINDFIRST THEN BEGIN
              REPEAT
                deshacer_prefactura_coste(lrProdCoste."N§ Prefactura");
              UNTIL lrProdCoste.NEXT =0;
            END;
          END;

          // ----  Comprobamos si se ha generado prevision en cuyo caso hay que generar una  ----
          // ----  contraprevision                                                           ----

          IF lrParte."Generada prevision" THEN BEGIN
            IF lwAnulaCoste THEN
              crear_prevision_coste_parte(lrParte, -1);
            IF lwAnulaIngreso THEN
              crear_prevision_ingreso_parte(lrParte, -1);
          END;

          // ## Borramos las lineas de produccion de coste  que no sean lineas de abono y regularizamos las lineas
          // ## ya facturadas siempre que pertenezcan a la ultima confirmacion del parte

          IF lwAnulaCoste THEN BEGIN

            // ## Produccion

            lrProdCoste.RESET;
            lrProdCoste.SETCURRENTKEY("N§ Parte","N§ Prefactura","N§ Factura");
            lrProdCoste.SETRANGE("N§ Parte"   , lrParte."N§ Parte");
            lrProdCoste.SETRANGE("Linea abono", FALSE);
            lrProdCoste.SETRANGE("N§ Factura" , '');

            // AJF 23/09/08
            // Borramos el historico de C/I.
            IF lrProdCoste.FINDSET THEN BEGIN
              REPEAT
                lrHistorico.RESET;
                lrHistorico.SETCURRENTKEY("N§ parte", Concepto, "N§ Linea");
                lrHistorico.SETRANGE("N§ parte", lrProdCoste."N§ Parte");
                lrHistorico.SETRANGE("N§ Linea", lrProdCoste."N§ Linea");
                lrHistorico.SETRANGE(Concepto  , lrHistorico.Concepto::"Produccion coste");
                IF lrHistorico.FINDSET THEN
                  lrHistorico.DELETEALL;
              UNTIL lrProdCoste.NEXT = 0;
            END;

            // JPT 03/12/08 Desmarcamos las modificaciones manuales para que puedan pasar a las siguientes lineas
            // El campo lwTieneModf sirve para hacer la pregunta UNA SOLA VEZ y no repetirla por parte
            CLEAR(lrMod);
            lrMod.SETCURRENTKEY("N§ Parte","N§ Linea",Tipo,"No Campo");
            lrMod.SETRANGE("N§ Parte", lrParte."N§ Parte");
            lrMod.SETRANGE(Tipo, lrMod.Tipo::Coste);
            lrMod.SETFILTER("N§ Linea", '<>%1', 0);
            lwTieneModf := lrMod.FINDFIRST;

            IF lwTieneModf AND (lwGuardaModf_C=0) THEN BEGIN
              IF CONFIRM(Text0028, FALSE, lrMod.Tipo) THEN
                lwGuardaModf_C := lwGuardaModf_C::Si
              ELSE
                lwGuardaModf_C := lwGuardaModf_C::No;
            END;

            IF lrProdCoste.FINDFIRST THEN BEGIN
              IF lwTieneModf THEN BEGIN
                lwTieneModf := lwTieneModf AND (lwGuardaModf_C = lwGuardaModf_C::Si);
                IF lwTieneModf THEN
                  DesMModificaciones(lrParte."N§ Parte", 1) // Las desmarca para que puedan se asignadas
                ELSE
                  DelModificaciones(lrParte."N§ Parte", 1); // Las borra
              END;
              lrProdCoste.DELETEALL;
            END;

            IF lw_facturado_coste THEN BEGIN
              lrProdCoste.SETFILTER("N§ Factura" ,'<>%1', '');
              IF lrProdCoste.FINDSET THEN BEGIN
                REPEAT

                  // ## Generamos lineas de produccion en negativo si la linea de coste/ingreso pertenece a la ultima vez
                  // ## que se confirmo el parte

                  IF lrParte."Fecha Confirmacion" = lrProdCoste."Fecha Confirmacion" THEN BEGIN
                    lrProdCoste2 := lrProdCoste;
                    lrProdCoste2.GirarImportes;
                    lrProdCoste2."N§ Prefactura" := '';
                    lrProdCoste2."N§ Factura"    := '';
                    lrProdCoste2."Fecha registro factura" := 0D;
                    lrProdCoste2."Linea abono"            := TRUE;
                    lrProdCoste2.INSERT(TRUE);
                  END;
                UNTIL lrProdCoste.NEXT = 0;
              END;
            END;
          END;

          // ## Borramos las lineas de produccion de ingreso que no sean lineas de abono y regularizamos las lineas
          // ## ya facturadas siempre que pertenezcan a la ultima confirmacion del parte

          IF lwAnulaIngreso THEN BEGIN

            // ## Produccion

            lrProdIng.RESET;
            lrProdIng.SETRANGE("N§ Parte"   , lrParte."N§ Parte");
            lrProdIng.SETRANGE("Linea abono", FALSE);

            // AJF 23/09/08
            // Borramos el historico de C/I.
            IF lrProdIng.FINDSET THEN BEGIN
              REPEAT
                lrHistorico.RESET;
                lrHistorico.SETCURRENTKEY("N§ parte", Concepto, "N§ Linea");
                lrHistorico.SETRANGE("N§ parte", lrProdIng."N§ Parte");
                lrHistorico.SETRANGE("N§ Linea", lrProdIng."N§ Linea");
                lrHistorico.SETRANGE(Concepto  , lrHistorico.Concepto::"Produccion ingreso");
                IF lrHistorico.FINDSET THEN
                  lrHistorico.DELETEALL;
              UNTIL lrProdIng.NEXT = 0;
            END;

            // JPT 03/12/08 Desmarcamos las modificaciones manuales para que puedan pasar a las siguientes lineas
            // El campo lwTieneModf sirve para hacer la pregunta UNA SOLA VEZ y no repetirla por parte
            CLEAR(lrMod);
            lrMod.SETCURRENTKEY("N§ Parte","N§ Linea",Tipo,"No Campo");
            lrMod.SETRANGE("N§ Parte", lrParte."N§ Parte");
            lrMod.SETRANGE(Tipo, lrMod.Tipo::Ingreso);
            lrMod.SETFILTER("N§ Linea", '<>%1', 0);
            lwTieneModf := lrMod.FINDFIRST;

            IF lwTieneModf AND (lwGuardaModf_I=0) THEN BEGIN
              IF CONFIRM(Text0028, FALSE, lrMod.Tipo) THEN
                lwGuardaModf_I := lwGuardaModf_I::Si
              ELSE
                lwGuardaModf_I := lwGuardaModf_I::No;
            END;

            IF lrProdIng.FINDFIRST THEN BEGIN
              IF lwTieneModf THEN BEGIN
                lwTieneModf := lwTieneModf AND (lwGuardaModf_I = lwGuardaModf_I::Si);
                IF lwTieneModf THEN
                  DesMModificaciones(lrParte."N§ Parte", 0) // Las desmarca para que puedan se asignadas
                ELSE
                  DelModificaciones(lrParte."N§ Parte", 0); // Las borra
              END;
              lrProdIng.DELETEALL;
            END;

            IF lw_facturado_ingreso THEN BEGIN
              lrCI.RESET;
              lrCI.SETRANGE("N§ Parte"   , lrParte."N§ Parte");
              lrCI.SETRANGE(Concepto     , lrCI.Concepto::Ingreso);
              lrCI.SETRANGE("Linea abono", FALSE);
              IF lrCI.FINDSET THEN BEGIN
                REPEAT
                  // ## Generamos lineas de produccion en negativo si la linea de coste/ingreso pertenece a la ultima vez
                  // ## que se confirmo el parte

                  IF lrParte."Fecha Confirmacion" = lrCI."Fecha Confirmacion" THEN BEGIN
                    girar_importes(lrCI);

                    lrProdIng.TRANSFERFIELDS(lrCI);
                    lrProdIng."N§ Prefactura" := '';
                    lrProdIng."N§ Factura"    := '';
                    lrProdIng."Fecha registro factura" := 0D;
                    lrProdIng."Linea abono"            := TRUE;
                    lrProdIng.INSERT(TRUE);
                  END;
                UNTIL lrCI.NEXT = 0;
              END;
            END;
          END;

          IF pwRecalcular = pwRecalcular::Desconfirmar THEN BEGIN

            // Desmarcar el parte para poder realizar modificaciones sobre l y marcar como pendiente
            // de generar prevision.

            lrParte2 := lrParte;
            lrParte2.VALIDATE (Confirmado , FALSE);
            lrParte2."Generada prevision" := FALSE;

            CLEAR(lrParte2."Fecha Confirmacion");
            IF lrParte2.Facturable THEN
              lrParte2.Facturado := FALSE;
            lrParte2.MODIFY;

            // Marcamos tambien los registros asociados en Touroperador x Parte

            Tratar_TTOOxParte(lrParte."N§ Parte", FALSE);
          END;

          IF pwRecalcular <> pwRecalcular::"Solo Ingreso" THEN
            cCalCost.EliminaMovOG(lrParte);

          // JPT 22/06/09 DRF IBZ 09001 - Valoraci¢n de partes de recogida
          // Esto es para evitar que el bucle genere un mensaje de error al confimar Parte Recogida
          IF prParte."Origen creacion" <>-1 THEN
            cFunRec.DesconfirmarParteRecogida(lrParte, pwRecalcular);

        UNTIL lrParte.NEXT = 0;
      END;
      EXIT(TRUE);
    END;

    PROCEDURE girar_importes@30(VAR prCI2@1100244000 : Record 7010414);
    BEGIN
      // girar_importes
      //
      prCI2.Pax                       := - prCI2.Pax;
      prCI2."Pax Real"                := - prCI2."Pax Real";
      prCI2.Importe                   := - prCI2.Importe;
      prCI2."Importe DL"              := - prCI2."Importe DL";
      prCI2."Importe sin impuesto"    := - prCI2."Importe sin impuesto";
      prCI2."Importe sin impuesto DL" := - prCI2."Importe sin impuesto DL";
      prCI2."Importe con impuesto"    := - prCI2."Importe con impuesto";
      prCI2."Importe con impuesto DL" := - prCI2."Importe con impuesto DL";
      prCI2."Importe sin original"    := - prCI2."Importe sin original";
      prCI2."Importe con original"    := - prCI2."Importe con original";
      prCI2."Precio Pax"              := - prCI2."Precio Pax";
      prCI2."Precio Pax DL"           := - prCI2."Precio Pax DL";
      prCI2."Precio Vehiculo"         := - prCI2."Precio Vehiculo";
      prCI2."Precio Vehiculo DL"      := - prCI2."Precio Vehiculo DL";
      prCI2."Pax Facturados"          := - prCI2."Pax Facturados";
      prCI2."Pax Transportados"       := - prCI2."Pax Transportados";
    END;

    PROCEDURE Tratar_TTOOxParte@19(pParte@1100244000 : Code[10];pValor@1100244001 : Boolean);
    VAR
      rTxP@1100244002 : Record 7010365;
    BEGIN
      // Tratar_TTOOxParte(pParte, pValor);

      rTxP.RESET;
      rTxP.SETCURRENTKEY("N§ Parte");
      rTxP.SETRANGE("N§ Parte", pParte);
      IF rTxP.FINDSET(TRUE) THEN BEGIN
        REPEAT
          rTxP.Confirmado := pValor;
          rTxP.MODIFY;
        UNTIL rTxP.NEXT = 0;
      END;
    END;

    PROCEDURE generar_prevision@9();
    VAR
      rConf@1100244000 : Record 98;
      rPar@1100244001 : Record 7010311;
      rParte@1100244002 : Record 7010360;
      rCond@1100244004 : Record 7010420;
      rProdCoste@1100244005 : Record 7035393;
      rCosteAnterior@1103355000 : Record 7035393;
      rProdIng@1103355002 : Record 7035392;
      rIngresoAnterior@1103355004 : Record 7035392;
      fFicTmp@1100244008 : Form 7035254;
      GestNoSerie@1100244009 : Codeunit 396;
      cVal@1100244010 : Codeunit 7010320;
      w_importe_linea@1100244015 : Decimal;
      w_num_documento@1100244016 : Code[10];
      w_ultima_linea@1100244017 : Integer;
      w_ultimo_asiento@1100244018 : Integer;
      rProdCosteTMP@1000000000 : TEMPORARY Record 7035393;
      rProdIngTMP@1000000001 : TEMPORARY Record 7035392;
    BEGIN
      // generar_prevision
      //
      // AJS --> Crear los asientos de prevision de ingresos y costes a partir de las lineas de
      //         coste-ingreso de los partes. Se generara un asiento por Dia, Touroperador y
      //         Tipo de Servicio.
      //

      // AJF 07/01/09
      // Evito borrar el registro, ya que ahora tiene datos permanentes.
      IF rCond.GET(USERID) THEN
        rCond.LimpiaRegistro
      ELSE BEGIN
        rCond.INIT;
        rCond.Usuario := USERID;
        rCond.INSERT;
      END;

      COMMIT;
      rCond.SETRECFILTER;

      CLEAR(fFicTmp);
      fFicTmp.SETTABLEVIEW(rCond);
      IF fFicTmp.RUNMODAL <> ACTION::OK THEN
        EXIT;
      rCond.GET(USERID);
      IF rCond."Fecha Factura" = 0D THEN
        EXIT;

      // ## Prevision de costes

      rProdCoste.RESET;
      rProdCoste.SETCURRENTKEY(Garaje,
                               Touroperador,
                               "Tipo servicio",
                               Fecha,
                               "Generada prevision");
      rProdCoste.SETRANGE ("Generada prevision", FALSE);
      rProdCoste.SETFILTER(Fecha               , '<=%1', rCond."Fecha Factura");
      IF rProdCoste.FINDSET THEN BEGIN
        w_importe_linea  := 0;
        rCosteAnterior   := rProdCoste;

        rPar.FINDFIRST;
        rConf.FINDFIRST;

        rPar.TESTFIELD("Libro diario Previsiones");
        rPar.TESTFIELD("Seccion Previsiones coste");
        rPar.TESTFIELD("Serie Previsiones coste");
        rPar.TESTFIELD("Cuenta Compras");

        w_ultima_linea   := cVal.busca_ultima_linea(rPar, TRUE);   // TRUE para indicar que es para una
                                                                   // prevision de coste.
        w_ultimo_asiento := cVal.busca_ultimo_asiento(rPar, TRUE);
        w_num_documento  := '';
        GestNoSerie.InitSeries(rPar."Serie Previsiones coste", rPar."Serie Previsiones coste",
                               TODAY, w_num_documento, rPar."Serie Previsiones coste");

        // $002 ARM Limpiamos el temporal para rellenar tabla de detalle
        CLEAR(rProdCosteTMP); // +$002
        rProdCosteTMP.DELETEALL;  // +$002
        REPEAT
          IF (rCosteAnterior.Garaje <> rProdCoste.Garaje) OR
             (rCosteAnterior.Fecha <> rProdCoste.Fecha) OR
             (rCosteAnterior.Touroperador <> rProdCoste.Touroperador) OR
             (rCosteAnterior."Tipo servicio" <> rProdCoste."Tipo servicio") THEN BEGIN

            // insertar_linea_en diario

            IF w_importe_linea <> 0 THEN
              crear_prevision_coste(rCosteAnterior, w_ultimo_asiento, w_ultima_linea, w_num_documento, w_importe_linea,rProdCosteTMP);

            rCosteAnterior  := rProdCoste;
            w_importe_linea := 0;
            // $002 ARM Limpiamos el temporal para rellenar tabla de detalle
            CLEAR(rProdCosteTMP); // +$002
            rProdCosteTMP.DELETEALL;  // +$002
          END;
          // $002 ARM rellenamos el temporal
          rProdCosteTMP := rProdCoste; // +$002
          rProdCosteTMP.INSERT;        // +$002

          w_importe_linea += rProdCoste."Importe sin impuesto DL";
        UNTIL rProdCoste.NEXT = 0;
        IF w_importe_linea <> 0 THEN
          crear_prevision_coste(rCosteAnterior, w_ultimo_asiento, w_ultima_linea, w_num_documento, w_importe_linea,rProdCosteTMP);

        // ## Marcamos las previsiones de ingresos

        rProdCoste.MODIFYALL("Generada prevision", TRUE);

        // ## Marcamos los partes de trabajo

        rParte.RESET;
        rParte.SETCURRENTKEY(Fecha);
        rParte.SETFILTER(Fecha               , '<=%1', rCond."Fecha Factura");
        rParte.SETRANGE ("Generada prevision", FALSE);
        IF rParte.FINDFIRST THEN
          rParte.MODIFYALL("Generada prevision", TRUE);
      END;

      // ## Prevision de ingresos

      rProdIng.RESET;
      rProdIng.SETCURRENTKEY(Garaje,
                             Touroperador,
                             "Tipo servicio",
                             Fecha,
                             "Tipo elemento",
                             "Generada prevision");
      rProdIng.SETRANGE ("Generada prevision", FALSE);
      rProdIng.SETFILTER(Fecha               , '<=%1', rCond."Fecha Factura");
      IF rProdIng.FINDSET THEN BEGIN
        w_importe_linea  := 0;
        rIngresoAnterior := rProdIng;

        rConf.FINDFIRST;
        rPar.FINDFIRST;

        rPar.TESTFIELD("Libro diario Previsiones");
        rPar.TESTFIELD("Seccion Previsiones ingreso");
        rPar.TESTFIELD("Serie Previsiones ingreso");
        rPar.TESTFIELD("Cuenta Ventas");

        w_ultima_linea   := cVal.busca_ultima_linea(rPar, FALSE);
        w_ultimo_asiento := cVal.busca_ultimo_asiento(rPar, FALSE);
        w_num_documento  := '';
        GestNoSerie.InitSeries(rPar."Serie Previsiones ingreso", rPar."Serie Previsiones ingreso",
                              TODAY, w_num_documento, rPar."Serie Previsiones ingreso");

        // $002 ARM Limpiamos el temporal para rellenar tabla de detalle
        CLEAR(rProdIngTMP); // +$002
        rProdIngTMP.DELETEALL;  // +$002
        REPEAT
          IF (rIngresoAnterior.Garaje <> rProdIng.Garaje) OR
             (rIngresoAnterior.Fecha <> rProdIng.Fecha) OR
             (rIngresoAnterior.Touroperador <> rProdIng.Touroperador) OR
             (rIngresoAnterior."Tipo servicio" <> rProdIng."Tipo servicio") THEN BEGIN

            // insertar_linea_en diario

            IF w_importe_linea <> 0 THEN
              crear_prevision_ingreso(rIngresoAnterior, w_ultimo_asiento, w_ultima_linea, w_num_documento, w_importe_linea,rProdIngTMP);

            rIngresoAnterior := rProdIng;
            w_importe_linea  := 0;
            // $002 ARM Limpiamos el temporal para rellenar tabla de detalle
            CLEAR(rProdIngTMP); // +$002
            rProdIngTMP.DELETEALL;  // +$002
          END;
          // $002 ARM rellenamos el temporal
          rProdIngTMP := rProdIng; // +$002
          rProdIngTMP.INSERT;        // +$002

          IF (rPar."Maletas en  Prev. Ingresos") OR (rProdIng."Tipo elemento" <> rPar."Codigo Maletas") THEN
            w_importe_linea += rProdIng."Importe sin impuesto DL";
        UNTIL rProdIng.NEXT = 0;

        IF w_importe_linea <> 0 THEN
          crear_prevision_ingreso(rIngresoAnterior, w_ultimo_asiento, w_ultima_linea, w_num_documento, w_importe_linea,rProdIngTMP);

        // ## Marcamos las lineas de prevision

        rProdIng.MODIFYALL("Generada prevision", TRUE);

        // ## Marcamos los partes de trabajo

        rParte.RESET;
        rParte.SETCURRENTKEY(Fecha);
        rParte.SETFILTER(Fecha               , '<=%1', rCond."Fecha Factura");
        rParte.SETRANGE ("Generada prevision", FALSE);
        IF rParte.FINDFIRST THEN
          rParte.MODIFYALL("Generada prevision", TRUE);

      END;
    END;

    PROCEDURE totalizar_importe@4(VAR prPC@1100244000 : Record 7035393);
    VAR
      lrDiv@1100244001 : Record 4;
      rPC@1100244002 : Record 7035393;
      ventana@1100244003 : Dialog;
      w_importe@1100244004 : Decimal;
      w_importe_marcadas@1100244005 : Decimal;
      w_importe_divisa@1100244006 : Decimal;
      w_importe_divisa_marcadas@1100244007 : Decimal;
      lw_ok@1100244008 : Boolean;
    BEGIN
      // totalizar_importe
      //
      // AJS --> Totaliza las lineas de coste-ingreso que vengan filtradas con el registro de parametro
      //         muestra en una ventana de dialogo el resultado del campo "Importe sin Impuesto DL"
      //         y el campo "Importe sin impuesto".
      //
      w_importe := 0;
      w_importe_marcadas := 0;
      rPC.RESET; rPC.INIT;
      rPC.COPY(prPC);
      IF rPC.FINDSET THEN BEGIN
        ventana.OPEN(text3 + '#1########\' +
                     text9 + '#4########\' +
                     '\' +
                     text4 + '#2######## ' + text5 + ' #3########\' +
                     text10 + '#5########');
        ventana.UPDATE(2, USERID);
        lw_ok := lrDiv.GET(rPC."Cod. Divisa");
        REPEAT
          rPC.CALCFIELDS("Importe validado");
          IF rPC."Importe validacion DL" <> 0 THEN BEGIN
            w_importe := w_importe + rPC."Importe validacion DL";
            w_importe_divisa := w_importe_divisa + rPC."Importe validacion";
          END
          ELSE BEGIN
            w_importe := w_importe + (rPC."Importe sin impuesto DL" - rPC."Importe validado");
            w_importe_divisa := w_importe_divisa + (rPC."Importe sin impuesto" - rPC."Importe validado");
          END;
          IF rPC.Marca = USERID THEN BEGIN
            IF rPC."Importe validacion DL" <> 0 THEN BEGIN
              w_importe_marcadas := w_importe_marcadas + rPC."Importe validacion DL";
              w_importe_divisa_marcadas := w_importe_divisa_marcadas + rPC."Importe validacion";
            END
            ELSE BEGIN
              w_importe_marcadas := w_importe_marcadas + (rPC."Importe sin impuesto DL" -
                                                          rPC."Importe validado");
              w_importe_divisa_marcadas := w_importe_divisa_marcadas + (rPC."Importe sin impuesto" -
                                                                        rPC."Importe validado");
            END;
          END;
          ventana.UPDATE(1, ROUND(w_importe));
          ventana.UPDATE(3, ROUND(w_importe_marcadas));
          ventana.UPDATE(4, ROUND(w_importe_divisa, lrDiv."Amount Rounding Precision"));
          ventana.UPDATE(5, ROUND(w_importe_divisa_marcadas, lrDiv."Amount Rounding Precision"));
        UNTIL rPC.NEXT = 0;
      END;
      SLEEP(7000);
      ventana.CLOSE;
    END;

    PROCEDURE marcar_linea_coste@5(VAR prPC@1100244000 : Record 7035393);
    BEGIN
      // marcar_linea_coste
      //
      // AJS --> Si el campo marca esta en blanco, poner el USERID sino, dejarlo en blanco.
      //
      IF prPC.Marca = '' THEN BEGIN
        IF prPC."Importe con impuesto" <> prPC."Importe validado" THEN
          prPC.Marca := USERID
        ELSE
          ERROR(err5);
      END
      ELSE
        prPC.Marca := '';
      prPC.MODIFY;
    END;

    PROCEDURE cambiar_importe_validacion@6(VAR prPC@1100244000 : Record 7035393);
    VAR
      fFicTmp@1100244001 : Form 7035257;
      rCond@1100244002 : Record 7010420;
    BEGIN
      // cambiar_importe_validacion
      //
      // AJS -->  Llamar a la ventana donde imputar el importe y los paxes de validacion. controlando
      //          que el importe y el numero de paxes sea valido.
      //

      // ----  Comprobar si la linea es de ajuste manual, y si lo es dar un mensaje de error  ----

      IF prPC."Tipo linea" = prPC."Tipo linea"::Ajuste THEN
        ERROR(no_validacion_en_ajuste);


      // AJF 07/01/09
      // Evito borrar el registro, ya que ahora tiene datos permanentes.
      IF rCond.GET(USERID) THEN
        rCond.LimpiaRegistro
      ELSE BEGIN
        rCond.INIT;
        rCond.Usuario := USERID;
        rCond.INSERT;
      END;

      rCond."N§ Parte"       := prPC."N§ Parte";
      rCond."N§ Linea coste" := prPC."N§ Linea";
      rCond.Operacion        := rCond.Operacion::Validacion;
      rCond.MODIFY;

      COMMIT;
      rCond.SETRECFILTER;

      CLEAR(fFicTmp);
      fFicTmp.SETTABLEVIEW(rCond);
      IF fFicTmp.RUNMODAL <> ACTION::OK THEN
        EXIT;
      rCond.GET(USERID);

      prPC.VALIDATE("Importe validacion", rCond.Importe);
      prPC."Pax validacion" := rCond.Paxes;
      prPC.MODIFY;
    END;

    PROCEDURE crear_linea_ajuste_coste@7(prPC@1100244000 : Record 7035393);
    VAR
      fFicTmp@1100244001 : Form 7035256;
      rCond@1100244002 : Record 7010420;
      rPC@1100244003 : Record 7035393;
    BEGIN
      // crear_linea_ajuste_coste
      //
      // AJS --> Crear una linea para poder validar por mayor importe del calculado en un
      //         principio, estas lineas se deben a peque¤os ajustes manuales de la facturacion
      //         no dejar crear lineas con importe a cero.
      //

      // AJF 07/01/09
      // Evito borrar el registro, ya que ahora tiene datos permanentes.
      IF rCond.GET(USERID) THEN
        rCond.LimpiaRegistro
      ELSE BEGIN
        rCond.INIT;
        rCond.Usuario := USERID;
        rCond.INSERT;
      END;

      rCond."N§ Parte"       := prPC."N§ Parte";
      rCond."N§ Linea coste" := prPC."N§ Linea";
      rCond.Operacion        := rCond.Operacion::Ajuste;
      rCond.MODIFY;

      COMMIT;
      rCond.SETRECFILTER;

      CLEAR(fFicTmp);
      fFicTmp.SETTABLEVIEW(rCond);
      IF fFicTmp.RUNMODAL <> ACTION::OK THEN
        EXIT;
      rCond.GET(USERID);
      IF rCond.Importe = 0 THEN
        ERROR(err2);

      rPC := prPC;
      rPC."Tipo linea"  := rPC."Tipo linea"::Ajuste;
      rPC."Cod. Divisa" := '';
      rPC."Pax Real"    := 1;
      rPC.VALIDATE(Importe               , rCond.Importe);
      rPC.VALIDATE("Importe con impuesto", rCond.Importe);
      rPC.VALIDATE("Precio Pax"          , 0);
      rPC.VALIDATE("Precio Vehiculo"     , 0);
      rPC."N§ Factura"  := '';

      rPC.INSERT(TRUE);
    END;

    PROCEDURE borra_linea_ajuste@8(prPC@1100244000 : Record 7035393);
    VAR
      rPC@1100244001 : Record 7035393;
    BEGIN
      // borra_linea_ajuste
      //
      IF prPC."Tipo linea" <> prPC."Tipo linea"::Ajuste THEN
        ERROR(err3);
      IF prPC."N§ Factura" <> '' THEN
        ERROR(err4);
      IF NOT CONFIRM(text6) THEN
        EXIT;
      rPC := prPC;
      rPC.DELETE;
    END;

    PROCEDURE crear_prevision_coste_parte@10(prParte@1100244000 : Record 7010360;pw_signo@1100244001 : Integer);
    VAR
      rPar@1100244002 : Record 7010311;
      rToPar@1100244003 : Record 7010365;
      rProdCoste@1100244004 : Record 7035393;
      rProdCoste2@1103355000 : Record 7035393;
      rProv@1100244005 : Record 23;
      rGrup@1100244006 : Record 93;
      rDetAsi@1000000000 : Record 7010436;
      GestNoSerie@1100244007 : Codeunit 396;
      cVal@1100244008 : Codeunit 7010320;
      w_num_documento@1100244009 : Code[10];
      w_ultima_linea@1100244010 : Integer;
      w_ultimo_asiento@1100244011 : Integer;
      w_opcion@1100244012 : 'Debe,Haber';
      w_importe@1100244013 : Decimal;
      w_tipo_asiento@1100244015 : 'Normal Ingreso,Normal Coste,Regul Ingreso,Regul Coste,Ajuste Ingreso,Ajuste Coste';
    BEGIN
      // crear_prevision_coste_parte
      //
      // AJS -- > Se encarga de crear los asientos de prevision o contraprevision de coste
      //          de un parte dependiendo del signo.
      //
      IF prParte.Proveedor = '' THEN // En aquellos casos en que no hay proveedor obviamente no hay
        EXIT;                        // prevision de coste.

      rPar.FINDFIRST;

      rPar.TESTFIELD("Libro diario Previsiones");
      rPar.TESTFIELD("Seccion Previsiones coste");
      rPar.TESTFIELD("Serie Previsiones coste");
      rPar.TESTFIELD("Cuenta Compras");

      rProdCoste.RESET;

      w_ultima_linea   := cVal.busca_ultima_linea(rPar, TRUE);   // TRUE para indicar que es para una
                                                                 // prevision de coste.
      w_ultimo_asiento := cVal.busca_ultimo_asiento(rPar, TRUE);

      busca_proveedor(rProv, rGrup, prParte.Proveedor);

      rToPar.RESET;
      rToPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF rToPar.FINDSET THEN BEGIN
        REPEAT
          rProdCoste.SETRANGE("N§ Parte"   , prParte."N§ Parte");
          rProdCoste.SETRANGE(Touroperador , rToPar.Touroperador);
          IF NOT rPar."Maletas en  Prev. Ingresos" THEN
            rProdCoste.SETFILTER("Tipo elemento", '<>%1', rPar."Codigo Maletas");

          IF pw_signo = 1 THEN
            rProdCoste.SETRANGE("Generada prevision", FALSE)
          ELSE
            rProdCoste.SETRANGE("Generada prevision", TRUE);

          IF rProdCoste.FINDFIRST THEN BEGIN
            rProdCoste2.COPY(rProdCoste);
            rProdCoste2.CALCSUMS("Importe sin impuesto DL");
            w_importe := rProdCoste2."Importe sin impuesto DL";

            IF w_importe <> 0 THEN BEGIN
              w_num_documento := '';
              GestNoSerie.InitSeries(rPar."Serie Previsiones coste", rPar."Serie Previsiones coste",
                                     TODAY, w_num_documento, rPar."Serie Previsiones coste");
              w_ultimo_asiento := w_ultimo_asiento + 1;
              w_ultima_linea   := w_ultima_linea + 1000;
              IF pw_signo = 1 THEN
                cVal.linea_prevision(w_ultima_linea, w_ultimo_asiento, rToPar.Touroperador,
                                     rPar."Cuenta Compras", rProdCoste.Fecha, w_num_documento, rProv.Name,
                                     w_opcion::Debe, (pw_signo * w_importe), rPar,
                                     rPar."Seccion Previsiones coste", w_tipo_asiento::"Normal Coste",
                                     rProdCoste."Tipo servicio", rProdCoste.Garaje, rProdCoste."N§ Parte", rProdCoste.Proveedor)
              ELSE
                cVal.linea_prevision(w_ultima_linea, w_ultimo_asiento, rToPar.Touroperador,
                                     rPar."Cuenta Compras", rProdCoste.Fecha, w_num_documento, rProv.Name,
                                     w_opcion::Debe, (pw_signo * w_importe), rPar,
                                     rPar."Seccion Previsiones coste", w_tipo_asiento::"Regul Coste",
                                     rProdCoste."Tipo servicio", rProdCoste.Garaje, rProdCoste."N§ Parte", rProdCoste.Proveedor);

              // < $002 GEneramos detalles de asiento
              CLEAR(rDetAsi);
              rDetAsi.INIT;
              rDetAsi.Parte := rProdCoste."N§ Parte";
              rDetAsi."Linea diario" := w_ultima_linea;
              rDetAsi."Tipo linea" := rDetAsi."Tipo linea"::Coste;
              IF pw_signo = 1 THEN
                rDetAsi."Tipo asiento" := rDetAsi."Tipo asiento"::Creacion
              ELSE
                rDetAsi."Tipo asiento" := rDetAsi."Tipo asiento"::Cancelacion;
              rDetAsi.Importe := rProdCoste."Importe sin impuesto DL";
              rDetAsi.INSERT(TRUE);
              // $002 >

              w_ultima_linea := w_ultima_linea + 1000;
              IF pw_signo = 1 THEN
                cVal.linea_prevision(w_ultima_linea, w_ultimo_asiento, rToPar.Touroperador,
                                     rGrup."Cta facturas pdtes recibir", rProdCoste.Fecha, w_num_documento, rProv.Name,
                                     w_opcion::Haber, (pw_signo * w_importe), rPar,
                                     rPar."Seccion Previsiones coste", w_tipo_asiento::"Normal Coste",
                                     rProdCoste."Tipo servicio", rProdCoste.Garaje, rProdCoste."N§ Parte", rProdCoste.Proveedor)
              ELSE
                cVal.linea_prevision(w_ultima_linea, w_ultimo_asiento, rToPar.Touroperador,
                                     rGrup."Cta facturas pdtes recibir", rProdCoste.Fecha, w_num_documento, rProv.Name,
                                     w_opcion::Haber, (pw_signo * w_importe), rPar,
                                     rPar."Seccion Previsiones coste", w_tipo_asiento::"Regul Coste",
                                     rProdCoste."Tipo servicio", rProdCoste.Garaje, rProdCoste."N§ Parte", rProdCoste.Proveedor);

              IF pw_signo = 1 THEN
                rProdCoste.MODIFYALL("Generada prevision", TRUE);
            END;
          END;
        UNTIL rToPar.NEXT = 0;
      END;
    END;

    PROCEDURE crear_prevision_ingreso_parte@12(prParte@1100244000 : Record 7010360;pw_signo@1100244001 : Integer);
    VAR
      rPar@1100244002 : Record 7010311;
      rToPar@1100244003 : Record 7010365;
      rProdIng@1100244004 : Record 7035392;
      rProdIng2@1103355000 : Record 7035392;
      rCli@1100244005 : Record 18;
      rGrup@1100244006 : Record 92;
      rDetAsi@1000000000 : Record 7010436;
      GestNoSerie@1100244007 : Codeunit 396;
      cVal@1100244008 : Codeunit 7010320;
      w_num_documento@1100244009 : Code[10];
      w_ultima_linea@1100244010 : Integer;
      w_ultimo_asiento@1100244011 : Integer;
      w_opcion@1100244012 : 'Debe,Haber';
      w_importe@1100244013 : Decimal;
      w_importe_soporte@1100244014 : Decimal;
      w_tipo_asiento@1100244015 : 'Normal Ingreso,Normal Coste,Regul Ingreso,Regul Coste,Ajuste Ingreso,Ajuste Coste';
    BEGIN
      // crear_prevision_ingreso_parte
      //
      // AJS -- > Se encarga de crear los asientos de prevision o contraprevision de ingreso
      //          dependiendo del signo.
      //
      rPar.FINDFIRST;

      rPar.TESTFIELD("Libro diario Previsiones");
      rPar.TESTFIELD("Seccion Previsiones ingreso");
      rPar.TESTFIELD("Serie Previsiones ingreso");
      rPar.TESTFIELD("Cuenta Ventas");

      rProdIng.RESET;
      rProdIng.SETCURRENTKEY(Garaje,
                             Touroperador,
                             "Tipo servicio",
                             Fecha,
                             "Tipo elemento",
                             "Generada prevision"); //+$003

      w_ultima_linea   := cVal.busca_ultima_linea(rPar, FALSE);   // FALSE Para indicar que se trata de
                                                                  // una prevision de ingresos.
      w_ultimo_asiento := cVal.busca_ultimo_asiento(rPar, FALSE);

      busca_cliente(rCli, rGrup, prParte.Cliente);

      rToPar.RESET;
      rToPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF rToPar.FINDSET THEN
      BEGIN
        REPEAT
          rProdIng.SETRANGE("N§ Parte"  , prParte."N§ Parte");
          rProdIng.SETRANGE(Touroperador, rToPar.Touroperador);

          IF NOT rPar."Maletas en  Prev. Ingresos" THEN
            rProdIng.SETFILTER("Tipo elemento", '<>%1', rPar."Codigo Maletas");

          IF pw_signo = 1 THEN
            rProdIng.SETRANGE("Generada prevision", FALSE)
          ELSE
            rProdIng.SETRANGE("Generada prevision", TRUE);

          IF rProdIng.FINDFIRST THEN
          BEGIN
            rProdIng2.COPY(rProdIng);
            rProdIng2.CALCSUMS("Importe sin impuesto DL");
            w_importe := rProdIng2."Importe sin impuesto DL";
            IF w_importe <> 0 THEN
            BEGIN
              w_num_documento := '';
              GestNoSerie.InitSeries(rPar."Serie Previsiones ingreso", rPar."Serie Previsiones ingreso",
                                     TODAY, w_num_documento, rPar."Serie Previsiones ingreso");

              w_ultimo_asiento := w_ultimo_asiento + 1;
              w_ultima_linea   := w_ultima_linea + 1000;

              IF pw_signo = 1 THEN
                cVal.linea_prevision(w_ultima_linea, w_ultimo_asiento, rToPar.Touroperador,
                                     rGrup."Cta facturas pdtes enviar", rProdIng.Fecha, w_num_documento, rCli.Name,
                                     w_opcion::Debe, (pw_signo * w_importe), rPar,
                                     rPar."Seccion Previsiones ingreso", w_tipo_asiento::"Normal Ingreso",
                                     rProdIng."Tipo servicio", rProdIng.Garaje, rProdIng."N§ Parte", rProdIng."Cliente Operativo")
              ELSE
                cVal.linea_prevision(w_ultima_linea, w_ultimo_asiento, rToPar.Touroperador,
                                     rGrup."Cta facturas pdtes enviar", rProdIng.Fecha, w_num_documento, rCli.Name,
                                     w_opcion::Debe, (pw_signo * w_importe), rPar,
                                     rPar."Seccion Previsiones ingreso", w_tipo_asiento::"Regul Ingreso",
                                     rProdIng."Tipo servicio", rProdIng.Garaje, rProdIng."N§ Parte", rProdIng."Cliente Operativo");

              // < $002 Generamos detalles de asiento
              CLEAR(rDetAsi);
              rDetAsi.INIT;
              rDetAsi.Parte := rProdIng."N§ Parte";
              rDetAsi."Linea diario" := w_ultima_linea;
              rDetAsi."Tipo linea" := rDetAsi."Tipo linea"::Ingreso;
              IF pw_signo = 1 THEN
                rDetAsi."Tipo asiento" := rDetAsi."Tipo asiento"::Creacion
              ELSE
                rDetAsi."Tipo asiento" := rDetAsi."Tipo asiento"::Cancelacion;
              rDetAsi.Importe := rProdIng."Importe sin impuesto DL";
              rDetAsi.INSERT(TRUE);
              // $002 >

              w_ultima_linea := w_ultima_linea + 1000;

              IF pw_signo = 1 THEN
                cVal.linea_prevision(w_ultima_linea, w_ultimo_asiento, rToPar.Touroperador,
                                     rPar."Cuenta Ventas", rProdIng.Fecha, w_num_documento, rCli.Name,
                                     w_opcion::Haber, (pw_signo * w_importe), rPar,
                                     rPar."Seccion Previsiones ingreso", w_tipo_asiento::"Normal Ingreso",
                                     rProdIng."Tipo servicio", rProdIng.Garaje, rProdIng."N§ Parte", rProdIng."Cliente Operativo")
              ELSE
                cVal.linea_prevision(w_ultima_linea, w_ultimo_asiento, rToPar.Touroperador,
                                     rPar."Cuenta Ventas", rProdIng.Fecha, w_num_documento, rCli.Name,
                                     w_opcion::Haber, (pw_signo * w_importe), rPar,
                                     rPar."Seccion Previsiones ingreso", w_tipo_asiento::"Regul Ingreso",
                                     rProdIng."Tipo servicio", rProdIng.Garaje, rProdIng."N§ Parte", rProdIng."Cliente Operativo");
              IF pw_signo = 1 THEN
                rProdIng.MODIFYALL("Generada prevision", TRUE);
            END;
          END;
        UNTIL rToPar.NEXT = 0;
      END;
    END;

    PROCEDURE busca_proveedor@13(VAR prProv@1100244000 : Record 23;VAR prGrup@1100244001 : Record 93;pw_proveedor@1100244002 : Code[10]);
    VAR
      rCta@1100244003 : Record 15;
    BEGIN
      // busca_proveedor
      //
      // AJS --> Encontrar el Proveedor del asiento de prevision y el grupo contable proveedor
      //         correspondiente para obtener la cuenta de Facturas Pendientes de Recibir.

      prProv.GET(pw_proveedor);
      prProv.TESTFIELD("Vendor Posting Group");
      prGrup.GET(prProv."Vendor Posting Group");
      prGrup.TESTFIELD("Cta facturas pdtes recibir");
      rCta.GET(prGrup."Cta facturas pdtes recibir");
    END;

    PROCEDURE busca_cliente@14(VAR prCli@1100244000 : Record 18;VAR prGrup@1100244001 : Record 92;pw_cliente@1100244002 : Code[20]);
    VAR
      rCta@1100244003 : Record 15;
    BEGIN
      // busca_cliente
      //
      // AJS --> Encontrar el Cliente del asiento de prevision y el grupo contable cliente
      //         correspondiente para obtener la cuenta de Facturas Pendientes de Enviar.
      //
      prCli.GET(pw_cliente);
      prCli.TESTFIELD("Customer Posting Group");
      prGrup.GET(prCli."Customer Posting Group");
      prGrup.TESTFIELD("Cta facturas pdtes enviar");
      rCta.GET(prGrup."Cta facturas pdtes enviar");
    END;

    PROCEDURE deshacer_prefactura@11(pwNoPref@1100244000 : Code[10]);
    VAR
      rCond@1100244001 : Record 7010420;
      rPreFact@1100244002 : Record 7010415;
      rLin@1100244005 : Record 7010417;
      cFunBas@1100244006 : Codeunit 7010310;
      OPCION_RESTRINGIDA@1100244007 : TextConst 'ESP=Se ha restringido el uso de esta acci¢n. Dirijase a su administrador.';
    BEGIN
      // deshacer_prefactura
      //
      // AJS --> Solicita del usuario que prefactura deshacer, borrar el registro del fichero de
      //         prefacturas, de lineas de prefactura y desmarcar las lineas de coste-ingreso.
      //

      IF cFunBas.TestRestriccion(Text50002) THEN
        ERROR(OPCION_RESTRINGIDA);

      // AJF 07/01/09
      // Evito borrar el registro, ya que ahora tiene datos permanentes.
      IF rCond.GET(USERID) THEN
        rCond.LimpiaRegistro
      ELSE BEGIN
        rCond.INIT;
        rCond.Usuario := USERID;
        rCond.INSERT;
      END;

      rCond."N§ Prefactura" := pwNoPref;
      rCond.MODIFY;

      rCond.FILTERGROUP(2);
      rCond.SETRANGE(Usuario, USERID);
      rCond.FILTERGROUP(0);
      COMMIT;

      IF FORM.RUNMODAL(7035252, rCond) <> ACTION::OK THEN
        EXIT;
      rCond.GET(USERID);
      IF rCond."N§ Prefactura" = '' THEN
        EXIT;
      rPreFact.GET(rCond."N§ Prefactura");
      rPreFact.DeshacerPrefactura(TRUE);
    END;

    PROCEDURE reimprimir_prefactura@15(prCI@1100244000 : Record 7010414);
    VAR
      rCond@1100244001 : Record 7010420;
      rPreFact@1100244002 : Record 7010415;
      rPar@1100244003 : Record 7010311;
      rLista@1100244004 : Record 7035384;
    BEGIN
      // reimprimir_prefactura
      //
      // AJS --> Solicita del usuario que prefactura desea reimprimir y en funcion del tipo
      //         de facturacion se llama al informe definido en parametros.
      //

      // AJF 07/01/09
      // Evito borrar el registro, ya que ahora tiene datos permanentes.
      IF rCond.GET(USERID) THEN
        rCond.LimpiaRegistro
      ELSE BEGIN
        rCond.INIT;
        rCond.Usuario := USERID;
        rCond.INSERT;
      END;

      rCond."N§ Prefactura" := prCI."N§ Prefactura";
      rCond.MODIFY;

      rCond.FILTERGROUP(2);
      rCond.SETRANGE(Usuario, USERID);
      rCond.FILTERGROUP(0);

      COMMIT;

      IF FORM.RUNMODAL(7035252, rCond) <> ACTION::OK THEN
        EXIT;
      rCond.GET(USERID);
      IF rCond."N§ Prefactura" = '' THEN
        EXIT;
      rPreFact.GET(rCond."N§ Prefactura");
      IF rPreFact.Facturada THEN
        ERROR(pre_ya_facturada2);
      IF rPreFact.Desactivada THEN
        ERROR(pre_desactivada);
      rPreFact.SETRECFILTER;
      rPreFact.Imprimir        := rPreFact.Imprimir::Prefactura;
      rPreFact."Imprime Mail"  := FALSE;
      rPreFact.MODIFY;
      rPar.FINDFIRST;
      COMMIT;
      CASE rPreFact."Tipo prefactura" OF
        rPreFact."Tipo prefactura"::"Sin resumen",
        rPreFact."Tipo prefactura"::"Resumen x Referencia":
        BEGIN
          rPar.TESTFIELD("Prefactura Sin resumen");
          rLista.RESET; rLista.INIT;
          IF rLista.GET( rPar."Prefactura Sin resumen") THEN BEGIN
            REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rPreFact);
          END;
        END;
        rPreFact."Tipo prefactura"::"Resumen x Codigo":
        BEGIN
          rPar.TESTFIELD("Prefactura Resumen-Codigo");
          rLista.RESET; rLista.INIT;
          IF rLista.GET(rPar."Prefactura Resumen-Codigo") THEN BEGIN
            REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rPreFact);
          END;
        END;
        rPreFact."Tipo prefactura"::"Resumen x Zona":
        BEGIN
          rPar.TESTFIELD("Prefactura Resumen-Zona");
          rLista.RESET; rLista.INIT;
          IF rLista.GET(rPar."Prefactura Resumen-Zona") THEN BEGIN
            REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rPreFact);
          END;
        END;
        rPreFact."Tipo prefactura"::"Resumen x Vuelo":
        BEGIN
          rPar.TESTFIELD("Prefactura Resumen-Vuelo");
          rLista.RESET; rLista.INIT;
          IF rLista.GET( rPar."Prefactura Resumen-Vuelo") THEN BEGIN
            REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rPreFact);
          END;
        END;
        rPreFact."Tipo prefactura"::"Resumen x Dia-Codigo":
        BEGIN
          rPar.TESTFIELD("Prefactura Resumen Dia-Codigo");
          rLista.RESET; rLista.INIT;
          IF rLista.GET(rPar."Prefactura Resumen Dia-Codigo") THEN BEGIN
            REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rPreFact);
          END;
        END;
        rPreFact."Tipo prefactura"::"Resumen x Zona-Detalle":
        BEGIN
          rPar.TESTFIELD("Prefactura Zona-Detalle");
          rLista.RESET; rLista.INIT;
          IF rLista.GET(rPar."Prefactura Zona-Detalle") THEN BEGIN
            REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rPreFact);
          END;
        END;
        rPreFact."Tipo prefactura"::"Resumen x Zona Dia-Codigo":
        BEGIN
          rPar.TESTFIELD("Prefactura Zona-Dia-Codigo");
          rLista.RESET; rLista.INIT;
          IF rLista.GET(rPar."Prefactura Zona-Dia-Codigo") THEN BEGIN
            REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rPreFact);
          END;
        END;
        rPreFact."Tipo prefactura"::"Texto alternativo":
        BEGIN
          rPar.TESTFIELD("Prefactura Texto alternativo");
          rLista.RESET; rLista.INIT;
          IF rLista.GET(rPar."Prefactura Texto alternativo") THEN BEGIN
            REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rPreFact);
          END;
        END;
      END;
    END;

    PROCEDURE reimprimir_factura@16(prCI@1100244000 : Record 7010414;pwPorCorreo@1100244002 : Boolean);
    VAR
      rCond@1100244001 : Record 7010420;
    BEGIN
      // reimprimir_factura
      //
      // AJS --> Caso de que la factura no este registrada se utilizaran los reports de facturas, sino
      //         se utilizaran los de historico factura.
      //

      // AJS 12.03.2004
      // A¤adido nuevo parametro para indicar si se imprime para enviar por correo o no

      IF NOT pwPorCorreo THEN BEGIN

        // AJF 07/01/09
        // Evito borrar el registro, ya que ahora tiene datos permanentes.
        IF rCond.GET(USERID) THEN
          rCond.LimpiaRegistro
        ELSE BEGIN
          rCond.INIT;
          rCond.Usuario := USERID;
          rCond.INSERT;
        END;

        rCond."N§ Factura" := prCI."N§ Factura";
        rCond.MODIFY;

        rCond.FILTERGROUP(2);
        rCond.SETRANGE(Usuario, USERID);
        rCond.FILTERGROUP(0);
        COMMIT;

        IF FORM.RUNMODAL(7035251, rCond) <> ACTION::OK THEN
          EXIT;
        rCond.GET(USERID);
      END
      ELSE BEGIN
        CLEAR(rCond);
        rCond."N§ Factura" := prCI."N§ Factura";
      END;

      rPar.GET;  // Seg£n la empresa real se imprimir  de una manera u otra
      CASE rPar."Empresa Real" OF
        rPar."Empresa Real"::TRN,rPar."Empresa Real"::UEX, rPar."Empresa Real"::CNT: reimprimir_factura2(rCond."N§ Factura", pwPorCorreo);
        rPar."Empresa Real"::SJO: reimprimir_factura2(rCond."N§ Factura", pwPorCorreo);
        ELSE
          reimprimir_factura1(rCond."N§ Factura", pwPorCorreo);
      END;
    END;

    PROCEDURE reimprimir_factura1@1100244000(pwNoFact@1100244000 : Code[20];pwPorCorreo@1100244001 : Boolean);
    VAR
      rLista@1100244003 : Record 7035384;
      rFra@1100244004 : Record 36;
      rHistFra@1100244005 : Record 112;
      rPreFact@1100244006 : Record 7010415;
      w_registrada@1100244007 : Boolean;
    BEGIN
      // reimprimir_factura1
      //
      // AJS --> Caso de que la factura no este registrada se utilizaran los reports de facturas, sino
      //         se utilizaran los de historico factura.
      // JPT  Listados Basados en las Cabecera de factura y factura registrada

      IF pwNoFact = '' THEN
        EXIT;
      // Busca la factura, primero no registrada y despues en registradas
      //
      w_registrada := FALSE;

      //IF NOT rFra.GET(rFra."Tipo documento"::Factura, rCond."N§ Factura") THEN BEGIN
      rFra.SETRANGE (rFra."Document Type" ,rFra."Document Type"::Invoice ,rFra."Document Type"::"Credit Memo");
      rFra.SETRANGE (rFra."No." , pwNoFact);
      IF NOT rFra.FINDFIRST THEN BEGIN
        IF NOT rHistFra.GET(pwNoFact) THEN
          EXIT
        ELSE BEGIN
          w_registrada := TRUE;
          rHistFra.SETRANGE("No.", rHistFra."No.");
        END;
      END
      ELSE BEGIN
        rFra.SETRANGE("Document Type", rFra."Document Type");
        rFra.SETRANGE("No."            , rFra."No.");
      END;
      // Buscamos la prefactura que corresponde a la factura
      //
      rPreFact.RESET; rPreFact.INIT;
      rPreFact.SETRANGE("N§ Factura", pwNoFact);
      rPreFact.FINDFIRST;

      rPreFact."Imprime Mail"  := pwPorCorreo;
      rPreFact.MODIFY;
      COMMIT;

      rPar.FINDFIRST;
      CASE rPreFact."Tipo factura" OF
        rPreFact."Tipo factura"::"Sin resumen",
        rPreFact."Tipo factura"::"Resumen x Referencia":
        BEGIN
          IF w_registrada THEN BEGIN
            rPar.TESTFIELD("Factura sin resumen registrada");
            rLista.RESET; rLista.INIT;
            IF rLista.GET(rPar."Factura sin resumen registrada") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rHistFra)
          END
          ELSE BEGIN
            rPar.TESTFIELD("Factura sin resumen");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura sin resumen") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rFra);
          END;
        END;
        rPreFact."Tipo factura"::"Resumen x Codigo":
        BEGIN
          IF w_registrada THEN BEGIN
            rPar.TESTFIELD("Factura Resumen-Codigo regis");
            rLista.RESET; rLista.INIT;
            IF rLista.GET(rPar."Factura Resumen-Codigo regis") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rHistFra)
          END
          ELSE BEGIN
            rPar.TESTFIELD("Factura Resumen-Codigo");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Resumen-Codigo") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rFra);
          END;
        END;
        rPreFact."Tipo factura"::"Resumen x Zona":
        BEGIN
          IF w_registrada THEN BEGIN
            rPar.TESTFIELD("Factura Resumen-Zona registrad");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Resumen-Zona registrad") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rHistFra)
          END
          ELSE BEGIN
            rPar.TESTFIELD("Factura Resumen-Zona");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Resumen-Zona") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rFra);
          END;
        END;
        rPreFact."Tipo factura"::"Resumen x Vuelo":
        BEGIN
          IF w_registrada THEN BEGIN
            rPar.TESTFIELD("Factura Resumen-Vuelo registra");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Resumen-Vuelo registra") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rHistFra)
          END
          ELSE BEGIN
            rPar.TESTFIELD("Factura Resumen-Vuelo");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Resumen-Vuelo") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rFra);
          END;
        END;
        rPreFact."Tipo factura"::"Resumen x Dia-Codigo":
        BEGIN
          IF w_registrada THEN BEGIN
            rPar.TESTFIELD("Factura Resumen Dia-Codigo reg");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Resumen Dia-Codigo reg") THEN
              REPORT.RUNMODAL(rLista."Id. Informe",TRUE, TRUE, rHistFra)
          END
          ELSE BEGIN
            rPar.TESTFIELD("Factura Resumen Dia-Codigo");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Resumen Dia-Codigo") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rFra);
          END;
        END;
        rPreFact."Tipo factura"::"Resumen x Zona-Detalle":
        BEGIN
          IF w_registrada THEN BEGIN
            rPar.TESTFIELD("Factura Zona-Detalle registra");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Zona-Detalle registra") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rHistFra)
          END
          ELSE BEGIN
            rPar.TESTFIELD("Factura Zona-Detalle");
            rLista.RESET; rLista.INIT;
            IF rLista.GET(rPar."Factura Zona-Detalle") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rFra);
          END;
        END;
        rPreFact."Tipo factura"::"Resumen x Zona Dia-Codigo":
        BEGIN
          IF w_registrada THEN BEGIN
            rPar.TESTFIELD("Fra. Zona-Dia-Codigo regis");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Fra. Zona-Dia-Codigo regis") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rHistFra)
          END
          ELSE BEGIN
            rPar.TESTFIELD("Factura Zona-Dia-Codigo");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Zona-Dia-Codigo") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rFra);
          END;
        END;
        rPreFact."Tipo factura"::"Texto alternativo":
        BEGIN
          IF w_registrada THEN BEGIN
            rPar.TESTFIELD("Factura Texto alternativo reg");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Texto alternativo reg") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rHistFra)
          END
          ELSE BEGIN
            rPar.TESTFIELD("Factura Texto alternativo");
            rLista.RESET; rLista.INIT;
            IF rLista.GET( rPar."Factura Texto alternativo") THEN
              REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rFra);
          END;
        END;
      END;
    END;

    PROCEDURE reimprimir_factura2@1100244004(pwNoFact@1100244000 : Code[20];pwPorCorreo@1100244004 : Boolean);
    VAR
      lwNListado@1100244001 : Integer;
      rPreFact@1100244002 : Record 7010415;
      rLista@1100244003 : Record 7035384;
    BEGIN
      // reimprimir_factura2
      // Listados Basados en la prefactura

      IF pwNoFact = '' THEN
        EXIT;

      rPreFact.RESET;
      rPreFact.INIT;
      rPreFact.SETCURRENTKEY("N§ Factura");
      rPreFact.SETRANGE("N§ Factura", pwNoFact);
      IF rPreFact.FINDFIRST THEN BEGIN
        rPreFact.MODIFYALL(Imprimir      , rPreFact.Imprimir::Factura);
        rPreFact.MODIFYALL("Imprime Mail", pwPorCorreo);
        COMMIT;
        CASE rPreFact."Tipo factura" OF
          rPreFact."Tipo factura"::"Sin resumen",
          rPreFact."Tipo factura"::"Resumen x Referencia": BEGIN
            rPar.TESTFIELD("Factura sin resumen");
            lwNListado := rPar."Factura sin resumen";
          END;

          rPreFact."Tipo factura"::"Resumen x Codigo": BEGIN
            rPar.TESTFIELD("Factura Resumen-Codigo");
            lwNListado := rPar."Factura Resumen-Codigo";
          END;

          rPreFact."Tipo factura"::"Resumen x Zona": BEGIN
            rPar.TESTFIELD("Factura Resumen-Zona");
            lwNListado := rPar."Factura Resumen-Zona";
          END;

          rPreFact."Tipo factura"::"Resumen x Vuelo": BEGIN
            rPar.TESTFIELD("Factura Resumen-Vuelo");
            lwNListado := rPar."Factura Resumen-Vuelo";
          END;

          rPreFact."Tipo factura"::"Resumen x Dia-Codigo": BEGIN
            rPar.TESTFIELD("Factura Resumen Dia-Codigo");
            lwNListado := rPar."Factura Resumen Dia-Codigo";
          END;

          rPreFact."Tipo factura"::"Resumen x Zona-Detalle": BEGIN
            rPar.TESTFIELD("Factura Zona-Detalle");
            lwNListado := rPar."Factura Zona-Detalle";
          END;

          rPreFact."Tipo factura"::"Resumen x Zona Dia-Codigo": BEGIN
            rPar.TESTFIELD("Factura Zona-Dia-Codigo");
            lwNListado := rPar."Factura Zona-Dia-Codigo";
          END;

          rPreFact."Tipo factura"::"Texto alternativo": BEGIN
            rPar.TESTFIELD("Factura Texto alternativo");
            lwNListado := rPar."Factura Texto alternativo";
          END;
        END;

        CLEAR(rLista);
        IF pwPorCorreo THEN BEGIN
          IF rLista.GET(lwNListado) THEN
            REPORT.RUNMODAL(rLista."Id. Informe", FALSE, FALSE, rPreFact);
        END
        ELSE BEGIN
          IF rLista.GET(lwNListado) THEN
            REPORT.RUNMODAL(rLista."Id. Informe", TRUE, TRUE, rPreFact);
        END;
      END;
    END;

    PROCEDURE BuscaNoReport@1103350000(VAR prPreFact@1103350000 : Record 7010415;pwImp@1103350002 : 'Prefactura,Factura') : Integer;
    VAR
      lwNListado@1103350003 : Integer;
      lrLista@1103350001 : Record 2000000001;
    BEGIN
      // BuscaNoReport
      // Devuelve el Numero de report que le corresponde a la factura
      // En principio solo facturas
      rPar.FINDFIRST;
      CLEAR(lwNListado);

      CASE pwImp OF
        pwImp::Prefactura : BEGIN

          CASE prPreFact."Tipo prefactura" OF
            prPreFact."Tipo prefactura"::"Sin resumen",
            prPreFact."Tipo prefactura"::"Resumen x Referencia": BEGIN
              rPar.TESTFIELD("Prefactura Sin resumen");
              lwNListado := rPar."Prefactura Sin resumen";
            END;

            prPreFact."Tipo prefactura"::"Resumen x Codigo": BEGIN
              rPar.TESTFIELD("Prefactura Resumen-Codigo");
              lwNListado := rPar."Prefactura Resumen-Codigo";
            END;

            prPreFact."Tipo prefactura"::"Resumen x Zona": BEGIN
              rPar.TESTFIELD("Prefactura Resumen-Zona");
              lwNListado := rPar."Prefactura Resumen-Zona";
            END;

            prPreFact."Tipo prefactura"::"Resumen x Vuelo": BEGIN
              rPar.TESTFIELD("Prefactura Resumen-Vuelo");
              lwNListado := rPar."Prefactura Resumen-Vuelo";
            END;

            prPreFact."Tipo prefactura"::"Resumen x Dia-Codigo": BEGIN
              rPar.TESTFIELD("Prefactura Resumen Dia-Codigo");
              lwNListado := rPar."Prefactura Resumen Dia-Codigo";
            END;

            prPreFact."Tipo prefactura"::"Resumen x Zona-Detalle": BEGIN
              rPar.TESTFIELD("Prefactura Zona-Detalle");
              lwNListado := rPar."Prefactura Zona-Detalle";
            END;

            prPreFact."Tipo prefactura"::"Resumen x Zona Dia-Codigo": BEGIN
              rPar.TESTFIELD("Prefactura Zona-Dia-Codigo");
              lwNListado := rPar."Prefactura Zona-Dia-Codigo";
            END;

            prPreFact."Tipo prefactura"::"Texto alternativo": BEGIN
              rPar.TESTFIELD("Prefactura Texto alternativo");
              lwNListado := rPar."Prefactura Texto alternativo";
            END;
          END;
        END;

        pwImp::Factura : BEGIN

          CASE prPreFact."Tipo factura" OF
            prPreFact."Tipo factura"::"Sin resumen",
            prPreFact."Tipo factura"::"Resumen x Referencia": BEGIN
              rPar.TESTFIELD("Factura sin resumen");
              lwNListado := rPar."Factura sin resumen";
            END;

            prPreFact."Tipo factura"::"Resumen x Codigo": BEGIN
              rPar.TESTFIELD("Factura Resumen-Codigo");
              lwNListado := rPar."Factura Resumen-Codigo";
            END;

            prPreFact."Tipo factura"::"Resumen x Zona": BEGIN
              rPar.TESTFIELD("Factura Resumen-Zona");
              lwNListado := rPar."Factura Resumen-Zona";
            END;

            prPreFact."Tipo factura"::"Resumen x Vuelo": BEGIN
              rPar.TESTFIELD("Factura Resumen-Vuelo");
              lwNListado := rPar."Factura Resumen-Vuelo";
            END;

            prPreFact."Tipo factura"::"Resumen x Dia-Codigo": BEGIN
              rPar.TESTFIELD("Factura Resumen Dia-Codigo");
              lwNListado := rPar."Factura Resumen Dia-Codigo";
            END;

            prPreFact."Tipo factura"::"Resumen x Zona-Detalle": BEGIN
              rPar.TESTFIELD("Factura Zona-Detalle");
              lwNListado := rPar."Factura Zona-Detalle";
            END;

            prPreFact."Tipo factura"::"Resumen x Zona Dia-Codigo": BEGIN
              rPar.TESTFIELD("Factura Zona-Dia-Codigo");
              lwNListado := rPar."Factura Zona-Dia-Codigo";
            END;

            prPreFact."Tipo factura"::"Texto alternativo": BEGIN
              rPar.TESTFIELD("Factura Texto alternativo");
              lwNListado := rPar."Factura Texto alternativo";
            END;
          END;
        END;
      END;

      CLEAR(lrLista);
      IF lrLista.GET(lrLista.Type::Report, '', lwNListado) THEN //+$004
        EXIT(lrLista.ID);
    END;

    PROCEDURE crear_prevision_coste@26(prProdCoste@1100244000 : Record 7035393;VAR pw_ultimo_asiento@1100244002 : Integer;VAR pw_ultima_linea@1100244003 : Integer;pw_num_documento@1100244004 : Code[20];pw_importe@1100244005 : Decimal;VAR prProdCosteTMP@1000000000 : TEMPORARY Record 7035393);
    VAR
      rPar@1100244006 : Record 7010311;
      rProv@1100244007 : Record 23;
      rDetAsi@1000000001 : Record 7010436;
      rGrup@1100244008 : Record 93;
      cVal@1100244009 : Codeunit 7010320;
      w_opcion@1100244010 : 'Debe,Haber';
      w_tipo_asiento@1100244011 : 'Normal Ingreso,Normal Coste,Regul Ingreso,Regul Coste,Ajuste Ingreso,Ajuste Coste';
    BEGIN
      // crear_prevision_coste
      //
      // AJS -- > Se encarga de crear los asientos de prevision de coste totalizada.
      //
      rPar.FINDFIRST;

      busca_proveedor(rProv, rGrup, prProdCoste.Proveedor);
      pw_ultimo_asiento := pw_ultimo_asiento + 1;
      pw_ultima_linea   := pw_ultima_linea + 1000;

      cVal.linea_prevision(pw_ultima_linea, pw_ultimo_asiento, prProdCoste.Touroperador, rPar."Cuenta Compras",
                           prProdCoste.Fecha, pw_num_documento, rProv.Name, w_opcion::Debe, pw_importe, rPar,
                           rPar."Seccion Previsiones coste", w_tipo_asiento::"Normal Coste", prProdCoste."Tipo servicio",
                           prProdCoste.Garaje, prProdCoste."N§ Parte", prProdCoste.Proveedor);
      // < $002 GEneramos detalles de asiento
      IF prProdCosteTMP.FINDFIRST THEN
      BEGIN
        REPEAT
          CLEAR(rDetAsi);
          rDetAsi.INIT;
          rDetAsi.Parte := prProdCosteTMP."N§ Parte";
          rDetAsi."Linea diario" := pw_ultima_linea;
          rDetAsi."Tipo linea" := rDetAsi."Tipo linea"::Coste;
          rDetAsi."Tipo asiento" := rDetAsi."Tipo asiento"::Creacion;
          rDetAsi.Importe := prProdCosteTMP."Importe sin impuesto DL";
          rDetAsi.INSERT(TRUE);
        UNTIL prProdCosteTMP.NEXT = 0;
      END;
      // $002 >

      pw_ultima_linea := pw_ultima_linea + 1000;
      cVal.linea_prevision(pw_ultima_linea, pw_ultimo_asiento, prProdCoste.Touroperador, rGrup."Cta facturas pdtes recibir",
                           prProdCoste.Fecha, pw_num_documento, rProv.Name, w_opcion::Haber, pw_importe, rPar,
                           rPar."Seccion Previsiones coste", w_tipo_asiento::"Normal Coste", prProdCoste."Tipo servicio",
                           prProdCoste.Garaje, prProdCoste."N§ Parte", prProdCoste.Proveedor);
    END;

    PROCEDURE crear_prevision_ingreso@27(prProdIng@1100244000 : Record 7035392;VAR pw_ultimo_asiento@1100244002 : Integer;VAR pw_ultima_linea@1100244003 : Integer;pw_num_documento@1100244004 : Code[20];pw_importe@1100244005 : Decimal;VAR prProdIngTMP@1000000000 : TEMPORARY Record 7035392);
    VAR
      rPar@1100244006 : Record 7010311;
      rCli@1100244007 : Record 18;
      rGrup@1100244008 : Record 92;
      rDetAsi@1000000001 : Record 7010436;
      cVal@1100244009 : Codeunit 7010320;
      w_opcion@1100244010 : 'Debe,Haber';
      w_tipo_asiento@1100244011 : 'Normal Ingreso,Normal Coste,Regul Ingreso,Regul Coste,Ajuste Ingreso,Ajuste Coste';
    BEGIN
      // crear_prevision_ingreso
      //
      // AJS --> Se encarga de crear los asientos de prevision de ingreso totalizada
      //
      rPar.FINDFIRST;

      pw_ultima_linea   := pw_ultima_linea + 1000;
      pw_ultimo_asiento := pw_ultimo_asiento + 1;
      busca_cliente(rCli, rGrup, prProdIng."Cliente Operativo");

      cVal.linea_prevision(pw_ultima_linea, pw_ultimo_asiento, prProdIng.Touroperador, rGrup."Cta facturas pdtes enviar",
                           prProdIng.Fecha, pw_num_documento, rCli.Name, w_opcion::Debe, pw_importe, rPar,
                           rPar."Seccion Previsiones ingreso", w_tipo_asiento::"Normal Ingreso", prProdIng."Tipo servicio",
                           prProdIng.Garaje, prProdIng."N§ Parte", prProdIng."Cliente Operativo");
      // < $002 GEneramos detalles de asiento
      IF prProdIngTMP.FINDFIRST THEN
      BEGIN
        REPEAT
          CLEAR(rDetAsi);
          rDetAsi.INIT;
          rDetAsi.Parte := prProdIngTMP."N§ Parte";
          rDetAsi."Linea diario" := pw_ultima_linea;
          rDetAsi."Tipo linea" := rDetAsi."Tipo linea"::Ingreso;
          rDetAsi."Tipo asiento" := rDetAsi."Tipo asiento"::Creacion;
          rDetAsi.Importe := prProdIngTMP."Importe sin impuesto DL";
          rDetAsi.INSERT(TRUE);
        UNTIL prProdIngTMP.NEXT = 0;
      END;
      // $002 >

      pw_ultima_linea := pw_ultima_linea + 1000;
      cVal.linea_prevision(pw_ultima_linea, pw_ultimo_asiento, prProdIng.Touroperador, rPar."Cuenta Ventas",
                           prProdIng.Fecha, pw_num_documento, rCli.Name, w_opcion::Haber, pw_importe, rPar,
                           rPar."Seccion Previsiones ingreso", w_tipo_asiento::"Normal Ingreso", prProdIng."Tipo servicio",
                           prProdIng.Garaje, prProdIng."N§ Parte", prProdIng."Cliente Operativo");
    END;

    PROCEDURE buscar_en_partes@17(prParte@1100244000 : Record 7010360);
    VAR
      rCond@1100244001 : Record 7010420;
      rParte@1100244002 : Record 7010360;
      rSerPar@1100244003 : Record 7010359;
      iFicCond@1100244004 : Form 7035250;
      w_hora_desde@1100244005 : Time;
      w_hora_hasta@1100244006 : Time;
      w_hora@1100244007 : Time;
      w_parte@1100244008 : Code[10];
      ventana@1100244009 : Dialog;
    BEGIN
      // buscar_en_partes
      //
      // AJS --> Localizar un conductor y vehiculo a partir de Hora, Pto. de recogida, Tipo servicio,
      //         Codigo servicio, cliente y touroperador
      //

      // AJF 07/01/09
      // Evito borrar el registro, ya que ahora tiene datos permanentes.
      IF rCond.GET(USERID) THEN
        rCond.LimpiaRegistro
      ELSE
      BEGIN
        rCond.INIT;
        rCond.Usuario := USERID;
        rCond.INSERT;
      END;

      rCond."Fecha Factura" := prParte.Fecha;
      rCond.MODIFY;

      COMMIT;
      rCond.SETRECFILTER;

      CLEAR(iFicCond);
      iFicCond.SETTABLEVIEW(rCond);
      IF iFicCond.RUNMODAL <> ACTION::OK THEN
        EXIT;
      rCond.GET(USERID);
      IF rCond."Punto recogida" = '' THEN
        ERROR(no_punto);

      rSerPar.RESET; rSerPar.INIT;
      rSerPar.SETCURRENTKEY("N§ Parte",
                            "Punto recogida",
                            "Hora recogida");

      rParte.RESET; rParte.INIT;
      rParte.SETCURRENTKEY(       Fecha,
                         "Dia siguiente",
                           "Hora inicio");
      rParte.SETRANGE(Fecha, rCond."Fecha Factura");
      IF rCond."Tipo servicio" <> '' THEN
        rParte.SETRANGE("Tipo Servicio", rCond."Tipo servicio");
      IF rCond."Codigo servicio" <> '' THEN
        rParte.SETRANGE("Codigo Servicio", rCond."Codigo servicio");
      IF rCond.Cliente <> '' THEN
        rParte.SETRANGE(Cliente, rCond.Cliente);
      IF rParte.FINDSET THEN
      BEGIN
        w_parte := '';
        REPEAT
          rSerPar.SETRANGE("N§ Parte"      , rParte."N§ Parte");
          rSerPar.SETRANGE("Punto recogida", rCond."Punto recogida");
          IF rCond.Touroperador <> '' THEN
            rSerPar.SETRANGE(Touroperador, rCond.Touroperador);
          IF rCond.Hora <> 0T THEN
          BEGIN
            w_hora_desde := rCond.Hora - 7200000;  // Restar dos horas de margen
            w_hora_hasta := rCond.Hora + 7200000;  // Sumar dos horas de margen
            rSerPar.SETRANGE("Hora recogida", w_hora_desde, w_hora_hasta);
          END;
          IF rSerPar.FINDFIRST THEN
          BEGIN
            w_parte := rSerPar."N§ Parte";
            w_hora  := rSerPar."Hora recogida";
          END;
        UNTIL (rParte.NEXT = 0) OR (w_parte <> '');
      END;

      IF (w_parte = '') AND (rCond.Hora <> 0T) THEN
      BEGIN
        rSerPar.RESET; rSerPar.INIT;
        rSerPar.SETCURRENTKEY("N§ Parte",
                              "Punto recogida",
                              "Hora recogida");
        IF rParte.FINDSET THEN
        BEGIN
          REPEAT
            rSerPar.SETRANGE("N§ Parte"      , rParte."N§ Parte");
            rSerPar.SETRANGE("Punto recogida", rCond."Punto recogida");
            IF rCond.Touroperador <> '' THEN
              rSerPar.SETRANGE(Touroperador, rCond.Touroperador);
            IF rSerPar.FINDFIRST THEN
            BEGIN
              w_parte := rSerPar."N§ Parte";
              w_hora  := rSerPar."Hora recogida";
            END;
          UNTIL (rParte.NEXT = 0) OR (w_parte <> '');
        END;
      END;
      IF w_parte = '' THEN
        EXIT;
      rParte.GET(w_parte);

      ventana.OPEN(Text50003 +
                   '\' +
                   Text50004 +
                   Text50005 +
                   Text50006 +
                   '\' +
                   Text50007);
      ventana.UPDATE(1, rParte."N§ Parte");
      ventana.UPDATE(2, rParte.Conductor);
      ventana.UPDATE(3, rParte."N§ Vehiculo");
      ventana.UPDATE(4, w_hora);
      SLEEP(6000);
      ventana.CLOSE;
    END;

    PROCEDURE calcular_dia@18(prParte@1100244000 : Record 7010360);
    VAR
      rParte@1100244001 : Record 7010360;
    BEGIN
      // calcular_dia
      //
      // AJS --> Calculo masivo de los servicios de un dia.
      //
      rParte.RESET; rParte.INIT;
      rParte.SETCURRENTKEY(Fecha);
      rParte.SETRANGE(Fecha     , prParte.Fecha);
      rParte.SETRANGE(Confirmado, FALSE);
      IF rParte.FINDSET(TRUE) THEN BEGIN
        REPEAT
          rParte."Tipo Calculo" := prParte."Tipo Calculo"::Margen;
          rParte.MODIFY(TRUE);
          COMMIT;
          // JPT 27/12/05 Cambio a las nuevas funciones de calculo
          // cCal.calculo_parte(rParte, FALSE, TRUE, TRUE,FALSE); // No queremos visualizar los resultados
          cCalR.CalculoParte(rParte, FALSE, TRUE, TRUE,FALSE,TRUE); // No queremos visualizar los resultados
        UNTIL rParte.NEXT = 0;
      END;
    END;

    PROCEDURE Deshacer_Varias_Prefacturas@23(VAR prProdIng@1100244000 : Record 7035392);
    VAR
      lrPrefact@1100244002 : Record 7010415;
    BEGIN
      // Deshacer_Varias_Prefacturas
      // JPT -> Deshace las prefacturas no facturadas relacionadas con las l¡neas Coste-Ingreso
      // pasadas como parametro SIN GENERAR NINGUN TIPO DE AVISO


      IF prProdIng.FINDSET THEN BEGIN
        REPEAT
          IF prProdIng."N§ Prefactura" <> '' THEN BEGIN
            IF lrPrefact.GET (prProdIng."N§ Prefactura") THEN BEGIN
              IF lrPrefact.Facturada THEN
                ERROR(pre_ya_facturada);

              IF NOT lrPrefact.Desactivada THEN
                lrPrefact.DeshacerPrefactura(FALSE); // LLamamos a la rutina con parametro para que no pida confirmacion
            END;
          END;
        UNTIL prProdIng.NEXT = 0;
      END;
    END;

    PROCEDURE "totalizar_importe_TTOO/Parte"@20(VAR prTP@1100244000 : Record 7010365);
    VAR
      lrDiv@1100244001 : Record 4;
      lrTP2@1100244002 : Record 7010365;
      w_importe@1100244003 : Decimal;
      w_importe_marcadas@1100244004 : Decimal;
      ventana@1100244005 : Dialog;
      texto1@1100244006 : TextConst 'ESP="El total  de las lineas filtradas es                "';
      texto2@1100244007 : TextConst 'ESP=El total de las lineas marcadas por %1';
      texto3@1100244008 : TextConst 'ESP="es           "';
      w_importe_DL@1100244009 : Decimal;
      w_importe_marcadas_DL@1100244010 : Decimal;
      texto4@1100244011 : TextConst 'ESP=El total  de las lineas filtradas en Divisa Local es';
      lwTexto@1100244012 : Text[55];
      lwIngreso@1103355001 : Decimal;
      lwIngresoDL@1103355000 : Decimal;
    BEGIN
      // totalizar_importe_TTOO/Parte
      //
      // JPT --> Totaliza las lineas de Touroperadores x Parte que vengan filtradas con el registro de parametro
      //         muestra en una ventana de dialogo el resultado del campo "Importe sin Impuesto DL".
      //
      w_importe := 0;
      w_importe_marcadas := 0;
      w_importe_DL := 0;
      w_importe_marcadas_DL := 0;

      lrTP2.RESET; lrTP2.INIT;
      lrTP2.COPY(prTP);
      IF lrTP2.FINDSET THEN BEGIN
        ventana.OPEN(                             texto1 + '#1########' + '\' +
                      STRSUBSTNO(texto2,USERID) + texto3 + '#3########' + '\' +
                                                  texto4 + '#4########' + '\' +
                      STRSUBSTNO(texto2,USERID) + texto3 + '#5########');

        CLEAR(lrDiv);
        IF lrDiv.GET(lrTP2."Cod. Divisa venta") THEN ;

        REPEAT
          lwIngresoDL := lrTP2.TotalIngresoDL;
          lwIngreso   := lrTP2.TotalIngreso;
          w_importe := w_importe + lwIngreso;
          w_importe_DL := w_importe_DL + lwIngresoDL;
          IF lrTP2.Marca = USERID THEN BEGIN
            w_importe_marcadas := w_importe_marcadas + lwIngreso;
            w_importe_marcadas_DL := w_importe_marcadas_DL + lwIngresoDL;

          END;
          ventana.UPDATE(1, ROUND(w_importe, lrDiv."Amount Rounding Precision"));
          ventana.UPDATE(3, ROUND(w_importe_marcadas, lrDiv."Amount Rounding Precision"));
          ventana.UPDATE(4, ROUND(w_importe_DL));
          ventana.UPDATE(5, ROUND(w_importe_marcadas_DL));

        UNTIL lrTP2.NEXT = 0;
      END;
      SLEEP(7000);
      ventana.CLOSE;
    END;

    PROCEDURE Unica_Divisa_Venta@21(prParte@1100244000 : Record 7010360) "es unica" : Boolean;
    VAR
      lrTTOOParte@1100244001 : Record 7010365;
      lwDivisa@1100244002 : Code[10];
    BEGIN
      // Unica_Divisa_Venta
      //
      // Comprueba que todos los touroperadores de las l¡neas de un parte operen con la misma divisa
      // De esta manera el campo calculado Ingreso en Partes podr  ocultarse en caso de que tengan distinta
      // divisa ya que el resultado no ser  correcto. Devuelve TRUE en caso de que coincidan

      lrTTOOParte.RESET;
      lrTTOOParte.SETRANGE("N§ Parte",prParte."N§ Parte");
      IF lrTTOOParte.FINDSET THEN BEGIN
        lwDivisa := lrTTOOParte."Cod. Divisa venta";
        REPEAT
          IF lwDivisa <> lrTTOOParte."Cod. Divisa venta" THEN
            EXIT(FALSE);
        UNTIL lrTTOOParte.NEXT = 0;
      END;
      EXIT(TRUE);
    END;

    PROCEDURE Unica_Divisa_Compra@29(prParte@1100244000 : Record 7010360) "es unica" : Boolean;
    VAR
      lrTTOOParte@1100244001 : Record 7010365;
      lwDivisa@1100244002 : Code[10];
    BEGIN
      // Unica_Divisa_Compra
      //
      // Comprueba que todos los proveedores de las l¡neas de un parte operen con la misma divisa
      // De esta manera el campo calculado Coste en Partes podr  ocultarse en caso de que tengan distinta
      // divisa ya que el resultado no ser  correcto. Devuelve TRUE en caso de que coincidan

      lrTTOOParte.RESET;
      lrTTOOParte.SETRANGE("N§ Parte",prParte."N§ Parte");
      IF lrTTOOParte.FINDSET THEN BEGIN
        lwDivisa := lrTTOOParte."Cod. Divisa compra";
        REPEAT
          IF lwDivisa <> lrTTOOParte."Cod. Divisa compra" THEN
            EXIT(FALSE);
        UNTIL lrTTOOParte.NEXT = 0;
      END;
      EXIT(TRUE);
    END;

    PROCEDURE busca_ultima_linea_CI@22(prCI@1100244000 : Record 7010414) : Decimal;
    VAR
      lrCI@1100244001 : Record 7010414;
    BEGIN
      // busca_ultima_linea_CI
      //
      lrCI.RESET;
      lrCI.SETRANGE("N§ Parte", prCI."N§ Parte");
      IF lrCI.FINDLAST THEN BEGIN
        IF lrCI."N§ Linea" < 99000000 THEN
          EXIT(99000000)
        ELSE
          EXIT(lrCI."N§ Linea");
      END
      ELSE
        EXIT(99000000);
    END;

    PROCEDURE deshacer_prefactura_coste@31(pwNumPref@1100244000 : Code[20]);
    VAR
      lrProdCoste@1100244001 : Record 7035393;
      lrPref@1100244002 : Record 7035348;
    BEGIN
      // deshacer_prefactura_coste
      //
      // Esta rutina se encarga de desmarcar las lineas de coste que esten dentro de la prefactura y borrar la prefactura

      lrProdCoste.RESET;
      lrProdCoste.SETCURRENTKEY("N§ Parte", "N§ Prefactura", "N§ Factura");
      lrProdCoste.SETRANGE("N§ Prefactura", pwNumPref);
      IF lrProdCoste.FINDFIRST THEN
        lrProdCoste.MODIFYALL("N§ Prefactura", '', TRUE);

      IF lrPref.GET(pwNumPref) THEN BEGIN
        lrPref.borra_prefactura;
        lrPref.DELETE;
      END;
    END;

    PROCEDURE SumarPre@1100244001(VAR prParte@1100244000 : Record 7010360);
    VAR
      lrPI@1100244001 : Record 7035392;
      lrPI2@1100244002 : Record 7035392;
    BEGIN
      // SumarPre
      // Only TRN
      // El fin de esta funci¢n es que si el "Precio por" es Precio Combinado y las lineas tiene el mismo precio
      // estas se sumaran.


      IF rPar."Empresa Real" <> rPar."Empresa Real"::TRN THEN
        EXIT;

      IF prParte."Ingreso Precios por" <> prParte."Ingreso Precios por"::"Zonas combinadas" THEN
        EXIT;

      lrPI.RESET;
      lrPI.SETCURRENTKEY("N§ Parte",Touroperador,"Tipo linea","Linea abono","Tipo elemento");
      lrPI.SETRANGE("N§ Parte"      , prParte."N§ Parte");
      lrPI.SETRANGE("Precio manual" , FALSE);
      lrPI.SETRANGE("Tipo linea"    , lrPI."Tipo linea"::Base);
      IF lrPI.FINDSET(TRUE) THEN BEGIN
        CLEAR(lrPI2);
        REPEAT
          IF lrPI."Tipo elemento" IN [rPar."Codigo Adulto",rPar."Codigo Ni¤o"] THEN BEGIN
            lrPI2.COPY(lrPI);
            lrPI2.SETRANGE(Touroperador   , lrPI.Touroperador);
            lrPI2.SETRANGE("Tipo elemento", lrPI."Tipo elemento");
            lrPI2.SETFILTER("N§ Linea"    ,'<>%1', lrPI."N§ Linea");
            IF lrPI2.FINDLAST THEN BEGIN
              REPEAT
                IF lrPI2."Precio Pax" = lrPI."Precio Pax" THEN BEGIN
                  lrPI.Pax                       += lrPI2.Pax;
                  lrPI."Pax Real"                += lrPI2."Pax Real";
                  lrPI.Importe                   += lrPI2.Importe;
                  lrPI."Importe DL"              += lrPI2."Importe DL";
                  lrPI."Importe sin impuesto"    += lrPI2."Importe sin impuesto";
                  lrPI."Importe sin impuesto DL" += lrPI2."Importe sin impuesto DL";
                  lrPI."Importe con impuesto"    += lrPI2."Importe con impuesto";
                  lrPI."Importe con impuesto DL" += lrPI2."Importe con impuesto DL";
                  lrPI."Importe sin original"    += lrPI2."Importe sin original";
                  lrPI."Importe con original"    += lrPI2."Importe con original";
                  lrPI."Pax Facturados"          += lrPI2."Pax Facturados";
                  lrPI."Pax Transportados"       += lrPI2."Pax Transportados";
                  lrPI.MODIFY;
                  lrPI2.DELETE;
                END;
              UNTIL lrPI2.NEXT(-1)=0
            END
          END;
        UNTIL lrPI.NEXT=0;
      END;
    END;

    PROCEDURE ModificaReferenciaParte@1100244002(VAR prParte@1100244000 : Record 7010360);
    VAR
      lrCond@1100244001 : Record 7010420;
      lrPI@1100244003 : Record 7035392;
      lrToPar@1100244004 : Record 7010365;
      fFicRef@1100244002 : Form 7035314;
    BEGIN
      // ModificaReferenciaParte
      //

      // Comprobar si este parte esta pendiente de facturar

      lrPI.RESET;
      lrPI.SETRANGE ("N§ Parte"  , prParte."N§ Parte");
      IF NOT lrPI.FINDFIRST THEN
        ERROR(Text12);

      // Llamamos a la ventana para solicitar la nueva referencia

      IF NOT lrCond.GET(USERID) THEN BEGIN
        lrCond.INIT;
        lrCond.Usuario := USERID;
        lrCond.INSERT;
      END;

      lrCond."N§ Parte"   := prParte."N§ Parte";
      lrCond.Cliente      := prParte.Cliente;
      lrCond.Touroperador := prParte."Touroperador principal";
      lrCond.Referencia   := prParte.Referencia;
      lrCond.MODIFY;

      lrCond.SETRECFILTER;
      COMMIT;

      CLEAR(fFicRef);
      fFicRef.SETTABLEVIEW(lrCond);
      IF fFicRef.RUNMODAL <> ACTION::OK THEN
        EXIT;
      fFicRef.GETRECORD(lrCond);

      // Pasar la referencia a las lineas de ingreso y a Touroperador x parte

      lrPI.RESET;
      lrPI.SETRANGE ("N§ Parte"  , prParte."N§ Parte");
      IF lrPI.FINDFIRST THEN
        lrPI.MODIFYALL(Referencia, lrCond.Referencia);

      // Modificar Touroperador x parte para poner la referencia en el campo Bono

      lrToPar.RESET;
      lrToPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF lrToPar.FINDFIRST THEN
        lrToPar.MODIFYALL(Referencia, lrCond.Referencia);

      // AJS 22.01.2007
      // En el caso de Ultramar estamos modificando el bono de excursiones en lugar del campo Referencia

      rPar.FINDFIRST;
      CASE rPar."Empresa Real" OF
        rPar."Empresa Real"::UEX:
        BEGIN
          // Modificar el parte

          prParte.VALIDATE("Num. Bono Excursiones", lrCond.Referencia);
          prParte.MODIFY;
        END
        ELSE BEGIN
      // Modificar el parte

          prParte.VALIDATE(Referencia, lrCond.Referencia);
          prParte.MODIFY;
        END;
      END;
    END;

    PROCEDURE ExportacionProvXML@1100244003(pwNo@1100244019 : Integer;pwTipoExportacion@1103355000 : 'Proveedor,Confirmados';VAR prParte@1103355001 : Record 7010360);
    VAR
      Nodo@1100244023 : ARRAY [10] OF Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";
      lrParte@1100244018 : Record 7010360;
      lrParte2@1103350000 : Record 7010360;
      lrHist@1100244017 : Record 7035353;
      lrLinPar@1100244016 : Record 7010359;
      lrVuelos@1100244015 : Record 7035335;
      lrSuplets@1100244014 : Record 7010363;
      lrProv@1100244021 : Record 23;
      lrTipSer@1103350002 : Record 7010319;
      lrExtras@1100253002 : Record 7010362;
      lfExpt@1100244013 : Form 7035376;
      lrConf@1100244012 : Record 7010371;
      lrInfEmp@1103350006 : Record 79;
      lcFunExp@1100244011 : Codeunit 7035324;
      lwNArc@1100244010 : Text[250];
      lwNomArch@1100244009 : Text[250];
      lwTexto@1100244008 : Text[250];
      lwTexto2@1100244007 : Text[250];
      lwVarios@1100244006 : Text[250];
      lwServ@1100244005 : Text[10];
      lwOk@1100244004 : Boolean;
      lwSubag@1100244003 : Code[10];
      lwCont@1100244002 : Integer;
      lwCont2@1100244020 : Integer;
      lwTotal@1100244001 : Integer;
      lwTTOO@1100244000 : Code[10];
      lwGaraje@1100244024 : Code[10];
      lwZonaT@1100244025 : Code[10];
      lwAsunto@1103350003 : Text[250];
      lwCuerpo@1103350004 : ARRAY [5] OF Text[250];
      lwArchivos@1103350005 : ARRAY [5] OF Text[250];
      lwCliente@1100253000 : Code[20];
      lwHost@1100253001 : Text[30];
      lwDec@1103355002 : Decimal;
    BEGIN
      // ExportacionProvXML

      // AJS 18.07.2006 ## DRF 06008
      // Incluidos dos nuevos parametros para indicar el tipo de exportacion (Proveedor,Confirmados) y un registro de partes
      // de trabajo para traer los filtros en caso de que sea de tipo confirmados

      rPar.FINDFIRST;

      lrProv.RESET;

      // Exportacion a XML plano de Reservas subcontratadas
      IF rPar."Empresa Real" = rPar."Empresa Real"::UEX THEN BEGIN
        rParUEX.FINDFIRST;
        rParUEX.TESTFIELD("Touroperador Thomson");
        rParUEX.TESTFIELD("TTOO TUI Exportacion Proveedor");
        rParUEX.TESTFIELD("TTOO THOMSON Export. Proveedor");
      END
      ELSE BEGIN
        rInfEmp.GET;
        rInfEmp.TESTFIELD("Cliente Exportacion");
        rParAux.FINDFIRST;
      END;


      lrLinPar.RESET;
      //lrLinPar.SETCURRENTKEY("N§ Parte","N§ Linea");

      lrLinPar.SETCURRENTKEY("N§ Parte", "Hora recogida");

      lrVuelos.RESET;
      lrSuplets.RESET;
      lrSuplets.SETCURRENTKEY("N§ Parte","N§ Linea");

      // AJS 18.07.2006 ## DRF 06008
      // Solo trabajamos con el historico en las exportaciones a proveedores

      IF pwTipoExportacion = pwTipoExportacion::Proveedor THEN BEGIN
        CLEAR(lrHist);
        CLEAR(lfExpt);
        IF pwNo <> 0 THEN BEGIN
          lrHist.GET(pwNo, lrHist."Tipo Exportacion"::"Servicios Proveedor");
          lfExpt.Editar(FALSE);
        END
        ELSE BEGIN
          lfExpt.Editar(TRUE);
          lrHist."Envio Mail" := rPar."Empresa Real" = rPar."Empresa Real"::UEX;
        END;

        lfExpt.SetDatos(lrHist."Fecha Desde",lrHist."Fecha Hasta",lrHist."N§",1,lrHist."Tipo Servicio",lrHist."Con Agregados",
                      lrHist.Proveedor,lrHist."Envio Mail");
        lfExpt.CAPTION:= Text0005;

        // Ense¤amos el formulario por primera vez para introducir fechas

        lfExpt.LOOKUPMODE(TRUE);

        IF NOT (lfExpt.RUNMODAL= ACTION::OK) THEN
          EXIT;

        lfExpt.GetDatos(lrHist."Fecha Desde",
                        lrHist."Fecha Hasta",
                        lrHist."Tipo Servicio",
                        lrHist."Con Agregados",
                        lrHist.Proveedor,
                        lrHist."Envio Mail");

        IF pwNo = 0 THEN BEGIN
          IF lrHist.Proveedor = '' THEN
            ERROR(Text0011);
          lrProv.GET(lrHist.Proveedor);
          lrProv.TESTFIELD("Ruta Exportacion");
        END;

        // Comprobamos fechas

        lrHist.TESTFIELD("Fecha Desde");
        lrHist.TESTFIELD("Fecha Hasta");
        IF lrHist."Fecha Hasta" < lrHist."Fecha Desde" THEN
          ERROR(Text0002);
      END;

      // AJS 18.07.2006 ## DRF 06008
      // Cuando la exportacion es de servicios confirmados, los filtros vienen puestos desde la ventana

      IF pwTipoExportacion = pwTipoExportacion::Confirmados THEN BEGIN
        lrParte.RESET;
        lrParte.COPY(prParte);
        pwNo := 99999;
      END
      ELSE BEGIN
        lrParte.RESET;
        lrParte.SETCURRENTKEY(Fecha, Proveedor, "Num Exportacion Prov");
        lrParte.SETFILTER("Num Exportacion Prov", '%1', pwNo);
        IF pwNo = 0 THEN BEGIN
          lrParte.SETRANGE(Proveedor , lrHist.Proveedor);
          lrParte.SETRANGE(Fecha     , lrHist."Fecha Desde", lrHist."Fecha Hasta");
          IF NOT lrHist."Con Agregados" THEN
            lrParte.SETRANGE("Vehiculo Agregado", FALSE);
        END;
      END;

      IF lrParte.FINDSET(TRUE) THEN BEGIN

        // AJS 18.07.2006 ## DRF 06008
        // La exportacion de servicios confirmados no trabaja solo con los partes de un proveedor

        IF pwTipoExportacion = pwTipoExportacion::Proveedor THEN BEGIN
          IF pwNo = 0 THEN BEGIN
            lrHist."Tipo Exportacion":=lrHist."Tipo Exportacion"::"Servicios Proveedor";
            lrHist.INSERT(TRUE);
            pwNo := lrHist."N§";
          END
          ELSE BEGIN
            lrParte.TESTFIELD(Proveedor);
            IF NOT lrProv.GET(lrParte.Proveedor) THEN
              CLEAR(lrProv);
          END;

          lrProv.TESTFIELD("Ruta Exportacion");
          IF lrProv."Ruta Exportacion"[STRLEN(lrProv."Ruta Exportacion")] <>'\' THEN
            lrProv."Ruta Exportacion" += '\';

          lwNArc := Text50008 + lcFunExp.Montafecha(TODAY) + Text50009;
          lwNomArch := lrProv."Ruta Exportacion" + lwNArc;

          lrHist."Nombre Archivo" := cImpTRN.Extractfilename(lwNomArch);
          lrHist.MODIFY;
        END
        ELSE BEGIN
          rParAux.FINDFIRST;
          rParAux.TESTFIELD("Directorio Archivos");
          IF rParAux."Directorio Archivos"[STRLEN(rParAux."Directorio Archivos")] <> '\' THEN
            rParAux."Directorio Archivos" += '\';

          lwNArc := Text50010 + lcFunExp.Montafecha(TODAY) + Text50009;
          lwNomArch := rParAux."Directorio Archivos" + lwNArc;
        END;

        lwTotal := lrParte.COUNTAPPROX;
        CLEAR(lwCont);
        wVentana.OPEN(Text0007);
        CLEAR(XML);
        CREATE(XML);

        // AJS 18.07.2006 ## DRF 06008
        // Indicaremos en el XML el tipo de exportacion que estamos realizando

        IF pwTipoExportacion = pwTipoExportacion::Proveedor THEN
          XML.loadXML := Text50011
        ELSE
          XML.loadXML := Text50012;

        //Nodo[1]:=XML.createElement(Text50013);
        //Nodo[1] := XML.documentElement;
        Nodo[1]:=XML.createNode(Text50014, Text50015, '');
        XML.appendChild(Nodo[1]);
        // AddElement(Nodo[1],Text50015,'','',Nodo[1]);
        CLEAR(lwCont2);
        REPEAT
          IF BuscaGaraje(lrParte, lrConf, TRUE) THEN BEGIN
            lrConf.TESTFIELD("Garaje/Emp");
            lrConf.TESTFIELD("Zona Trabajo");
          END;

          lrLinPar.SETRANGE("N§ Parte", lrParte."N§ Parte");
          lwOk := lrLinPar.FINDFIRST;

          // AJS 18.07.2006 ## DRF 06008
          // Filtro por tipo de servicio fijo en las exportaciones de tipo Proveedor

          IF (lrHist."Tipo Servicio" <> lrHist."Tipo Servicio"::Todos) AND
             (pwTipoExportacion = pwTipoExportacion::Proveedor) THEN BEGIN
            lrParte.TESTFIELD("Tipo Servicio");
            lrTipSer.GET(lrParte."Tipo Servicio");
            lwOk:= lwOk AND (lrTipSer."Tipo fijo" = lrHist."Tipo Servicio" - 1);
          END;

          IF lwOk THEN BEGIN
            lwCont += 1;
            AddElement(Nodo[1], STRSUBSTNO(Text50016, lwCont), '', '', Nodo[2]);
            AddAttribute(Nodo[2], Text50017, lrParte."N§ Parte");

            CLEAR(lwTexto);
            IF lrConf."Garaje/Emp" <> '' THEN
              lwGaraje:= lrConf."Garaje/Emp"
            ELSE
              lwGaraje:= lrParte.Garaje;

            AddAttribute(Nodo[2],Text50018,lwGaraje);

            lrLinPar.TESTFIELD(Touroperador);
            IF rPar."Empresa Real" = rPar."Empresa Real"::UEX THEN BEGIN
              lwCliente := rParUEX."Cliente Exportacion Proveedor";

              IF lrLinPar.Touroperador = rParUEX."Touroperador Thomson" THEN
                lwSubag := rParUEX."TTOO THOMSON Export. Proveedor"
              ELSE
                lwSubag := rParUEX."TTOO TUI Exportacion Proveedor";
            END
            ELSE BEGIN
              // AJS 28.04.2006
              // Exportamos el cliente real del servicio en lugar de exportar el parametro
              //lwCliente := rInfEmp."Cliente Exportacion";

              lwCliente := lrParte.Cliente;
              lwSubag   := lrLinPar.Touroperador;
            END;

            AddAttribute(Nodo[2], Text50019, lwCliente); // CLIENTE
            AddAttribute(Nodo[2], Text50020, lwSubag);
            AddAttribute(Nodo[2], Text50021, lrParte."Codigo Servicio");
            AddAttribute(Nodo[2], Text50022, FORMAT(lrParte.Fecha));
            AddAttribute(Nodo[2], Text50023 , lrParte.Guia);
            IF lrConf."Zona Trabajo" <> '' THEN
              lwZonaT := lrConf."Zona Trabajo"
            ELSE
              lwZonaT := lrParte."Zona trabajo";
            AddAttribute(Nodo[2], Text50024, lwZonaT);
            AddAttribute(Nodo[2], Text50025, FORMAT(lrParte."Hora inicio",0,Text50026));
            AddAttribute(Nodo[2], Text50027, FORMAT(lrParte."Dia siguiente"));

      //      AddAttribute(Nodo[2],Text50028, lrParte.nom_origen);
            // **
            // AddAttribute(Nodo[2],Text50028, RetornaPresentacion(lrParte, lrLinPar));
            AddAttribute(Nodo[2],Text50028,  lrParte.Presentacion);
            AddAttribute(Nodo[2],Text50029, lrParte.Observaciones);

            // AJS 08.11.2005
            // Incluir los campos Referencia y Letreros

            AddAttribute(Nodo[2], Text50030, lrParte.Referencia);
            AddAttribute(Nodo[2], Text50031  , lrParte.Letreros);
            AddAttribute(Nodo[2], Text50032, lrParte."Origen/Destino");

            // JPT 09/03/06
            // Incluimos los campos Conductor y Vehiculo

            IF NOT (rPar."Empresa Real" IN [rPar."Empresa Real"::UEX]) THEN BEGIN
              IF lrParte."Cod Conductor" <> '' THEN
                AddAttribute(Nodo[2], Text50033, lrParte."Cod Conductor");
              IF lrParte.Vehiculo <> '' THEN
                AddAttribute(Nodo[2], Text50034, lrParte.Vehiculo);
            END;

            // AJS 18.07.2006 ## DRF 06008
            // Si exportamos servicios confirmados hay que incluir el ingreso sin impuestos

            IF pwTipoExportacion = pwTipoExportacion::Confirmados THEN BEGIN
              AddAttribute(Nodo[2], Text50035, FORMAT(lrParte.TotalIngreso));
            END;

            // VUELOS

            lrVuelos.SETRANGE("N§Parte", lrParte."N§ Parte");
            IF lrVuelos.FINDSET THEN BEGIN
              AddElement(Nodo[2],Text50036, '', '', Nodo[3]);
              CLEAR(lwCont2);
              REPEAT
                lwCont2 +=1;
                AddElement(Nodo[3], STRSUBSTNO(Text50037, lwCont2), '', '', Nodo[4]);
                AddAttribute(Nodo[4], Text50038, lrVuelos."Referencia Vuelo");
                AddAttribute(Nodo[4], Text50039    , FORMAT(lrVuelos.Hora,0,Text50026));
                AddAttribute(Nodo[4], Text50040    , lrVuelos.IATA);
                AddAttribute(Nodo[4], Text50020    , lrVuelos."Codigo Touroperador");
                AddAttribute(Nodo[4], Text50041  , FORMAT(lrVuelos."E/S"));
                AddAttribute(Nodo[4], Text50022   , FORMAT(lrVuelos."Fecha Traslado"));
                AddAttribute(Nodo[4], Text50042, FORMAT(lrVuelos."Fecha Llegada Vuelo"));
              UNTIL lrVuelos.NEXT = 0;
            END;

            // LINEAS DE RECOGIDA

            lrLinPar.SETRANGE("N§ Parte", lrParte."N§ Parte");
            IF lrLinPar.FINDSET THEN BEGIN
              AddElement(Nodo[2],Text50043,'','',Nodo[3]);
              CLEAR(lwCont2);
              REPEAT
                lwCont2 +=1;
                AddElement(Nodo[3],STRSUBSTNO(Text50044,lwCont2),'','',Nodo[4]);
                AddAttribute(Nodo[4], Text50045, lrLinPar."Punto recogida");
                AddAttribute(Nodo[4], Text50046, lrLinPar.nom_punto);
                AddAttribute(Nodo[4], Text50039, FORMAT(lrLinPar."Hora recogida",0,Text50026));

                IF rPar."Empresa Real" = rPar."Empresa Real"::UEX THEN BEGIN
                  IF lrLinPar.Touroperador = rParUEX."Touroperador Thomson" THEN
                    lwTTOO := rParUEX."TTOO THOMSON Export. Proveedor"
                  ELSE
                    lwTTOO := rParUEX."TTOO TUI Exportacion Proveedor";
                END
                ELSE
                  lwTTOO := lrLinPar.Touroperador;

                AddAttribute(Nodo[4], Text50020, lwTTOO);
                AddAttribute(Nodo[4], Text50047, lrLinPar."Zona fisica");
                // JPT 07/08/06 Debemos de separar los invitados de los transportados ya que la importaci¢n
                // lo consider  as¡. P.O. Gori Carvajal.
                lwDec := lrLinPar."Adultos transportados" - lrLinPar."Adultos invitados coste";
                AddAttribute(Nodo[4], Text50048, FORMAT(lwDec));
                lwDec := lrLinPar."Ni¤os transportados" - lrLinPar."Ni¤os invitados coste";
                AddAttribute(Nodo[4], Text50049  , FORMAT(lwDec));
                AddAttribute(Nodo[4], Text50050, FORMAT(lrLinPar."Adultos invitados coste"));
                AddAttribute(Nodo[4], Text50051  , FORMAT(lrLinPar."Ni¤os invitados coste"));
                AddAttribute(Nodo[4], Text50036,lrLinPar.Vuelo);
                AddAttribute(Nodo[4], Text50052  , FORMAT(lrLinPar."Hora Vuelo" ,0,Text50026));
                AddAttribute(Nodo[4], Text50029,lrLinPar.Observaciones);
                IF lrLinPar."Nombre Cliente" <> '' THEN
                  AddAttribute(Nodo[4], Text50053, lrLinPar."Nombre Cliente");
                IF lrLinPar.Reserva <> '' THEN
                  AddAttribute(Nodo[4], Text50054      , lrLinPar.Reserva);

                // SUPLEMENTOS

                CLEAR(lrSuplets);
                lrSuplets.SETRANGE("N§ Parte", lrLinPar."N§ Parte");
                lrSuplets.SETRANGE("N§ Linea", lrLinPar."N§ Linea");
                IF lrSuplets.FINDSET THEN BEGIN
                  AddElement(Nodo[4], Text50055, '', '', Nodo[5]);
                  CLEAR(lwCont2);
                  REPEAT
                    lwCont2 += 1;
                    AddElement(Nodo[5], STRSUBSTNO(Text50056, lwCont2), '', '', Nodo[6]);
                    AddAttribute(Nodo[6], Text50057, lrSuplets."Cod. Suplemento");
                    AddAttribute(Nodo[6], Text50058, FORMAT(lrSuplets.Cantidad));
                  UNTIL lrSuplets.NEXT = 0;
                END;
              UNTIL lrLinPar.NEXT = 0;
            END;

            // EXTRAS

            CLEAR(lrExtras);
            lrExtras.SETRANGE("N§ Parte", lrParte."N§ Parte");
            IF lrExtras.FINDSET THEN BEGIN
              AddElement(Nodo[2], Text50059, '', '', Nodo[3]);
              CLEAR(lwCont2);
              REPEAT
                lwCont2 +=1;
                AddElement(Nodo[3], STRSUBSTNO(Text50060, lwCont2), '', '', Nodo[4]);
                AddAttribute(Nodo[4], Text50061, lrExtras.Extra);
                AddAttribute(Nodo[4], Text50020  , lrExtras.Touroperador);
              UNTIL lrExtras.NEXT=0;
            END;

            // AJS 18.07.2006 ## DRF 06008
            // Si es una exportacion a proveedor guardamos el n£mero de exportaci¢n en el parte

            IF pwTipoExportacion = pwTipoExportacion::Proveedor THEN BEGIN
              lrParte2 := lrParte;
              lrParte2."Num Exportacion Prov" := pwNo;
              lrParte2.MODIFY;
            END;
          END;
          wVentana.UPDATE(1, ROUND(lwCont / lwTotal * 10000, 1));
        UNTIL lrParte.NEXT = 0;
        // lrParte.MODIFYALL("Num Exportacion Prov", pwNo);
        wVentana.CLOSE;
        XML.save(lwNomArch);
        CLEAR(XML);
        CLEAR(Nodo);

        // AJS 18.07.2006 ## DRF 06008
        // Envio por correo solo en las exportaciones a proveedores

        IF (lrHist."Envio Mail") AND (pwTipoExportacion = pwTipoExportacion::Proveedor) THEN BEGIN
          CLEAR(lwHost);
          IF rPar."Empresa Real" = rPar."Empresa Real"::UEX THEN BEGIN
            //-$005rParUEX.TESTFIELD("Host SMTP");
            lwHost := rParUEX."Host SMTP";
          END
          ELSE BEGIN
            //-$005AJSrParAux.TESTFIELD("Host SMTP");
            lwHost := rParAux."Host SMTP";
          END;

          lrHist.CALCFIELDS("Total Parte");
          lrInfEmp.GET;
          lrInfEmp.TESTFIELD("E-Mail");
          CLEAR(lwArchivos);
          CLEAR(lwCuerpo);
          lrProv.TESTFIELD("E-Mail");

          lwAsunto     := STRSUBSTNO(Text0012,lrHist."Fecha Desde",lrHist."Fecha Hasta",lrHist."Total Parte");
          lwArchivos[1]:= lwNomArch;
          cFunBas.EnviaDocumentoEmail(            lwHost,
                                        lrInfEmp."E-Mail",
                                          lrProv."E-Mail",
                                                 lwAsunto,
                                               lwArchivos,
                                                lwCuerpo,
                                                TRUE);
        END;
      END
      ELSE
        ERROR(Text0006);
    END;

    PROCEDURE BuscaGaraje@1100244006(prParte@1100244004 : Record 7010360;VAR prConf@1100244003 : Record 7010371;prError@1100244002 : Boolean) : Boolean;
    VAR
      lwPaxes@1100244001 : Decimal;
      lwOk@1100244000 : Boolean;
      lText0001@1100244005 : TextConst 'ESP="No se ha encontrado ninguna configuracion Exportacion Proveedor (%3) para Zona Fisica %1 y  Rango %2  "';
    BEGIN

      // BuscaGaraje
      // Devuelve el regisgtro de configuracion del Parte pasado como parametro
      // prError Indica si debe de generarse un error en caso de no encontrar nada

      CLEAR(prConf);
      prParte.CALCFIELDS("Adultos transportados","Ni¤os transportados");
      lwPaxes := prParte."Adultos transportados" + prParte."Ni¤os transportados";

      prConf.SETCURRENTKEY("Tipo Busqueda",Proveedor,"Zona Fisica","Rango Desde","Rango Hasta");

      prConf.SETRANGE("Tipo Busqueda", prConf."Tipo Busqueda"::Garaje);
      prConf.SETRANGE(Proveedor      , prParte.Proveedor);
      prConf.SETRANGE("Zona Fisica"  , prParte."Zona parte");
      prConf.SETFILTER("Rango Desde" , '<=%1', lwPaxes);
      prConf.SETFILTER("Rango Hasta" , '>=%1', lwPaxes);
      lwOk :=prConf.FINDFIRST;

      IF prError AND NOT lwOk THEN BEGIN
        prConf.SETRANGE("Zona Fisica");
        prConf.SETRANGE("Rango Desde");
        prConf.SETRANGE("Rango Hasta");
        IF prConf.FINDFIRST THEN // Solo da error si existe algun registro para este proveedor
          ERROR(lText0001,prParte."Zona parte",lwPaxes,prParte.Proveedor);
      END;

      IF NOT lwOk THEN
        CLEAR(prConf);
      EXIT(lwOk);
    END;

    PROCEDURE AddElement@32(VAR DOMNode@1001 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";Name@1002 : Text[250];Value@1003 : Text[250];NameSpace@1004 : Text[250];VAR CreatedDOMNode@1005 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode") Status@1000 : Integer;
    VAR
      TempElement@1100244000 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";
    BEGIN
      // AddElement

      // TempElement := DOMNode.ownerDocument.createNode(Text50062, Name, NameSpace);
      TempElement:=XML.createNode(Text50014,Name,NameSpace);

      IF TempElement.nodeName='' THEN BEGIN
        Status := 50;
        EXIT(Status)
      END;
      IF Value <> '' THEN BEGIN
        TempElement.text := Value;
        // Hay caracteres no permitidos
        Value := DELCHR(Value,'=','/<>');
      END;
      DOMNode.appendChild(TempElement);
      CreatedDOMNode := TempElement;
      CLEAR(TempElement);
      Status := 0;
    END;

    PROCEDURE AddAttribute@28(VAR DOMNode@1001 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";Name@1002 : Text[250];Value@1003 : Text[250]) Status@1000 : Integer;
    VAR
      TempAttribute@1100244000 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";
    BEGIN
      // AddAttribute

      TempAttribute := DOMNode.ownerDocument.createAttribute(Name);
      IF TempAttribute.nodeName='' THEN BEGIN
        Status := 60;
        EXIT(Status)
      END;

      IF Value <> '' THEN BEGIN
        // Hay caracteres no permitidos
        Value := DELCHR(Value,'=','/<>');
        TempAttribute.nodeValue := Value;
      END;
      DOMNode.attributes.setNamedItem(TempAttribute);
      CLEAR(TempAttribute);
    END;

    PROCEDURE ModificaVuelosParte@1100244005(VAR prParte@1100244000 : Record 7010360);
    VAR
      lrCond@1100244001 : Record 7010420;
      lrPI@1100244003 : Record 7035392;
      lrSerPar@1100244004 : Record 7010359;
      fFicVue@1100244002 : Form 7035316;
    BEGIN
      // ModificaVuelosParte
      //

      // Comprobar si este parte esta pendiente de facturar

      lrPI.RESET;
      lrPI.SETRANGE ("N§ Parte"  , prParte."N§ Parte");
      IF NOT lrPI.FINDFIRST THEN
        ERROR(Text12);

      // Llamamos a la ventana para solicitar el nuevo vuelo

      IF NOT lrCond.GET(USERID) THEN BEGIN
        lrCond.INIT;
        lrCond.Usuario := USERID;
        lrCond.INSERT;
      END;

      lrCond."N§ Parte"   := prParte."N§ Parte";
      lrCond.Cliente      := prParte.Cliente;
      lrCond.Touroperador := prParte."Touroperador principal";

      // Busca el primer ingreso para obtener el vuelo actual


      IF lrPI.FINDFIRST THEN
        lrCond.Referencia := lrPI.Vuelos // Utilizamos el campo referencia como temporal para poner y recoger el vuelo
      ELSE
        lrCond.Referencia := prParte.Vuelos;

      lrCond.MODIFY;
      lrCond.SETRECFILTER;
      COMMIT;

      CLEAR(fFicVue);
      fFicVue.SETTABLEVIEW(lrCond);
      IF fFicVue.RUNMODAL <> ACTION::OK THEN
        EXIT;
      fFicVue.GETRECORD(lrCond);

      // JPT 30/05/06 Validamos el campo vuelos en parte. Eso de paso lo formatea
      prParte.VALIDATE(Vuelos, lrCond.Referencia);
      prParte.MODIFY; // No puede ejecutarse el OnValidate ya que el parte puede estar confirmado.

      // Pasar Vuelos a las lineas de ingreso

      lrPI.RESET;
      lrPI.SETRANGE ("N§ Parte"  , prParte."N§ Parte");
      IF lrPI.FINDFIRST THEN
        lrPI.MODIFYALL(Vuelos, prParte.Vuelos);

      // Pasar Vuelos a la primera linea de recogida y final

      lrSerPar.RESET;
      lrSerPar.SETCURRENTKEY("N§ Parte");
      lrSerPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF lrSerPar.FINDFIRST THEN BEGIN
        lrSerPar.Vuelo := prParte.Vuelos;
        lrSerPar.MODIFY;
      END;
    END;

    PROCEDURE RetornaPresentacion@1100244007(prParte@1100244000 : Record 7010360;VAR prLinPar@1100244001 : Record 7010359) : Text[50];
    BEGIN
      // RetornaPresentacion
      //
      EXIT(prParte.nom_origen);
    END;

    PROCEDURE validar_conf_partes@1100244008(pw_CodTPR@1100244000 : Code[10]);
    VAR
      lrTTOOxParte@1100244006 : Record 7010365;
      lrGrupo@1100244005 : Record 7010373;
      lrParteAux@1100244004 : Record 7010360;
      vError@1100244003 : Boolean;
      vNumReg@1100244002 : Integer;
      vNumParte@1100244001 : Code[10];
    BEGIN
      //BRM 21/05/04 Solo confirmamos los partes de grupo cuando:
      //             - El grupo al q pertenecen ha sido confirmado
      //             - El resto de partes del mismo grupo confirmados son manuales o no facturables

      lrGrupo.GET(pw_CodTPR);

      IF NOT lrGrupo.Confirmado THEN
        ERROR(err6,lrGrupo."Codigo Grupo");

      IF (lrGrupo."Tipo Facturacion"=lrGrupo."Tipo Facturacion"::Manual) THEN BEGIN

        vError := FALSE;

        //En primer lugar vamos a comprobar si todos los partes tienen precio manual
        lrParteAux.RESET;
        lrParteAux.SETCURRENTKEY("Cod Grupo");
        lrParteAux.SETRANGE("Cod Grupo",lrGrupo."Codigo Grupo");
        IF lrParteAux.FINDSET THEN REPEAT

        IF NOT lrParteAux.Facturable THEN
          vError := TRUE;

          lrTTOOxParte.RESET;
          lrTTOOxParte.SETFILTER("N§ Parte",lrParteAux."N§ Parte");
          IF lrTTOOxParte.FINDSET THEN REPEAT
          IF (lrTTOOxParte."Precio manual venta"=0) THEN
            vError := TRUE;
          UNTIL (lrTTOOxParte.NEXT=0) OR vError;

        UNTIL (lrParteAux.NEXT=0) OR vError;

        //Si no todos los partes tienen precio manual comprobaremos q uno tiene precio
        //y los demas son no facturables
        IF vError THEN BEGIN

          //Comprobamos si hay m s de 1 parte con precio
          CLEAR(vNumReg);
          CLEAR(vNumParte);
          lrParteAux.RESET;
          lrParteAux.SETCURRENTKEY("Cod Grupo");
          lrParteAux.SETRANGE("Cod Grupo",lrGrupo."Codigo Grupo");
          IF lrParteAux.FINDSET THEN REPEAT
            lrTTOOxParte.RESET;
            lrTTOOxParte.SETFILTER("N§ Parte",lrParteAux."N§ Parte");
            lrTTOOxParte.SETFILTER("Precio manual venta",'<>%1',0);
            IF lrTTOOxParte.FINDFIRST THEN BEGIN
              vNumParte := lrParteAux."N§ Parte";
              vNumReg := vNumReg + 1;
            END;
          UNTIL lrParteAux.NEXT=0;

          IF (vNumReg = 0) THEN
            ERROR(err7,lrGrupo."Codigo Grupo");

          IF (vNumReg > 1) THEN
            ERROR(err11,lrGrupo."Codigo Grupo");

          //Comprobamos si el resto de partes sin precio est n marcados como no facturables
          lrParteAux.RESET;
          lrParteAux.GET(vNumParte);
          lrParteAux.TESTFIELD(Facturable,TRUE);

          lrTTOOxParte.RESET;
          lrTTOOxParte.SETFILTER("N§ Parte",vNumParte);
          IF lrTTOOxParte.FINDSET THEN REPEAT
            IF (lrTTOOxParte."Precio manual venta" = 0) THEN
              ERROR(err8,vNumParte);
          UNTIL lrTTOOxParte.NEXT=0;

          lrParteAux.RESET;
          lrParteAux.SETCURRENTKEY("Cod Grupo");
          lrParteAux.SETRANGE("Cod Grupo",lrGrupo."Codigo Grupo");
          lrParteAux.SETFILTER("N§ Parte",'<>%1',vNumParte);
          IF lrParteAux.FINDSET THEN REPEAT
            IF lrParteAux.Facturable THEN
              ERROR(err9,lrParteAux."N§ Parte");
          UNTIL lrParteAux.NEXT=0;
        END;
      END;
    END;

    PROCEDURE MostrarProductos@1100244009(VAR prParte@1100244000 : Record 7010360);
    VAR
      lrCont@1100244001 : Record 7010403;
      lrPrecios@1100244002 : Record 7010405;
      lrSerPar@1100244003 : Record 7010359;
      lrZonCon@1100244006 : Record 7010404;
      lrTipoSer@1103355000 : Record 7010319;
      lfPrecios@1100244004 : Form 7010420;
      lwPax@1100244005 : Decimal;
    BEGIN
      // MostrarProductos
      // Ense¤a una lista con los precios concernientes al codigo de servicio del parte

      // Primero buscamos el contrato

      lrCont.RESET;
      lrCont.SETCURRENTKEY(Cliente, Touroperador, "Fecha inicio contrato", "Fecha final contrato");
      lrCont.SETRANGE(Cliente                , prParte.Cliente);
      lrCont.SETRANGE(Touroperador           , prParte."Touroperador principal");
      lrCont.SETFILTER("Fecha inicio contrato", '<=%1',prParte.Fecha);
      lrCont.SETFILTER("Fecha final contrato" , '>=%1',prParte.Fecha);
      lrCont.SETRANGE(Confirmado              , TRUE);
      IF NOT lrCont.FINDFIRST THEN
        ERROR(Text0008, lrCont.GETFILTERS);

      // Puede ser un contrato basado en precios de otro

      lrCont.RESET;
      IF lrCont."Basado en contrato n§" <> '' THEN BEGIN
        lrCont.SETRANGE("N§ Contrato", lrCont."Basado en contrato n§");
        IF NOT lrCont.FINDFIRST THEN
          ERROR(Text0008, lrCont.GETFILTERS);
      END;

      prParte.CALCFIELDS("Adultos transportados","Ni¤os transportados");
      lwPax := prParte."Adultos transportados" + prParte."Ni¤os transportados";

      // Busca la zona contrato

      // AJS 28.06.2008
      // Buscamos el tipo de servicio para filtrar por el tipo de servicio fijo

      lrTipoSer.GET(prParte."Tipo Servicio");

      lrZonCon.RESET;
      lrZonCon.SETFILTER(Garaje              , lrCont.Garaje);
      lrZonCon.SETFILTER("N§ Contrato"       , lrCont."N§ Contrato");
      lrZonCon.SETFILTER("Tipo contrato"     , '%1',lrZonCon."Tipo contrato"::Venta);
      lrZonCon.SETFILTER("Codigo Origen"     , prParte."Zona parte");
      lrZonCon.SETRANGE ("Tipo Servicio fijo", lrTipoSer."Tipo fijo");
      IF NOT lrZonCon.FINDFIRST THEN
        CLEAR(lrZonCon);

      lrPrecios.RESET;
      lrPrecios.SETRANGE(Garaje           , lrCont.Garaje);
      lrPrecios.SETRANGE(Activo           , TRUE);
      lrPrecios.SETRANGE("N§ Contrato"    , lrCont."N§ Contrato");
      lrPrecios.SETRANGE("Tipo precio"    , lrPrecios."Tipo precio"::"Precio Base");
      // lrPrecios.SETRANGE("Tipo Servicio"  , prParte."Tipo Servicio");
      lrPrecios.SETFILTER("Fecha desde"   ,'<=%1', prParte.Fecha);
      lrPrecios.SETFILTER("Fecha hasta"   ,'>=%1', prParte.Fecha);
      lrPrecios.SETFILTER("Zona desde"    , lrZonCon."Zona Precio");
      lrPrecios.SETFILTER("Rango desde"   ,'<=%1|%2',lwPax,0);
      lrPrecios.SETFILTER("Rango hasta"   ,'>=%1|%2',lwPax,0);

      // AJS 28.06.2008
      // Filtramos por el tipo de servicio fijo

      lrPrecios.SETRANGE("Tipo Servicio fijo", lrTipoSer."Tipo fijo");

      IF lrPrecios.FINDFIRST THEN BEGIN
        lfPrecios.EDITABLE  := FALSE;
        lfPrecios.SETTABLEVIEW(lrPrecios);
        lfPrecios.LOOKUPMODE:= TRUE;
        lfPrecios.CAPTION   := Text0009;
        lfPrecios.RUNMODAL;
      END ELSE
        MESSAGE(Text0010);
    END;

    PROCEDURE FiltraParte@1103350006(VAR prParte@1103350000 : Record 7010360) : Boolean;
    VAR
      lfConFact@1103350001 : Form 7035360;
      lrCond@1103350002 : Record 7010420;
      lwNumClave@1103350003 : Integer;
      lwClv@1103350004 : ARRAY [15] OF Boolean;
      lwContFilt@1103350005 : Text[250];
      lwCont@1103350006 : Integer;
      lwNCmps@1103350007 : Integer;
      lwrTabla@1103350008 : RecordRef;
    BEGIN
      // FiltraParte
      // Propone un filtrado inicial de la Tabla Parte antes de ense¤ar la ventana

      CLEAR(lfConFact);
      CLEAR(lrCond);

      // AJF 07/01/09
      // Evito borrar el registro, ya que ahora tiene datos permanentes.
      IF lrCond.GET(USERID) THEN
        lrCond.LimpiaRegistro
      ELSE BEGIN
        lrCond.INIT;
        lrCond.Usuario := USERID;
        lrCond.INSERT;
      END;

      lrCond.FILTERGROUP(2);
      lrCond.SETRECFILTER;
      lrCond.FILTERGROUP(0);

      COMMIT;

      lfConFact.SETTABLEVIEW(lrCond);

      lfConFact.Presentar(TRUE,TRUE,TRUE,TRUE);
      // lfConFact.MAXIMIZEDONOPEN:= TRUE;
      lfConFact.LOOKUPMODE:= TRUE;
      lfConFact.CAPTION   := Text0013;
      //IF lfConFact.RUNMODAL <> ACTION::LookupOK THEN
      IF lfConFact.RUNMODAL <> ACTION::OK THEN
        EXIT(FALSE);

      lrCond.FIND;
      prParte.RESET;

      // Filtros

      prParte.FILTERGROUP(2);
      // prParte.SETFILTER(Gestor,'%1|%2',USERID,'');  //JPT 03/08/05 Lo pasamos a la ventana
      prParte.SETRANGE(Confirmado, TRUE);
      prParte.FILTERGROUP(0);

      IF lrCond.Cliente <> '' THEN
        prParte.SETRANGE(Cliente, lrCond.Cliente);

      IF lrCond.Touroperador <> '' THEN
        prParte.SETRANGE("Touroperador principal" , lrCond.Touroperador);

      IF lrCond.Garaje <> '' THEN
        prParte.SETRANGE(Garaje , lrCond.Garaje);

      IF lrCond."Tipos servicio" <> '' THEN
        prParte.SETFILTER("Tipo Servicio" ,lrCond."Tipos servicio");

      IF lrCond."Codigos Servicio" <> '' THEN
        prParte.SETFILTER("Codigo Servicio", lrCond."Codigos Servicio");

      IF lrCond."Tipos Vehiculo" <> '' THEN
        prParte.SETFILTER("Tipo Vehiculo", lrCond."Tipos Vehiculo");

      IF  lrCond."Zonas Precio" <> '' THEN
        prParte.SETRANGE("Zona parte", lrCond."Zonas Precio");

      IF  lrCond."N§ Parte" <> '' THEN
        prParte.SETRANGE("N§ Parte" , lrCond."N§ Parte");

      IF lrCond.Referencia  <> '' THEN
        prParte.SETRANGE(Referencia , lrCond.Referencia);

      IF lrCond.Proveedor  <> '' THEN
        prParte.SETRANGE(Proveedor , lrCond.Proveedor);

      IF (lrCond."Fecha desde" <> 0D) OR (lrCond."Fecha hasta" <> 0D) THEN
        prParte.SETFILTER(Fecha, '%1..%2' ,lrCond."Fecha desde" ,lrCond."Fecha hasta" );

      IF (lrCond."Rango Desde" <> 0) OR  (lrCond."Rango Hasta" <> 0) THEN
        prParte.SETFILTER("Paxes Previstos", '%1..%2' ,lrCond."Rango Desde", lrCond."Rango Hasta");

      // Establecemos la clave idonea
      DeterminaClaveParte(prParte);


      EXIT(TRUE);
    END;

    PROCEDURE DeterminaClaveParte@1103350002(VAR prParte@1103350001 : Record 7010360);
    VAR
      lwrTabla@1103350000 : RecordRef;
      lwNumClave@1103350002 : Integer;
      lwTexto@1103355000 : Text[250];
    BEGIN
      // DeterminaClaveParte

      lwrTabla.OPEN(DATABASE::Parte);
      lwrTabla.GETTABLE(prParte);
      lwNumClave := DeterminaClave(lwrTabla);

      // lwrTabla.SETTABLE(prParte); // JPT 28/12/04 Esto no se porque no traspasa la clave
      lwTexto := lwrTabla.GETVIEW;
      prParte.SETVIEW(lwTexto);
      lwrTabla.CLOSE;
    END;

    PROCEDURE DeterminaClave@1103350009(VAR prrTabla@1103350000 : RecordRef) : Integer;
    VAR
      lrFieldT@1103350001 : FieldRef;
      lrFieldK@1103350004 : FieldRef;
      lrKey@1103350002 : KeyRef;
      lwNumK@1103350003 : Integer;
      lwNumFK@1103350009 : Integer;
      lwNumF@1103350005 : Integer;
      lwNumCamps@1103350006 : ARRAY [2] OF Integer;
      lwNumCampsKv@1103350010 : ARRAY [2] OF Integer;
      lwPosCamps@1103350007 : ARRAY [2] OF Integer;
      lwNumClave@1103350008 : Integer;
      lwOK@1103350011 : Boolean;
    BEGIN
      // DeterminaClave
      //
      // JPT 28/12/04
      // Esta funci¢n determina la clave optima para la tabla
      // Tambien devuelve el numero de orden de la clave
      // En teoria un SETTABLE sobre el puntero record permitiria traspasar la clave, pero he comprobado que no es as¡

      CLEAR(lwNumCamps); // Numero de campos coincidentes
      CLEAR(lwPosCamps); // Suma de las posiciones de los campos coincidentes
      CLEAR(lwNumCampsKv); // Numero total de campos que tiene la clave
      lwNumClave:=1;
      FOR lwNumK:=1 TO prrTabla.KEYCOUNT DO BEGIN
        lwNumCamps[2]  :=0;
        lwPosCamps[2]  :=0;
        lwNumCampsKv[2]:=0;
        lrKey:= prrTabla.KEYINDEX(lwNumK);
        IF lrKey.ACTIVE THEN BEGIN
          lwNumCampsKv[2] := lrKey.FIELDCOUNT; // Numero de campos de la clave
          FOR lwNumF:=1 TO prrTabla.FIELDCOUNT DO BEGIN
            lrFieldT := prrTabla.FIELDINDEX(lwNumF);
            IF lrFieldT.GETFILTER <> '' THEN BEGIN
              FOR lwNumFK := 1 TO lrKey.FIELDCOUNT DO BEGIN
                lrFieldK := lrKey.FIELDINDEX(lwNumFK);
                IF lrFieldT.NUMBER = lrFieldK.NUMBER THEN BEGIN
                  lwNumCamps[2] += 1;       // Numero de campos Coincidentes
                  lwPosCamps[2] += lwNumFK;  // Posicion de campos
                END;
              END;
            END;
          END;
        END;
        // Seleccionamos la clave si tiene m s campos coincidentes, o si est n en un orden mejor
        // o que la clave tenga en total menos campos en caso de que tengan los mismos coincidentes

        lwOK := (lwNumCamps[2] > lwNumCamps[1]);
        IF NOT lwOK THEN BEGIN
          IF ((lwNumCamps[2] = lwNumCamps[1]) AND (lwNumCampsKv[2] < lwNumCampsKv[1])) THEN
            lwOK := TRUE
          ELSE
            lwOK := ((lwNumCamps[2] = lwNumCamps[1]) AND (lwPosCamps[2] < lwPosCamps[1]));
        END;

        IF lwOK THEN BEGIN
          lwNumClave := lwNumK;
          lwNumCamps[1]   := lwNumCamps[2];
          lwPosCamps[1]   := lwPosCamps[2];
          lwNumCampsKv[1] := lwNumCampsKv[2];
        END;
      END;

      prrTabla.CURRENTKEYINDEX(lwNumClave);

      EXIT(lwNumClave);
    END;

    PROCEDURE CompruebaRestriccion@1103350001(pwCod@1103350003 : Code[20];pwGenError@1103350000 : Boolean) : Boolean;
    VAR
      lrAcc@1103350001 : Record 7010422;
      lwTiene@1103350002 : Boolean;
    BEGIN
      // CompruebaRestriccion

      CLEAR(lwTiene);
      IF rUsu.GET(USERID) THEN
        lwTiene := lrAcc.GET(rUsu."Perfil Transfer",pwCod);

      IF lwTiene AND pwGenError THEN
        ERROR(Text0016);

      EXIT(lwTiene);
    END;

    PROCEDURE ContabilizaServicioContado@1103350003(VAR prParte@1100244001 : Record 7010360);
    VAR
      lrGaraje@1103350000 : Record 7010310;
      lrConCodOr@1100244010 : Record 242;
      lrClient@1100244009 : Record 18;
      lrGrConClient@1100244008 : Record 92;
      lrDiarios@1100244007 : Record 80;
      lrSecciones@1100244006 : Record 232;
      lwCta@1100244005 : Code[20];
      GenJnlLine@1100244004 : Record 81;
      GenJnlLine2@1100244015 : Record 81;
      lrTemp@1100244013 : TEMPORARY Record 81;
      GenJnlPostLine@1100244003 : Codeunit 12;
      lwTotalImp@1100244002 : Decimal;
      lwCont@1100244014 : ARRAY [2] OF Integer;
      lwAsiento@1103350001 : Integer;
    BEGIN
      // ContabilizaServicioContado
      // Genera un asiento de cobro si el Garaje est  marcado como "Cobro Directo"
      //

      rPar.FINDFIRST;
      CLEAR(lrGaraje);
      CLEAR(GenJnlLine);
      prParte.TESTFIELD(Garaje);
      lrGaraje.GET(prParte.Garaje);
      IF NOT lrGaraje."Cobro Directo" THEN
        EXIT;

      lrGaraje.TESTFIELD("Banco Cobro");

      CLEAR(lwTotalImp);

      CLEAR(lwCont);
      // Busca el diario de cobros
      lrDiarios.RESET;
      lrDiarios.SETRANGE(Type , lrDiarios.Type::"Cash Receipts");
      lrDiarios.FINDFIRST;

      GenJnlLine.VALIDATE("Journal Template Name" , lrDiarios.Name);

      lrSecciones.RESET;
      lrSecciones.INIT;
      IF lrDiarios.Name <> '' THEN BEGIN
        IF NOT lrSecciones.GET(lrDiarios.Name, Text0017) THEN BEGIN
          lrSecciones."Journal Template Name" := lrDiarios.Name;
          lrSecciones.Name                    := Text0017;
          lrSecciones.Description             := Text0019;
          lrSecciones.INSERT(TRUE);
        END;
      END;

      // Buscamos el numero de asiento
      CLEAR(lwAsiento);
      CLEAR(GenJnlLine2);

      GenJnlLine2.SETCURRENTKEY("Journal Template Name",
                               "Journal Batch Name",
                               "Posting Date",
                               "Transaction No.");
      GenJnlLine2.SETRANGE("Journal Template Name" , lrDiarios.Name);
      GenJnlLine2.SETRANGE("Journal Batch Name"    , lrSecciones.Name);
      IF GenJnlLine2.FINDLAST THEN
        lwAsiento := GenJnlLine2."Transaction No." + 1
      ELSE
        lwAsiento := 1;

      // Buscamos el Ultimo n£mero de linea del diario
      CLEAR(lwCont);
      CLEAR(GenJnlLine2);
      GenJnlLine2.SETRANGE("Journal Template Name" , lrDiarios.Name);
      GenJnlLine2.SETRANGE("Journal Batch Name"    , lrSecciones.Name);
      IF GenJnlLine2.FINDLAST THEN
        lwCont[1] := GenJnlLine2."Line No.";
      lwCont[1] += 1;
      lwCont[2] := lwCont[1];

      // Buscamos el importe total
      lwTotalImp := prParte.TotalIngreso;

      IF lwTotalImp=0 THEN // No se pasa nada al diario si el importe es 0
        EXIT;

      GenJnlLine.INIT;
      lwCont[2]                              += 1;
      GenJnlLine."Line No."                  := lwCont[2];

      GenJnlLine.VALIDATE("Transaction No."  , lwAsiento);
      GenJnlLine.VALIDATE("Posting Date"     ,  TODAY);
      GenJnlLine."Journal Batch Name"        := lrSecciones.Name;
      GenJnlLine.VALIDATE("Document Date"    , prParte.Fecha);
      IF lwTotalImp > 0 THEN
        GenJnlLine."Document Type"           := GenJnlLine."Document Type"::Payment
      ELSE
        GenJnlLine."Document Type"           := GenJnlLine."Document Type"::Refund;

      // Buscamos el codigo de origen
      lrConCodOr.GET;
      GenJnlLine."Source Code" := lrConCodOr."Cash Receipt Journal";
      GenJnlLine."Document No." := prParte."N§ Parte";

      lrClient.GET(prParte.Cliente);
      // lrGrConClient.GET(lrClient."Customer Posting Group");

      CLEAR(lwCta);
      lwCta := lrGaraje."Banco Cobro";
      GenJnlLine."Account Type":= GenJnlLine."Bal. Account Type"::"Bank Account";
      GenJnlLine.VALIDATE("Account No.", lwCta);

      GenJnlLine."External Document No."     := prParte."N§ Parte";
      GenJnlLine."Currency Factor" :=  1;
      GenJnlLine."Due Date" := TODAY;
      GenJnlLine.VALIDATE("Debit Amount", lwTotalImp);
      GenJnlLine.Description  := STRSUBSTNO(Text0018,prParte."N§ Parte");
      GenJnlLine.VALIDATE("Shortcut Dimension 1 Code", prParte.Garaje);
      GenJnlLine.VALIDATE("Shortcut Dimension 2 Code", prParte."Touroperador principal");
      // Dimension Tipo de Servicio
      IF rPar."Tipo Servicio Como Dimension" THEN BEGIN
        rPar.TESTFIELD("Dimensi¢n Tipo Servicio");
        InsertDimLD(GenJnlLine, rPar."Dimensi¢n Tipo Servicio", prParte."Tipo Servicio");
      END;
      GenJnlLine.INSERT;


      lwCta := prParte.Cliente;
      GenJnlLine.INIT;
      lwCont[2]                              += 1;
      GenJnlLine."Line No."                  := lwCont[2];
      GenJnlLine.VALIDATE("Transaction No."  , lwAsiento);
      GenJnlLine.VALIDATE("Posting Date"     ,  TODAY);
      GenJnlLine."Journal Batch Name"        := lrSecciones.Name;
      GenJnlLine.VALIDATE("Document Date"    ,  prParte.Fecha);
      GenJnlLine.Description                 := STRSUBSTNO(Text0018,prParte."N§ Parte");;
      GenJnlLine.VALIDATE("Account Type"     , GenJnlLine."Account Type"::Customer);
      GenJnlLine.VALIDATE("Account No."      , lwCta);
      IF lwTotalImp > 0 THEN
        GenJnlLine."Document Type"             := GenJnlLine."Document Type"::Payment
      ELSE
        GenJnlLine."Document Type"             := GenJnlLine."Document Type"::Refund;
      // Buscamos el codigo de origen
      lrConCodOr.GET;
      GenJnlLine."Source Code" := lrConCodOr."Cash Receipt Journal";
      GenJnlLine."Document No.":= prParte."N§ Parte";
      GenJnlLine.VALIDATE("Credit Amount", lwTotalImp);
      GenJnlLine."Currency Factor" :=  1;
      GenJnlLine.Description  := STRSUBSTNO(Text0018,prParte."N§ Parte");
      GenJnlLine.VALIDATE("Shortcut Dimension 1 Code", prParte.Garaje);
      GenJnlLine.VALIDATE("Shortcut Dimension 2 Code", prParte."Touroperador principal");
      // Dimension Tipo de Servicio
      IF rPar."Tipo Servicio Como Dimension" THEN BEGIN
        rPar.TESTFIELD("Dimensi¢n Tipo Servicio");
        InsertDimLD(GenJnlLine, rPar."Dimensi¢n Tipo Servicio", prParte."Tipo Servicio");
      END;

      GenJnlLine.INSERT;


      COMMIT; // Los errores de registro no deben impedir el cobro
      GenJnlLine.RESET;
      GenJnlLine.SETCURRENTKEY("Journal Template Name","Journal Batch Name","Posting Date","Transaction No.");
      GenJnlLine.SETRANGE("Journal Template Name", lrDiarios.Name);
      GenJnlLine.SETRANGE("Journal Batch Name"   , lrSecciones.Name);
      GenJnlLine.SETRANGE("Transaction No."      , lwAsiento);
      IF GenJnlLine.FINDFIRST THEN
          cCont.RUN(GenJnlLine);
      CLEARALL;
    END;

    PROCEDURE InsertDimLD@1103350004(VAR prLinDia@1100217000 : Record 81;pwDim@1100217001 : Code[20];pwValor@1103350000 : Code[20]);
    VAR
      lrConfCont@1100217003 : Record 98;
      lrDim@1100244000 : Record 356;
      lrDim2@1103350001 : Record 356;
    BEGIN
      // InsertDimL
      //
      // Inserta una dimensione a una linea de diario

      IF (pwDim='') OR (pwValor='') THEN
        EXIT;

      //CLEAR(lrDim);
      lrDim.RESET;
      lrDim.INIT;
      lrDim."Table ID"              := DATABASE::"Gen. Journal Line";
      lrDim."Journal Template Name" := prLinDia."Journal Template Name";
      lrDim."Journal Batch Name"    := prLinDia."Journal Batch Name";
      lrDim."Journal Line No."      := prLinDia."Line No.";

      lrDim."Dimension Code"       := pwDim;
      lrDim."Dimension Value Code" := pwValor;
      lrDim2 := lrDim;
      IF lrDim2.FIND THEN
        lrDim.MODIFY
      ELSE
        lrDim.INSERT;
    END;

    PROCEDURE CambiaVariosPrecioManual@1100253000(VAR prParte@1100253000 : Record 7010360);
    VAR
      lrParte@1100253004 : Record 7010360;
      lrTOPar@1103350000 : Record 7010365;
      lrHist@1100253009 : Record 7010361;
      lw_preciomanual@1103350001 : Decimal;
      lwOpc@1100253001 : Integer;
      lwImporte@1100253002 : Decimal;
      lwNumP@1100253003 : Integer;
      lwDif@1100253005 : Decimal;
      lwVentana2@1100253006 : Dialog;
      lwCont@1100253007 : Integer;
      lwTotal@1100253008 : Integer;
      lwCont2@1100253011 : Integer;
      lwTotal2@1100253010 : Integer;
      lwValorAnt@1100253012 : Decimal;
    BEGIN
      // CambiaVariosPrecioManual
      // Cambiar el precio manual de Varios partes

      lrParte.COPY(prParte);

      lwOpc := STRMENU(Text0022);
      IF lwOpc=0 THEN
        EXIT;

      IF lwOpc= 1 THEN // Si solo es el actual filtramos
        lrParte.SETRECFILTER;

      wVentana.OPEN(Text0021);
      wVentana.INPUT(1, lw_preciomanual);
      wVentana.CLOSE;

      IF lw_preciomanual=0 THEN
        IF NOT CONFIRM(Text0026) THEN
          EXIT;

      CLEAR(lrTOPar);
      IF lrParte.FINDSET(TRUE) THEN BEGIN
        lwTotal := lrParte.COUNT;
        CLEAR(lwCont);
        lwVentana2.OPEN(Text0023);
        REPEAT
          IF prParte.Cliente <> lrParte.Cliente THEN
            ERROR(Text0025);
          lwCont +=1;
          lwVentana2.UPDATE(1,lrParte."N§ Parte");
          lwVentana2.UPDATE(2,STRSUBSTNO(Text0024,lwCont,lwTotal));
          lrTOPar.SETRANGE("N§ Parte" , lrParte."N§ Parte");
          // Si hay varios touroperadores dividimos la cantidad equitativamente
          IF lrTOPar.FINDSET(TRUE) THEN BEGIN
            CLEAR(lwCont2);
            lwTotal2 := lrTOPar.COUNT;
            lwImporte := ROUND(lw_preciomanual / lwTotal2);
            lwDif := lw_preciomanual;
            REPEAT
              // Si hay alguna diferencia por redondeo la aplicamos al £ltimo
              lwCont2+=1;
              IF lwCont2 = lwTotal2 THEN BEGIN
                IF lwDif <> lwImporte THEN
                  lwImporte := lwDif;
              END
              ELSE
                lwDif -= lwImporte;

              // Guardamos el precio anterior
              lwValorAnt := lrTOPar."Precio manual venta";
              IF lwValorAnt=0 THEN BEGIN
                lwValorAnt := lrTOPar.TotalIngresoDL;
              END;
              lrTOPar.VALIDATE("Ingreso Anterior" , lwValorAnt);

              // No validamos el campo para que no pida si incluir maletas. A¤adimos funciones necesarias
              lrTOPar."Precio manual venta" := lwImporte;
              lrTOPar.VALIDATE("Cod. Divisa venta");
              IF lwImporte <> 0 THEN
                lrTOPar."Ingreso Precios Por" := lrTOPar."Ingreso Precios Por"::"Zona mas alejada"
              ELSE
                lrTOPar."Ingreso Precios Por" := lrTOPar."Ingreso Precios Por"::"Cada zona";
              lrHist.inserta_registro(lrHist."Tipo Fichero"::Parte, lrParte."N§ Parte", 0, lrTOPar.FIELDCAPTION("Precio manual venta"),
                                     FORMAT(lrTOPar."Ingreso Anterior"), FORMAT(lrTOPar."Precio manual venta"));

              lrTOPar.MODIFY;
            UNTIL lrTOPar.NEXT=0;
          END;

          IF lrParte.Confirmado THEN BEGIN
            desconfirmar_partes(lrParte   , FALSE,'',3); // Necesario para las anulaciones
            confirmar_partes   (lrParte   , FALSE,'',3);
          END;
          lwVentana2.UPDATE(3, ROUND(lwCont/lwTotal*10000,1));
        UNTIL lrParte.NEXT=0;
        lwVentana2.CLOSE;
      END;
    END;

    PROCEDURE ActualizarTTOOPrincipal@1103355000(VAR prParte@1103355000 : Record 7010360);
    VAR
      lrToParte@1103355001 : Record 7010365;
      lrCliTO@1103355004 : Record 7010313;
      lwTTOOPrincipal@1103355002 : Code[10];
      lwPaxes@1103355003 : Decimal;
    BEGIN
      // ActualizarTTOOPrincipal

      lwPaxes         := 0;
      lwTTOOPrincipal := prParte."Touroperador principal";

      lrToParte.SETRANGE("N§ Parte", prParte."N§ Parte");

      IF lrToParte.FINDSET THEN BEGIN
        REPEAT

          IF lrToParte."Pax Transportados" > lwPaxes THEN BEGIN
            IF lrCliTO.GET(prParte.Cliente, lrToParte.Touroperador) THEN BEGIN
              lwPaxes         := lrToParte."Pax Transportados";
              lwTTOOPrincipal := lrToParte.Touroperador;
            END;
          END;

        UNTIL lrToParte.NEXT = 0;
      END;

      IF prParte."Touroperador principal" <> lwTTOOPrincipal THEN BEGIN

        lrCliTO.GET(prParte.Cliente, lwTTOOPrincipal);

        // No se puede validar ya que actualiza el TTOO de las l¡neas del parte.
        prParte."Touroperador principal" := lwTTOOPrincipal;
        prParte.VALIDATE("Ingreso Precios por", lrCliTO."Precios por");

      END;
    END;

    PROCEDURE CrearParte@1103355013(VAR prParteTMP@1103355000 : TEMPORARY Record 7010360;VAR prLinsParteTMP@1103355003 : TEMPORARY Record 7010359;pwCreacion@1103355001 : Integer;VAR prParteNuevo@1103355002 : Record 7010360);
    BEGIN
      // CrearParte

      IF pwCreacion IN [wCreacion::Servicio, wCreacion::ImpUEX, wCreacion::Regulares, wCreacion::Grupos] THEN
        CrearParteValidado(prParteTMP, prLinsParteTMP, pwCreacion, prParteNuevo)
      ELSE
        CrearParteRapido(prParteTMP, prLinsParteTMP, pwCreacion, prParteNuevo);
    END;

    LOCAL PROCEDURE CrearParteValidado@1103355002(VAR prParteTMP@1103355001 : TEMPORARY Record 7010360;VAR prLinsParteTMP@1103355004 : TEMPORARY Record 7010359;pwCreacion@1103355000 : Integer;VAR prNuevoParte@1103355002 : Record 7010360);
    VAR
      lrParte@1103355003 : Record 7010360;
    BEGIN
      // CrearParteValidado

      IF NOT lrParte.GET(prParteTMP."N§ Parte") THEN BEGIN
        lrParte."N§ Parte" := prParteTMP."N§ Parte";
        lrParte.INSERT(TRUE);
      END;

      lrParte.VALIDATE(Garaje, prParteTMP.Garaje);
      IF pwCreacion IN [wCreacion::ImpUEX] THEN BEGIN
        // Si el parte de trabajo tiene rellenado el conductor solo vamos a cambiar la fecha de facturacion del parte
        IF lrParte."Cod Conductor" <> '' THEN
          lrParte.VALIDATE("Fecha facturacion", prParteTMP."Fecha facturacion")
        ELSE
          lrParte.VALIDATE(Fecha              , prParteTMP.Fecha);
      END;

      lrParte.VALIDATE(Fecha, prParteTMP.Fecha);

      lrParte.VALIDATE(Cliente, prParteTMP.Cliente);
      lrParte.VALIDATE("Codigo Servicio", prParteTMP."Codigo Servicio");

      IF pwCreacion IN [wCreacion::ImpUEX, wCreacion::Servicio] THEN BEGIN
        lrParte.VALIDATE("Tipo Servicio", prParteTMP."Tipo Servicio");
        lrParte.VALIDATE(Agrupacion, prParteTMP.Agrupacion);
      END;

      IF pwCreacion IN [wCreacion::ImpUEX, wCreacion::Regulares] THEN
        lrParte.VALIDATE(Touroperadores, prParteTMP.Touroperadores);

      IF pwCreacion IN [wCreacion::Regulares, wCreacion::Servicio] THEN
        lrParte.VALIDATE(Referencia, prParteTMP.Referencia);

      IF pwCreacion IN [wCreacion::Servicio] THEN BEGIN
        lrParte.VALIDATE(Letreros, prParteTMP.Letreros);
        lrParte."Imprimir Letreros" := prParteTMP."Imprimir Letreros";
      END;

      lrParte.VALIDATE("Touroperador principal", prParteTMP."Touroperador principal");

      IF pwCreacion IN [wCreacion::Servicio, wCreacion::ImpUEX] THEN
        lrParte.VALIDATE("Hora 1er Vuelo", prParteTMP."Hora 1er Vuelo");

      lrParte.VALIDATE("Hora inicio", prParteTMP."Hora inicio");

      IF pwCreacion IN [wCreacion::Servicio] THEN BEGIN
        lrParte.VALIDATE("Hora final", prParteTMP."Hora final");
      END;

      lrParte."Cod Grupo" := prParteTMP."Cod Grupo";
      lrParte.VALIDATE("Origen/Destino", prParteTMP."Origen/Destino");
      lrParte.VALIDATE(Guia, prParteTMP.Guia);

      IF pwCreacion IN [wCreacion::ImpUEX] THEN
        lrParte.VALIDATE("Tipo Vehiculo facturacion", prParteTMP."Tipo Vehiculo facturacion");

      //-$007IF pwCreacion IN [wCreacion::Regulares, wCreacion::Servicio] THEN
        lrParte.VALIDATE(Presentacion, prParteTMP.Presentacion);

      IF pwCreacion IN [wCreacion::Servicio] THEN
        lrParte.VALIDATE(Finalizacion, prParteTMP.Finalizacion);


      IF pwCreacion IN [wCreacion::Regulares] THEN BEGIN
        lrParte."No Servicio Regular" := prParteTMP."No Servicio Regular";
        lrParte.VALIDATE("Calcular maletas", prParteTMP."Calcular maletas");
        lrParte.VALIDATE("Peticion Servicio Cliente", prParteTMP."Peticion Servicio Cliente");
      END;

      IF pwCreacion IN [wCreacion::ImpUEX] THEN BEGIN
        lrParte.VALIDATE(Vuelos, prParteTMP.Vuelos);
        lrParte.Facturable    := prParteTMP.Facturable;
        lrParte.Gratuito      := prParteTMP.Gratuito;
        lrParte.Bono          := prParteTMP.Bono;
        lrParte."No Exportar" := prParteTMP."No Exportar";
      END;

      lrParte."Adultos trans. soporte" := prParteTMP."Adultos trans. soporte";
      lrParte."Ni¤os trans. soporte"   := prParteTMP."Ni¤os trans. soporte";
      lrParte."Origen creacion"        := prParteTMP."Origen creacion";
      lrParte.Usuario                  := prParteTMP.Usuario;

      IF pwCreacion IN [wCreacion::Regulares, wCreacion::Servicio] THEN BEGIN
        lrParte."Vehiculo Escolar"       := prParteTMP."Vehiculo Escolar";
        lrParte."Vehiculo Minusvalidos"  := prParteTMP."Vehiculo Minusvalidos";
      END;

      IF pwCreacion IN [wCreacion::Regulares] THEN BEGIN
        lrParte."Vehiculo especial"      := prParteTMP."Vehiculo especial";
        lrParte."Cod Conductor"          := prParteTMP."Cod Conductor";
        lrParte.Conductor                := prParteTMP.Conductor;
        lrParte.Vehiculo                 := prParteTMP.Vehiculo;
        lrParte.VALIDATE("Tipo Vehiculo facturacion", prParteTMP."Tipo Vehiculo facturacion");
        lrParte."Vehiculo Agregado"      := prParteTMP."Vehiculo Agregado";
        lrParte.Proveedor                := prParteTMP.Proveedor;
      END;

      lrParte.Observaciones            := prParteTMP.Observaciones;

      lrParte.MODIFY(TRUE);

      prLinsParteTMP.RESET;
      IF prLinsParteTMP.FINDSET THEN BEGIN
        REPEAT
          CrearLineasParteValidado(prLinsParteTMP, pwCreacion, lrParte);
        UNTIL prLinsParteTMP.NEXT = 0;
      END;

      prNuevoParte.COPY(lrParte);
    END;

    LOCAL PROCEDURE CrearLineasParteValidado@1103355001(VAR prLinsParteTMP@1103355001 : TEMPORARY Record 7010359;pwCreacion@1103355000 : Integer;prParteNuevo@1103355002 : Record 7010360);
    VAR
      lrLinsParte@1103355003 : Record 7010359;
    BEGIN
      // CrearLineasParteValidado

      IF pwCreacion IN [wCreacion::Servicio] THEN
        EXIT;

      lrLinsParte.VALIDATE("N§ Linea",    prLinsParteTMP."N§ Linea");
      lrLinsParte.VALIDATE("N§ Servicio", prLinsParteTMP."N§ Servicio");

      IF NOT (pwCreacion IN [wCreacion::Regulares]) THEN
        lrLinsParte.INSERT(TRUE);

      lrLinsParte.VALIDATE("Punto recogida", prLinsParteTMP."Punto recogida");

      IF pwCreacion IN [wCreacion::Regulares] THEN BEGIN
        lrLinsParte.VALIDATE("Descripcion Punto Recogida", prLinsParteTMP."Descripcion Punto Recogida");
        lrLinsParte.VALIDATE("Adultos transportados"     , prLinsParteTMP."Adultos transportados");
        lrLinsParte.VALIDATE("Ni¤os transportados"       , prLinsParteTMP."Ni¤os transportados");
        lrLinsParte.VALIDATE("Adultos invitados ingreso" , prLinsParteTMP."Adultos invitados ingreso");
        lrLinsParte.VALIDATE("Ni¤os invitados ingreso"   , prLinsParteTMP."Ni¤os invitados ingreso");
        lrLinsParte.es_alta(TRUE);
        lrLinsParte.INSERT(TRUE);
      END;

      lrLinsParte.VALIDATE(Touroperador, prLinsParteTMP.Touroperador);
      lrLinsParte.VALIDATE("N§ Parte", prParteNuevo."N§ Parte");

      IF pwCreacion IN [wCreacion::ImpUEX] THEN
      BEGIN
        lrLinsParte."Permite Borrar" := TRUE;
        lrLinsParte.VALIDATE("Adultos transportados"     , prLinsParteTMP."Adultos transportados");
        lrLinsParte.VALIDATE("Ni¤os transportados"       , prLinsParteTMP."Ni¤os transportados");
        lrLinsParte."Permite Borrar" := FALSE;
        lrLinsParte.VALIDATE("Orden Hotel en zona", prLinsParteTMP."Orden Hotel en zona");
      END;

      IF pwCreacion IN [wCreacion::Regulares] THEN BEGIN
        lrLinsParte.VALIDATE("Codigo Servicio", prLinsParteTMP."Codigo Servicio");
        lrLinsParte.VALIDATE(Vehiculo, prLinsParteTMP.Vehiculo);
        lrLinsParte.VALIDATE("Imprimir Documento Descriptivo", prLinsParteTMP."Imprimir Documento Descriptivo");
        lrLinsParte.es_alta(FALSE);
      END;

      lrLinsParte.VALIDATE("Hora recogida", prLinsParteTMP."Hora recogida");

      IF pwCreacion IN [wCreacion::ImpUEX] THEN
        lrLinsParte.VALIDATE("Orden Hotel en zona", prLinsParteTMP."Orden Hotel en zona");

      lrLinsParte.Observaciones    := prLinsParteTMP.Observaciones;
      lrLinsParte."Nombre Cliente" := prLinsParteTMP."Nombre Cliente";

      //lrLinsParte.mantener_touroperador_parte(prParteNuevo);
      lrLinsParte.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CrearParteRapido@1103355003(VAR prParteTMP@1103355001 : TEMPORARY Record 7010360;VAR prLinsParteTMP@1103355003 : TEMPORARY Record 7010359;pwCreacion@1103355000 : Integer;VAR prNuevoParte@1103355002 : Record 7010360);
    VAR
      lrParte@1103355004 : Record 7010360;
      lrPar@1103355005 : Record 7010311;
    BEGIN
      // CrearParteRapido

      IF NOT lrParte.GET(prParteTMP."N§ Parte") THEN BEGIN
        lrParte."N§ Parte"                     := prParteTMP."N§ Parte";
        IF pwCreacion IN [wCreacion::Shuttle] THEN  BEGIN
          lrParte.Fecha                        := prParteTMP.Fecha;
          lrParte.Cliente                      := prParteTMP.Cliente;
          lrParte."Busca precio ingreso"       := prParteTMP."Busca precio ingreso";
          lrParte."Codigo Servicio"            := prParteTMP."Codigo Servicio";
          lrParte."Tipo Servicio"              := prParteTMP."Tipo Servicio";
          lrParte."Origen creacion"            := prParteTMP."Origen creacion";
        END;
        lrParte.INSERT(TRUE);
      END;

      lrParte.Garaje                           := prParteTMP.Garaje;

      IF NOT (pwCreacion IN [wCreacion::Shuttle]) THEN  BEGIN
        lrParte.Fecha                          := prParteTMP.Fecha;
        lrParte.Cliente                        := prParteTMP.Cliente;
        lrParte."Busca precio ingreso"         := prParteTMP."Busca precio ingreso";
        lrParte."Codigo Servicio"              := prParteTMP."Codigo Servicio";
        lrParte."Tipo Servicio"                := prParteTMP."Tipo Servicio";
        lrParte."Origen creacion"              := prParteTMP."Origen creacion";
        lrParte."Origen/Destino"               := prParteTMP."Origen/Destino";
        lrParte.Presentacion                   := prParteTMP.Presentacion;
        lrParte."Ingreso Precios por"          := prParteTMP."Ingreso Precios por";
      END;

      lrParte."Fecha facturacion"              := prParteTMP."Fecha facturacion";
      lrParte."Calcular maletas"               := prParteTMP."Calcular maletas";
      lrParte.Observaciones                    := prParteTMP.Observaciones;
      lrParte.Guia                             := prParteTMP.Guia;
      lrParte."Touroperador principal"         := prParteTMP."Touroperador principal";
      lrParte."Busca precio pasaje x zona ing" := prParteTMP."Busca precio pasaje x zona ing";
      lrParte.Gestor                           := prParteTMP.Gestor;
      lrParte."Hora 1er Vuelo"                 := prParteTMP."Hora 1er Vuelo";

      lrParte."Hora inicio"                    := prParteTMP."Hora inicio";


      IF pwCreacion IN [wCreacion::Shuttle] THEN BEGIN
        lrParte."Zona parte"   := prParteTMP."Zona parte";
        lrParte."Zona trabajo" := prParteTMP."Zona trabajo";
      END;

      IF lrPar."Empresa Real" = lrPar."Empresa Real"::IBZ THEN BEGIN
        IF lrPar."Codigo Entradas" = prParteTMP."Codigo Servicio" THEN
          lrParte.VALIDATE("Hora inicio"    , prParteTMP."Hora 1er Vuelo");
      END;

      lrParte.ActualizaHoraDT;
      lrParte."Hora final"                     := prParteTMP."Hora final";
      lrParte.Referencia                       := prParteTMP.Referencia;
      lrParte.Letreros                         := prParteTMP.Letreros;
      lrParte.Vuelos                           := prParteTMP.Vuelos;
      lrParte."Adultos trans. soporte"         := prParteTMP."Adultos trans. soporte";
      lrParte."Ni¤os trans. soporte"           := prParteTMP."Ni¤os trans. soporte";
      lrParte."Paxes Previstos"                := prParteTMP."Paxes Previstos";
      lrParte.Usuario                          := prParteTMP.Usuario;

      lrParte."Asignacion rapida" := TRUE; // Esto es para evitar comprobaciones innecesarias

      IF prParteTMP.Vehiculo <> '' THEN
        lrParte.VALIDATE(Vehiculo       , prParteTMP.Vehiculo);

      IF prParteTMP."Cod Conductor" <> '' THEN
        lrParte.VALIDATE("Cod Conductor", prParteTMP."Cod Conductor");

      lrParte."Asignacion rapida" := FALSE;

      lrParte.MantenVersion(TRUE); // Mantiene la versi¢n de impresion
      lrParte.MantenNoExp(TRUE);  // Mantiene el campo "No Exportacion Prov"

      lrParte.MODIFY;

      prLinsParteTMP.RESET;
      IF prLinsParteTMP.FINDSET THEN BEGIN
        REPEAT
          CrearLineasParteRapido(prLinsParteTMP, pwCreacion, lrParte);
        UNTIL prLinsParteTMP.NEXT = 0;
      END;

      prNuevoParte.COPY(lrParte);
    END;

    LOCAL PROCEDURE CrearLineasParteRapido@1103355004(VAR prLinsParteTMP@1103355001 : TEMPORARY Record 7010359;pwCreacion@1103355000 : Integer;VAR prParteNuevo@1103355003 : Record 7010360);
    VAR
      lrLinParte@1103355002 : Record 7010359;
    BEGIN
      // CrearLineasParteRapido

      lrLinParte."N§ Linea"                       := prLinsParteTMP."N§ Linea";
      lrLinParte."N§ Servicio"                    := prLinsParteTMP."N§ Servicio";
      lrLinParte.INSERT;

      lrLinParte."N§ Parte"                       := prParteNuevo."N§ Parte";
      lrLinParte."Origen creacion"                := prLinsParteTMP."Origen creacion";
      lrLinParte."Punto recogida"                 := prLinsParteTMP."Punto recogida";
      lrLinParte."Zona fisica"                    := prLinsParteTMP."Zona fisica";
      lrLinParte."Orden zona"                     := prLinsParteTMP."Orden zona";
      lrLinParte."Orden Hotel en zona"            := prLinsParteTMP."Orden Hotel en zona";
      lrLinParte."Imprimir Documento Descriptivo" := prLinsParteTMP."Imprimir Documento Descriptivo";
      lrLinParte."Descripcion Punto Recogida"     := prLinsParteTMP."Descripcion Punto Recogida";
      lrLinParte.Fecha                            := prLinsParteTMP.Fecha;

      // JPT 02/02/10 Datetime a Biginteger. Validamos campos para asignar BI
      IF pwCreacion IN [wCreacion::ImpShuttle] THEN BEGIN
          // lrLinParte."FechaHora Vuelo"            := prLinsParteTMP."FechaHora Vuelo";
          // lrLinParte."FechaHora Parte"            := prLinsParteTMP."FechaHora Parte";
          lrLinParte.VALIDATE("FechaHora Vuelo" , prLinsParteTMP."FechaHora Vuelo");
          lrLinParte.VALIDATE("FechaHora Parte" , prLinsParteTMP."FechaHora Parte");
      END;

      lrLinParte.Touroperador                     := prLinsParteTMP.Touroperador;
      lrLinParte."Codigo Servicio"                := prLinsParteTMP."Codigo Servicio";
      lrLinParte."Tipo Servicio"                  := prLinsParteTMP."Tipo Servicio";
      lrLinParte."Adultos transportados"          := prLinsParteTMP."Adultos transportados";
      lrLinParte."Ni¤os transportados"            := prLinsParteTMP."Ni¤os transportados";
      lrLinParte."Paxes transportados"            := prLinsParteTMP."Paxes transportados";
      lrLinParte."Adultos invitados ingreso"      := prLinsParteTMP."Adultos invitados ingreso";
      lrLinParte."Ni¤os invitados ingreso"        := prLinsParteTMP."Ni¤os invitados ingreso";
      lrLinParte."Hora recogida"                  := prLinsParteTMP."Hora recogida";
      lrLinParte.Observaciones                    := prLinsParteTMP.Observaciones;
      lrLinParte.IATA                             := prLinsParteTMP.IATA;
      IF prLinsParteTMP.Letra <> '' THEN
        lrLinParte.VALIDATE(Letra, prLinsParteTMP.Letra);
      lrLinParte."Nombre Cliente"                 := prLinsParteTMP."Nombre Cliente";
      lrLinParte.Reserva                          := prLinsParteTMP.Reserva;
      lrLinParte."Suplemento Rapido 1"            := prLinsParteTMP."Suplemento Rapido 1";
      lrLinParte."Suplemento Rapido 2"            := prLinsParteTMP."Suplemento Rapido 2";
      lrLinParte.Vuelo                            := prLinsParteTMP.Vuelo;
      lrLinParte."Hora Vuelo"                     := prLinsParteTMP."Hora Vuelo";
      lrLinParte.IATA                             := prLinsParteTMP.IATA;

      lrLinParte.MODIFY;
    END;

    PROCEDURE TipoParteImportacionTRN@1103355005() : Integer;
    BEGIN
      // TipoParteImportacionTRN

      EXIT(wCreacion::ImpTRN);
    END;

    PROCEDURE TipoParteImportacionUEX@1103355006() : Integer;
    BEGIN
      // TipoParteImportacionUEX

      EXIT(wCreacion::ImpUEX);
    END;

    PROCEDURE TipoParteServicio@1103355007() : Integer;
    BEGIN
      // TipoParteServicio

      EXIT(wCreacion::Servicio);
    END;

    PROCEDURE TipoParteGrupos@1103355008() : Integer;
    BEGIN
      // TipoParteGrupos

      EXIT(wCreacion::Grupos);
    END;

    PROCEDURE TipoParteServiciosRegulares@1103355009() : Integer;
    BEGIN
      // TipoParteServiciosRegulares

      EXIT(wCreacion::Regulares);
    END;

    PROCEDURE TipoParteShuttle@1103355010() : Integer;
    BEGIN
      // TipoParteShuttle

      EXIT(wCreacion::Shuttle);
    END;

    PROCEDURE TipoParteImportacionShuttle@1103355011() : Integer;
    BEGIN
      // TipoParteImportacionShuttle

      EXIT(wCreacion::ImpShuttle);
    END;

    PROCEDURE ExportaParte@1103355012(VAR prParte@1103355000 : Record 7010360);
    VAR
      lrLinsParte@1103355001 : Record 7010359;
      lrSuplParte@1103355002 : Record 7010363;
      lrExtrasParte@1103355003 : Record 7010362;
      lrToParte@1103355004 : Record 7010365;
      lrVuelosParte@1103355005 : Record 7035335;
      lrRecRef@1103355006 : RecordRef;
      lwFile@1103355007 : File;
      lwChar@1103355008 : Char;
    BEGIN
      // ExportaParte

      lwFile.WRITEMODE(TRUE);
      lwFile.TEXTMODE(TRUE);
      lwFile.CREATE(Text50063 + prParte."N§ Parte" + Text50064);

      lwFile.WRITE(prParte);

      lrLinsParte.RESET;
      lrLinsParte.SETCURRENTKEY("N§ Parte", "N§ Linea");
      lrLinsParte.SETRANGE("N§ Parte", prParte."N§ Parte");

      IF lrLinsParte.FINDSET THEN BEGIN
        REPEAT
          lwFile.WRITE(lrLinsParte);
        UNTIL lrLinsParte.NEXT = 0;
      END;

      lrSuplParte.RESET;
      lrSuplParte.SETRANGE("N§ Parte", prParte."N§ Parte");

      IF lrSuplParte.FINDSET THEN BEGIN
        REPEAT
          lwFile.WRITE(lrSuplParte);
        UNTIL lrSuplParte.NEXT = 0;
      END;

      lrExtrasParte.RESET;
      lrExtrasParte.SETRANGE("N§ Parte", prParte."N§ Parte");

      IF lrExtrasParte.FINDSET THEN BEGIN
        REPEAT
          lwFile.WRITE(lrExtrasParte);
        UNTIL lrExtrasParte.NEXT = 0;
      END;

      lrToParte.RESET;
      lrToParte.SETRANGE("N§ Parte", prParte."N§ Parte");

      IF lrToParte.FINDSET THEN BEGIN
        REPEAT
          lwFile.WRITE(lrToParte);
        UNTIL lrToParte.NEXT = 0;
      END;

      lrVuelosParte.RESET;
      lrVuelosParte.SETRANGE("N§Parte", prParte."N§ Parte");

      IF lrVuelosParte.FINDSET THEN BEGIN
        REPEAT
          lwFile.WRITE(lrVuelosParte);
        UNTIL lrVuelosParte.NEXT = 0;
      END;

      lwFile.CLOSE;
    END;

    PROCEDURE AddModificaciones@1103355027(pwParte@1103355001 : Code[10];pwTipo@1103355000 : 'Ingreso,Coste');
    VAR
      lrMod@1103355002 : Record 7035330;
      lrMod2@1103355003 : Record 7035330;
      lrProdI@1103355004 : Record 7035392;
      lrProdC@1103355006 : Record 7035393;
      lrRec@1103355005 : RecordRef;
    BEGIN
      // AddModificaciones

      // JPT 03/12/08
      CLEAR(lrMod);
      lrMod.SETCURRENTKEY("N§ Parte","N§ Linea",Tipo,"No Campo");
      lrMod.SETRANGE("N§ Parte", pwParte);
      lrMod.SETRANGE("N§ Linea", 0);
      lrMod.SETRANGE(Tipo , pwTipo);
      IF lrMod.FINDSET THEN BEGIN
        REPEAT
          CASE pwTipo OF
            pwTipo::Ingreso: BEGIN
              CLEAR(lrProdI);
              lrProdI.SETCURRENTKEY("N§ Parte",Touroperador,"Tipo linea","Linea abono","Tipo elemento");
              lrProdI.SETRANGE("N§ Parte"     , lrMod."N§ Parte");
              lrProdI.SETRANGE(Touroperador   , lrMod.Touroperador);
              lrProdI.SETRANGE("Tipo linea"   , lrMod."Tipo linea");
              lrProdI.SETRANGE("Linea abono"  , lrMod."Linea abono");
              lrProdI.SETRANGE("Tipo elemento", lrMod."Tipo elemento");
              IF lrProdI.FINDSET THEN BEGIN
                lrRec.GETTABLE(lrProdI);
                lrMod2 := lrMod;
                lrMod2."N§ Linea" := lrProdI."N§ Linea";
                lrMod2.MarcaValor(lrRec, FALSE, FALSE);
              END;
            END;
            pwTipo::Coste: BEGIN
              CLEAR(lrProdC);
              lrProdC.SETCURRENTKEY("N§ Parte",Touroperador,"Tipo linea","Linea abono","Tipo elemento");
              lrProdC.SETRANGE("N§ Parte"     , lrMod."N§ Parte");
              lrProdC.SETRANGE(Touroperador   , lrMod.Touroperador);
              lrProdC.SETRANGE("Tipo linea"   , lrMod."Tipo linea");
              lrProdC.SETRANGE("Linea abono"  , lrMod."Linea abono");
              lrProdC.SETRANGE("Tipo elemento", lrMod."Tipo elemento");
              IF lrProdC.FINDSET THEN BEGIN
                lrRec.GETTABLE(lrProdC);
                lrMod2 := lrMod;
                lrMod2."N§ Linea" := lrProdC."N§ Linea";
                lrMod2.MarcaValor(lrRec, FALSE, FALSE);
              END;
            END;

          END;
        UNTIL lrMod.NEXT=0;
      END;
    END;

    PROCEDURE DelModificaciones@1103355017(pwParte@1103355001 : Code[10];pwTipo@1103355000 : 'Ingreso,Coste');
    VAR
      lrMod@1103355002 : Record 7035330;
      lrMod2@1103355003 : Record 7035330;
    BEGIN
      // DelModificaciones
      // Borra todas las modificaciones ligadas a este parte

      // JPT 03/12/08
      CLEAR(lrMod);
      lrMod.SETCURRENTKEY("N§ Parte","N§ Linea",Tipo,"No Campo");
      lrMod.SETRANGE("N§ Parte", pwParte);
      lrMod.SETRANGE(Tipo      , pwTipo);
      lrMod.DELETEALL;
    END;

    PROCEDURE DesMModificaciones@1103355019(pwParte@1103355001 : Code[10];pwTipo@1103355000 : 'Ingreso,Coste');
    VAR
      lrMod@1103355002 : Record 7035330;
      lrMod2@1103355003 : Record 7035330;
    BEGIN
      // DesMModificaciones
      // Desmarca todas las modificaciones ligadas a este parte

      // JPT 03/12/08
      CLEAR(lrMod);
      lrMod.SETCURRENTKEY("N§ Parte","N§ Linea",Tipo,"No Campo");
      lrMod.SETRANGE("N§ Parte", pwParte);
      lrMod.SETRANGE(Tipo      , pwTipo);
      lrMod.MODIFYALL("N§ Linea", 0);
    END;

    PROCEDURE RecalculaTTOOParte@1103355014(VAR prParte@1103355000 : Record 7010360);
    VAR
      lrVeh@1103355001 : Record 7010346;
      lrTOPar@1103355002 : Record 7010365;
      lrTOPar2@1103355003 : Record 7010365;
      lrSerPar@1103355004 : Record 7010359;
      lwAdultos@1103355005 : ARRAY [3] OF Decimal;
      lwNi¤os@1103355006 : ARRAY [3] OF Decimal;
      lwTouroperadores@1103355007 : Text[60];
    BEGIN
      // RecalculaTTOOParte
      // JPT 24/08/09
      // Volvemos a calcular  los paxes en Touroperador x parte a partir de las l¡neas
      // Servicios-Partes para asegurarnos de que no existe ning£n error
      // Las variables lwAdultos y lwNi¤os tienes tres dimensiones: 1:Trasportados
      // 2: invitados ingreso y 3: invitados coste
      // Insertamos el campo Touroperadores en Parte

      CLEAR(lrTOPar);
      lrSerPar.RESET;
      lrSerPar.SETCURRENTKEY("N§ Parte",Touroperador,"Hora recogida");
      lrSerPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF lrSerPar.FINDSET THEN BEGIN
        REPEAT // Nos aseguramos que no falta ning£n touroperador
          IF NOT lrTOPar.GET(prParte."N§ Parte", lrSerPar.Touroperador) THEN BEGIN
            CLEAR(lrTOPar);
            lrTOPar."N§ Parte"   := prParte."N§ Parte";
            lrTOPar.Touroperador := lrSerPar.Touroperador;

            //+$001
            lrTOPar."N§ Viajes"         := prParte."N§ viajes";
            lrTOPar."Cliente operativo" := prParte.Cliente;
            lrTOPar."Cliente estadistico" := prParte.GetClienteEstadistico(lrSerPar.Touroperador);
            lrTOPar."Tipo Servicio"     := prParte."Tipo Servicio";
            lrTOPar."Codigo Servicio"   := prParte."Codigo Servicio";
            lrTOPar.Garaje              := prParte.Garaje;
            lrTOPar."Fecha Facturacion" := prParte."Fecha facturacion";
            lrTOPar.Confirmado          := prParte.Confirmado;
            //-$001

            lrTOPar.INSERT(TRUE);
          END
          ELSE BEGIN
            // AJF 01/09/10
            lrTOPar."N§ Viajes"           := prParte."N§ viajes";
            lrTOPar."Cliente operativo"   := prParte.Cliente;
            lrTOPar."Cliente estadistico" := prParte.GetClienteEstadistico(lrSerPar.Touroperador);
            lrTOPar."Tipo Servicio"       := prParte."Tipo Servicio";
            lrTOPar."Codigo Servicio"     := prParte."Codigo Servicio";
            lrTOPar.Garaje                := prParte.Garaje;
            lrTOPar."Fecha Facturacion"   := prParte."Fecha facturacion";
            lrTOPar.Confirmado            := prParte.Confirmado;
            lrTOPar.MODIFY;
          END;
        UNTIL lrSerPar.NEXT=0;
      END;

      CLEAR(lwTouroperadores);
      CLEAR(lrTOPar);
      lrTOPar.SETRANGE("N§ Parte", prParte."N§ Parte");

      IF lrTOPar.FINDSET(TRUE) THEN BEGIN
        REPEAT
          lrSerPar.SETRANGE(Touroperador , lrTOPar.Touroperador);
          CLEAR(lwAdultos);
          CLEAR(lwNi¤os);
          IF lrSerPar.FINDSET THEN
            REPEAT
              lwAdultos[1] += lrSerPar."Adultos transportados";
              lwAdultos[2] += lrSerPar."Adultos invitados ingreso";
              lwAdultos[3] += lrSerPar."Adultos invitados coste";

              lwNi¤os[1]   += lrSerPar."Ni¤os transportados";
              lwNi¤os[2]   += lrSerPar."Ni¤os invitados ingreso";
              lwNi¤os[3]   += lrSerPar."Ni¤os invitados coste";
            UNTIL lrSerPar.NEXT = 0;

          lrTOPar.VALIDATE("Adultos transportados"      , lwAdultos[1]);
          lrTOPar.VALIDATE("Adultos invitados ingreso"  , lwAdultos[2]);
          lrTOPar.VALIDATE("Adultos invitados coste"    , lwAdultos[3]);

          lrTOPar.VALIDATE("Ni¤os transportados"        , lwNi¤os[1]);
          lrTOPar.VALIDATE("Ni¤os invitados ingreso"    , lwNi¤os[2]);
          lrTOPar.VALIDATE("Ni¤os invitados coste"      , lwNi¤os[3]);

          // Actualizar tambien este campo que acumula adultos y ni¤os

          lrTOPar.VALIDATE("Pax Transportados"          , lwAdultos[1] + lwNi¤os[1]);

          lrTOPar."Adultos facturados" := 0;
          lrTOPar."Ni¤os facturados"   := 0;

          // Si la referencia esta rellenada se pondra en el campo Bono, si este esta en blanco

          IF prParte.Referencia <> '' THEN BEGIN
            IF lrTOPar.Bono = '' THEN
              lrTOPar.Bono := COPYSTR(prParte.Referencia, 1, 10);
          END;

          // Modificado por la migracion de IBZ

          IF lrVeh.GET(prParte.Vehiculo) THEN BEGIN
            IF NOT lrVeh."Vehiculo propio" THEN
              lrTOPar."Servicio arrendado" := TRUE;
          END;
          lrTOPar.Vehiculo := prParte.Vehiculo;
          lrTOPar.MODIFY;

          IF (lrTOPar."Adultos transportados" + lrTOPar."Ni¤os transportados" ) = 0 THEN BEGIN
            lrTOPar2 := lrTOPar;
            lrTOPar2.DELETE;
          END
          ELSE BEGIN
            IF lwTouroperadores <> '' THEN
              lwTouroperadores := lwTouroperadores + '|';
            lwTouroperadores := lwTouroperadores + lrTOPar.Touroperador;

            // AJF 01/09/10
            // En el caso de las recogidas se tiene que dejar los paxes a 0 para que no alteren las estad¡sticas.
            IF prParte."Origen creacion" = prParte."Origen creacion"::"Recogida Automatica" THEN BEGIN
              lrTOPar."Adultos transportados" := 0;
              lrTOPar."Ni¤os transportados"   := 0;
              lrTOPar."Pax Transportados"     := 0;
              lrTOPar."Adultos facturados"    := 0;
              lrTOPar."Ni¤os facturados"      := 0;
              lrTOPar.MODIFY;
            END;

          END;
        UNTIL lrTOPar.NEXT = 0;
      END;

      prParte.ProratearViajes;
      // Aprovechamos el recorrido para volver a indicar el campo Touroperadores en Parte
      prParte.VALIDATE(Touroperadores , lwTouroperadores);
    END;

    PROCEDURE GetClienteEstadistico@1100253001(pwCliente@1100253000 : Code[20];pwTO@1100253001 : Code[10]) rvCliEst : Code[20];
    VAR
      lrCLiTo@1100253002 : Record 7010313;
    BEGIN
      // GetClienteEstadistico.

      CLEAR(lrCLiTo);
      lrCLiTo.SETRANGE (Cliente, pwCliente);
      lrCLiTo.SETRANGE (TTOO   , pwTO);
      IF lrCLiTo.FIND('-') THEN BEGIN
        CASE lrCLiTo."Cliente mostrar estadisticas" OF
          lrCLiTo."Cliente mostrar estadisticas"::Operativo  : EXIT(lrCLiTo.Cliente);
          lrCLiTo."Cliente mostrar estadisticas"::Facturacion: EXIT(lrCLiTo."Cliente facturacion");
        END;
      END;
    END;

    PROCEDURE CreaDetalleAsientoCoste@1000000001();
    BEGIN
    END;

    EVENT XML@1100244030::ondataavailable@198();
    BEGIN
    END;

    EVENT XML@1100244030::onreadystatechange@-609();
    BEGIN
    END;

    BEGIN
    {
      JPT 02/02/10 Datetime a Biginteger

      $001 AJS 08072010 En la funcion RecalculaTTOOParte hay que actualizar los campos que provienen de parte de trabajo para asegurar
                        la coherencia entre los datos de ambas tablas.

      $002 ARM 12112014 INV-OC-14039 Rellenar la tabla de detalle de asientos contables

      $003 AJS 18122014 Corregir error de clave en funcion crear_prevision_ingreso_parte

      $004 AJS 27012015 Modifico la funci¢n BuscaNoReport para que trabaje sobre la tabla objeto

      $005 AJS 12022015 Dejamos de utilizar el campo Host SMTP

      $006 AJS 18052015 Modifico la funcion buscar_en_partes para que la ventana permanezca por 6 segundos

      $007 AJS 18062015 Modifico la funcion CrearParteValidado para que siempre rellene Presentacion
    }
    END.
  }
}
