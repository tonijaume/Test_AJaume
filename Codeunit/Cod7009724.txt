OBJECT Codeunit 7009724 Funciones Cierre Llegada Hotel
{
  OBJECT-PROPERTIES
  {
    Date=09/02/15;
    Time=22:53:33;
    Modified=Yes;
    Version List=AIC2009;
  }
  PROPERTIES
  {
    OnRun=VAR
            lrResH@1100253000 : Record 7009743;
            lfForm@1100253001 : Form 7009857;
          BEGIN
            CLEAR(lrResH);
            lrResH.SETCURRENTKEY("Pendiente calculo", "Fecha entrada", "TourOperador Venta", Responsable, "Pendiente asignar", Bono);
            lrResH.FILTERGROUP(2);
            lrResH.SETRANGE(Responsable        , TRUE);
            lrResH.SETRANGE("Pendiente calculo", TRUE);
            lrResH.SETRANGE("Pendiente asignar", FALSE);
            lrResH.FILTERGROUP(0);

            lfForm.SETTABLEVIEW(lrResH);
            lfForm.RUN;
          END;

  }
  CODE
  {
    VAR
      Text000@1103355042 : TextConst 'ENU=Company data file does not exist;ESP=No Existe fichero de datos de empresa';
      Text001@1103355043 : TextConst 'ENU=Another user is executing the arrivals closure \;ESP=Otro usuario est  ejecutando el cierre de llegadas \';
      Text002@1103355044 : TextConst 'ENU=or the calculation of non-closed. Must wait until \;ESP=o el c lculo de no cerradas. Debe esperar a que \';
      Text003@1103355045 : TextConst 'ENU=it ends in order to start its process.\\;ESP=finalice para iniciar su proceso.\\';
      Text004@1103355046 : TextConst 'ENU=USER ID: %1;ESP=USUARIO ID: %1';
      Text005@1103355047 : TextConst 'ENU=Closing voucher #3######## \;ESP=Cerrando el bono #3######## \';
      Text006@1103355048 : TextConst 'ENU=There are #2#### voucher to be closed\;ESP=Quedan #2#### bonos por cerrar\';
      Text007@1103355049 : TextConst 'ENU=Booking %1 has as destination invoice \;ESP=La reserva %1 tiene como destino factura \';
      Text008@1103355050 : TextConst 'ENU=a hotel "no name". Correct it;ESP=un hotel "no name". Corr¡jalo.';
      Text009@1103355051 : TextConst 'ENU=Any booking has been found;ESP=No se ha encontrado ninguna reserva';
      Text010@1103355052 : TextConst 'ENU=Agency parameters file does not exist;ESP=No existe el fichero parametros de agencia';
      Text011@1103355053 : TextConst 'ENU=GENERATE PAYMENT IN ADVANCE\;ESP=GENERAR PREPAGO\';
      Text012@1103355054 : TextConst 'ENU=TourOperator #1########;ESP=TourOperador #1########';
      Text013@1103355055 : TextConst 'ENU=Would you like to generate payment in advance for touroperator %1;ESP=Desea generar prepago para el touroperador %1';
      Text014@1103355056 : TextConst 'ENU=Touroperator %1 does not exist;ESP=No existe el Touroperador %1.';
      Text015@1103355057 : TextConst 'ENU=This touroperator has 0 days of payment in advance;ESP=Este TourOperador tiene 0 dias de prepago.';
      Text016@1103355058 : TextConst 'ENU=%1D;ESP=%1D';
      Text017@1103355059 : TextConst 'ENU=There are no touroperator %1 bookings for day %2 assigned and remaining of closure;ESP=No hay reservas del touroperador %1 para el dia %2 asignadas y pendientes de cierre.';
      Text018@1103355060 : TextConst 'ENU=Enter the day until you want to close #1######\;ESP=Introduzca el d¡a hasta el que desea cerrar #1######\';
      Text019@1103355061 : TextConst 'ENU=Enter the touroperator                  #2######\;ESP=Introduzca el TourOperador                  #2######\';
      Text020@1103355062 : TextConst 'ENU=Mark bookings as closed               #3;ESP=Marcar reservas como cerradas               #3';
      Text021@1103355063 : TextConst 'ENU=Have indicated closure day before the \;ESP=Ha indicado un d¡a de cierre anterior al \';
      Text022@1103355064 : TextConst 'ENU=last day of filtered range.\\;ESP=£ltimo d¡a de rango filtrado.\\';
      Text023@1103355065 : TextConst 'ENU=Review the ranges and execute \;ESP=Revise los rangos y ejecute \';
      Text024@1103355066 : TextConst 'ENU=the closure again;ESP=otra vez el cierre.';
      Text025@1103355067 : TextConst 'ENU=Correct closure data?\\;ESP=¨Datos de cierre correctos?\\';
      Text026@1103355068 : TextConst 'ENU=Day . . . . . . . . :  %1 \;ESP=Dia . . . . . . . . :  %1 \';
      Text027@1103355069 : TextConst 'ENU=TourOperator:  %2\;ESP=TourOperador:  %2\';
      Text028@1103355070 : TextConst 'ENU=Mark bookings: %3;ESP=Marcar reservas: %3';
      rBo@1103355000 : Record 7010013;
      rBo2@1103355001 : Record 7010013;
      rBono@1103355002 : Record 7010018;
      rBono2@1103355003 : Record 7010018;
      rCnp@1103355004 : Record 7010019;
      rCnp2@1103355005 : Record 7010019;
      rDia@1103355006 : Record 7010020;
      rDia2@1103355007 : Record 7010020;
      rRsv2@1103355008 : Record 7009743;
      rRsv3@1103355009 : Record 7009743;
      rLin@1103355010 : Record 7009736;
      rParAgencia@1103355011 : Record 7009700;
      rCierre@1103355012 : Record 7009778;
      rHotel@1103355013 : Record 7009724;
      fCalculo@1103355071 : Codeunit 7009707;
      cExpHP@1103355081 : Codeunit 7009911;
      cFunSeg@1100217000 : Codeunit 7009751;
      rTempTO@1103355072 : TEMPORARY Record 7009717;
      dia@1103355014 : Date;
      dia2@1103355015 : Date;
      w_sig_numcierre@1103355016 : Integer;
      w_ult_n_orden@1103355017 : Integer;
      w_ant_n_orden@1103355018 : Integer;
      fec_fecha@1103355019 : ARRAY [60] OF Date;
      fec_ci@1103355020 : ARRAY [60] OF Integer;
      fec_importe@1103355021 : ARRAY [60] OF Decimal;
      cnp_concep@1103355022 : ARRAY [60] OF Text[10];
      cnp_ci@1103355023 : ARRAY [60] OF Integer;
      cnp_importe@1103355024 : ARRAY [60] OF Decimal;
      cnp_extra@1103355074 : ARRAY [60] OF Text[10];
      cnp_hf@1100253001 : ARRAY [60] OF Code[10];
      cnp_precio@1100253002 : ARRAY [60] OF Decimal;
      cnp_Cntr@1100253003 : ARRAY [60] OF Code[10];
      ind@1103355025 : Integer;
      rResumenRes@1103355026 : Record 7009771;
      Hoteles@1103355027 : ARRAY [10] OF Code[20];
      CosteHotel@1103355028 : ARRAY [10] OF Decimal;
      CosteHotelAparte@1103355029 : ARRAY [10] OF Decimal;
      IngresoHotel@1103355030 : ARRAY [10] OF Decimal;
      ingresoAnterior@1103355031 : ARRAY [10] OF Decimal;
      tab_secuencias@1103355032 : ARRAY [10] OF Code[10];
      indice@1103355033 : Integer;
      indice_secuencias@1103355034 : Integer;
      ant_cierre@1103355035 : Integer;
      w_sig_n_orden@1103355036 : Integer;
      sw_no_enviado@1103355037 : Boolean;
      dDialog@1103355039 : Dialog;
      NumSecuencia@1103355040 : Code[10];
      aux_secuencia@1103355041 : Integer;
      Text029@1103355073 : TextConst 'ENU=Several;ESP=Varios';
      Text030@1103355038 : TextConst 'ENU=#1##############\@2@@@@@@@@@@@@@@\;ESP=#1##############\@2@@@@@@@@@@@@@@\';
      Text031@1103355075 : TextConst 'ENU=Extra;ESP=Extra';
      Text032@1103355076 : TextConst 'ENU=Booking %1 with voucher %2 has the field Room No. Null;ESP=La reserva %1 con bono %2 tiene el campo N§ Habitaciones a cero.';
      Text033@1103355077 : TextConst 'ENU=Voucher commission;ESP=Comision bono';
      Text034@1103355078 : TextConst 'ENU=Must indicate and account of hotel commission in TO-Local Office accounts.;ESP=Debe indicar una cuenta de comision hotel en Cuentas TO-Delegacion.';
      Text035@1103355079 : TextConst 'ENU=Sale contract %1 - %2 does not exist;ESP=No existe el contrato de venta %1 - %2.';
      Text036@1103355080 : TextConst 'ENU=Accounting diary:;ESP=Diario contabilizacion:';
      Text037@1100253000 : TextConst 'ENU=HANDFEEVEN;ESP=HANDFEEVEN';
      wDiarioGeneral@1100217001 : Code[10];
      Text038@1100217002 : TextConst 'ENU=Unable to close voucher %1 because it has not arrived yet.;ESP=No se puede cerrar el bono %1 porque aun no ha llegado.';
      wAdults@1100217003 : Integer;
      wChilds@1100217004 : Integer;

    PROCEDURE Cierre_llegada_hotel@1(VAR rRsvhotel@1103355000 : Record 7009743;par_dia@1103355001 : Date;par_TTOO@1103355002 : Code[10];par_MarcaReserva@1103355003 : Boolean;pwSelTTOO@1103355004 : Boolean);
    VAR
      lwEnc@1103355005 : Boolean;
    BEGIN
      // Cierre_llegada_hotel
      //
      // Ponemos la marca en "Parametros Agencia" para bloquear el c lculo
      // de reservas.
      // pwSelTTOO indica que hay una selecci¢n de Touroperadores

      rParAgencia.LOCKTABLE;
      rParAgencia.FINDFIRST;

      IF rParAgencia."Ejecutando Cierre" THEN BEGIN
        rCierre.FINDLAST;
        ERROR(Text001 +
              Text002 +
              Text003 +
              Text004, rCierre.Usuario);
      END;
      rParAgencia."Ejecutando Cierre" := TRUE;
      rParAgencia.MODIFY;
      COMMIT;

      // Obtenemos el £ltimo n§ de cierre hotel

      w_sig_numcierre := Hallar_sig_cierre() + 1;
      WITH rCierre DO BEGIN
        INIT;
        Delegacion      := rRsvhotel.Delegacion;
        "N§ Cierre"     := w_sig_numcierre;
        Fecha           := TODAY;
        Hora            := TIME;
        Usuario         := USERID();
        TourOperador    := par_TTOO;
        "Fecha Cerrada" := par_dia;
        INSERT;
      END;

      // Tomamos el registro actual para obtener los filtros

      rRsv3.COPYFILTERS(rRsvhotel);
      rRsv3.SETCURRENTKEY("Pendiente calculo",
                          "Fecha entrada",
                          "TourOperador Venta",
                          Responsable,
                          "Pendiente asignar",
                          Bono);
      rRsv3.SETRANGE("Pendiente calculo", TRUE);
      IF (rRsv3.GETFILTER("Fecha entrada") = '') AND (par_dia <> 0D) THEN
        rRsv3.SETFILTER("Fecha entrada", '<=%1', par_dia);

      rRsv3.SETRANGE(Responsable        , TRUE);
      rRsv3.SETRANGE("Pendiente asignar", FALSE);

      CLEAR(lwEnc);
      IF pwSelTTOO THEN BEGIN
        CLEAR(rTempTO);
        IF rTempTO.FINDSET THEN BEGIN
          REPEAT
            rRsv3.SETRANGE("TourOperador Venta", rTempTO.TourOperador);
            lwEnc := lwEnc OR Cierra(rRsv3, par_MarcaReserva);
          UNTIL rTempTO.NEXT=0;
        END;
      END
      ELSE
        lwEnc := Cierra(rRsv3, par_MarcaReserva);

      IF NOT lwEnc THEN
        ErrorCierre(Text009);

      rRsvhotel.SETRANGE("Fecha entrada");

      // Quitamos la marca en "Parametros Agencia" para desbloquear
      // el c lculo de reservas

      rParAgencia.LOCKTABLE;
      IF NOT rParAgencia.FINDFIRST THEN
        ERROR(Text010);
      rParAgencia."Ejecutando Cierre" := FALSE;
      rParAgencia.MODIFY;
      COMMIT;
    END;

    PROCEDURE Cierra@1103355000(VAR prRsv@1103355000 : Record 7009743;prMarca@1103355002 : Boolean) : Boolean;
    VAR
      lwEnc@1103355001 : Boolean;
      lrRsv2@1103355003 : Record 7009743;
      lwTotal@1103355004 : Integer;
      lwCont@1103355005 : Integer;
      lrTTOO@1103355006 : Record 7009717;
      lrResumenRes@1103355007 : Record 7009771;
      lwTipoCalculo@1100217000 : 'Ambos,Coste,Ingreso';
    BEGIN
      // Cierra
      // prRsv tiene que ya venir previamente filtrado

      lwEnc := prRsv.FINDFIRST;
      IF lwEnc THEN BEGIN
        dDialog.OPEN(Text030 + Text005 +
                     '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\');
        dDialog.UPDATE(1, prRsv.GETFILTER("TourOperador Venta"));
        lwTotal := prRsv.COUNT;
        CLEAR(lwCont);
        REPEAT

          // AJF 22/12/08 (GOC08004)
          // Recuperamos el TTOO de compra para saber si hay que generar lineas de ajuste.
          lrTTOO.GET(prRsv.TourOperador);

          dDialog.UPDATE(3, prRsv.Bono);

          IF rHotel.GET(prRsv."Hotel Factura") THEN
            IF rHotel.NoName THEN
              ErrorCierre(STRSUBSTNO(Text007 + Text008, prRsv."N§ Responsable"));

          // AJS 13.06.2008
          // Incluimos un control de que la reserva no tenga el campo N§ Habitaciones a cero

          IF prRsv."N§ Habitaciones" = 0 THEN
            ErrorCierre(STRSUBSTNO(Text032, prRsv."N§ Responsable", prRsv.Bono));

          rLin.RESET;
          rLin.SETRANGE(Usuario, USERID);
          IF rLin.FINDSET(TRUE) THEN
            rLin.DELETEALL;

          COMMIT;

          //+$006 <
          IF prMarca THEN
          BEGIN
            //+$008 <
            //IF prRsv."Fecha entrada" > TODAY THEN
            //  ERROR(Text038, prRsv.Bono);
            //+$008 >
            lwTipoCalculo := lwTipoCalculo::Ambos
          END
          ELSE
            lwTipoCalculo := lwTipoCalculo::Coste;

          // fCalculo.calculo_reserva(prRsv, FALSE);
          fCalculo.CalculoReserva(prRsv, FALSE, lwTipoCalculo);
          //+$006 >

          CLEAR(Hoteles);
          CLEAR(CosteHotel);
          CLEAR(CosteHotelAparte);
          CLEAR(IngresoHotel);
          CLEAR(ingresoAnterior);

          _ContarPersonas(prRsv); //+$010

          CalculoxHotel();
          GrabarxHotel(lrTTOO);

          // Marcamos todas las reservas dependientes del responsable

          lrRsv2.RESET;
          lrRsv2.SETCURRENTKEY(Delegacion,
                              "N§ Responsable");
          lrRsv2.SETRANGE(Delegacion      , prRsv.Delegacion);
          lrRsv2.SETRANGE("N§ Responsable", prRsv."N§ Reserva");
          IF lrRsv2.FINDSET(TRUE) THEN BEGIN
            REPEAT
              WITH lrRsv2 DO BEGIN
                "Enviar delegacion" := TRUE;

                // AJS 13.05.2005
                // Las reservas solo se marcan si asi lo indica el usuario

                IF prMarca THEN BEGIN
                  "Pendiente calculo" := FALSE;
                  "Llegada cerrada"   := TRUE;
                  "Ultimo n§  cierre" := w_sig_numcierre;
                END;

                IF "Hotel TO" = '' THEN
                  "Hotel TO" := "Hotel reservado";
                IF "Regimen TO" = '' THEN
                  "Regimen TO" := Regimen;
                IF "Habitacion TO" = '' THEN
                  "Habitacion TO" := Habitacion;
                MODIFY;

                // Si el cierre anterior no ha sido enviado borramos los res£menes de las
                // reservas de ese cierre.

                IF sw_no_enviado THEN BEGIN
                  rResumenRes.RESET;
                  rResumenRes.SETRANGE(Delegacion , lrRsv2.Delegacion);
                  rResumenRes.SETRANGE("N§ Cierre", ant_cierre);
                  IF rResumenRes.FINDSET(TRUE) THEN
                    rResumenRes.DELETEALL(TRUE);
                  rResumenRes.SETRANGE("N§ Cierre");
                END;

                // Grabamos el resumen de la reserva correspondiente a este cierre

                rResumenRes.INIT;
                rResumenRes.TRANSFERFIELDS(lrRsv2);
                rResumenRes."N§ Cierre"      := w_sig_numcierre;
                rResumenRes."N§ Orden"       := w_ult_n_orden;
                rResumenRes."N§ Responsable" := prRsv."N§ Responsable";
                rResumenRes.INSERT(TRUE);

              END;
            UNTIL lrRsv2.NEXT = 0;
          END;
          lwCont += 1;
          dDialog.UPDATE(2, ROUND(lwCont / lwTotal * 10000, 1));
        UNTIL prRsv.NEXT = 0;
        dDialog.CLOSE;
      END;

      EXIT(lwEnc);
    END;

    PROCEDURE ErrorCierre@1103355003(pwTexto@1103355000 : Text[1024]);
    BEGIN
      // ErrorCierre
      // Genera un error sistema previamente Desmarcando "Ejecutando Cierre"

      rParAgencia."Ejecutando Cierre" := FALSE;
      rParAgencia.MODIFY;
      COMMIT;

      ERROR(pwTexto);
    END;

    PROCEDURE Hallar_sig_cierre@6() : Integer;
    BEGIN
      // Hallar_sig_cierre

      IF rCierre.FINDLAST THEN
        EXIT(rCierre."N§ Cierre")
      ELSE
        EXIT(0);
    END;

    PROCEDURE CalculoxHotel@33();
    BEGIN
      // CalculoxHotel

      rLin.RESET;
      rLin.SETRANGE(Usuario, USERID());
      IF rLin.FINDFIRST THEN
        REPEAT
          Busca_Hotel(rLin."Hotel Pago");

          IF rLin."Coste/Ingreso" = rLin."Coste/Ingreso"::Coste THEN BEGIN

            // AJS 22.02.2006
            // Vamos a separar en dos variables los costes marcados como facturacion aparte y los normales

            IF rLin."Concepto Hotel Payment" THEN BEGIN
              IF rLin."Validacion HP especial" THEN
                CosteHotelAparte[indice] := CosteHotelAparte[indice] + rLin.Importe
              ELSE
                CosteHotel[indice] := CosteHotel[indice] + rLin.Importe;

            END;
          END
          ELSE BEGIN
            IF rLin."Concepto Hotel Payment" THEN
              IngresoHotel[indice] := IngresoHotel[indice] + rLin.Importe;
          END;
        UNTIL rLin.NEXT = 0;
    END;

    PROCEDURE GrabarxHotel@34(VAR prTTOO@1103355001 : Record 7009717);
    VAR
      lrCnpAjusteTMP@1103355000 : TEMPORARY Record 7010019;
    BEGIN
      // GrabarxHotel

      w_sig_n_orden := 1;
      indice        := 1;
      indice_secuencias := 0;
      CLEAR(tab_secuencias);
      buscar_secuencias(rRsv3);
      indice_secuencias := 1;
      WHILE tab_secuencias[indice_secuencias] <> '' DO BEGIN
        Anula_Cierre_Ant(lrCnpAjusteTMP);
        // Si el cierre anterior ha sido enviado hay que anular el anterior
        IF sw_no_enviado THEN BEGIN
          // COMMIT;
          Anula_Cierre_Ant(lrCnpAjusteTMP);
        END;
        indice_secuencias := indice_secuencias + 1;
      END;

      WHILE (Hoteles[indice] <> '') DO BEGIN

        Busca_Secuencia(FALSE);
        Calc_bono(FALSE, lrCnpAjusteTMP, prTTOO);  // le paso los conceptos de ajuste que se acaban de anular.
        Pasar_Bono(FALSE, prTTOO);

        // AJS 22.02.2006
        // Para cada hotel del bono hay que comprobar si tiene costes que se validen aparte

        IF CosteHotelAparte[indice] <> 0 THEN BEGIN
          Busca_Secuencia(TRUE);
          Calc_bono(TRUE,lrCnpAjusteTMP, prTTOO);
          Pasar_Bono(TRUE, prTTOO);
        END;

        indice        := indice + 1;
      //  w_sig_n_orden := w_sig_n_orden + 1;
      END;
    END;

    PROCEDURE Busca_Hotel@2(HotelBuscado@1103355000 : Code[20]);
    BEGIN
      // Busca_Hotel
      //
      indice := 1;
      WHILE (indice <= 10) AND (Hoteles[indice] <> HotelBuscado) DO BEGIN
        IF Hoteles[indice] = '' THEN
          Hoteles[indice] := HotelBuscado
        ELSE
          indice := indice + 1;
      END;
    END;

    PROCEDURE Anula_Cierre_Ant@4(VAR prCnpAjusteTMP@1103355000 : TEMPORARY Record 7010019);
    BEGIN
      // Anula_cierre_ant
      //
      // Buscamos el £ltimo n§ de cierre

      ant_cierre    := 0;
      sw_no_enviado := FALSE;
      rBono.RESET;
      rBono.SETCURRENTKEY(TourOperador,
                          Bono,
                          "N§ Responsable",
                          "N§ Orden");
      rBono.SETRANGE(Delegacion      , rRsv3.Delegacion);
      rBono.SETRANGE(TourOperador    , rRsv3."TourOperador Venta");
      rBono.SETRANGE(Bono            , rRsv3.Bono);
      rBono.SETRANGE("N§ Responsable", rRsv3."N§ Reserva");
      rBono.SETRANGE("N§ Secuencia"  , tab_secuencias[indice_secuencias]);
      IF rBono.FINDFIRST THEN
        REPEAT
          IF rBono."N§ cierre delegacion" > ant_cierre THEN
            ant_cierre := rBono."N§ cierre delegacion";
        UNTIL rBono.NEXT = 0;

      // buscamos el £ltimo n§ de orden para este bono
      IF rBono.FINDLAST THEN
        w_sig_n_orden := rBono."N§ Orden" + 1
      ELSE
        w_sig_n_orden := 1;

      // Anulamos todos los bonos del cierre anterior que no sean
      // regularizaci¢n del cierre anterior.

      rBono.RESET;
      rBono.SETCURRENTKEY(TourOperador,
                          Bono,
                          "N§ Responsable");
      rBono.SETRANGE(Delegacion            , rRsv3.Delegacion);
      rBono.SETRANGE(TourOperador          , rRsv3."TourOperador Venta");
      rBono.SETRANGE(Bono                  , rRsv3.Bono);
      rBono.SETRANGE("N§ Responsable"      , rRsv3."N§ Reserva");
      rBono.SETRANGE("N§ cierre delegacion", ant_cierre);
      rBono.SETRANGE("N§ Secuencia"  , tab_secuencias[indice_secuencias]);
      IF rBono.FINDFIRST THEN BEGIN
        REPEAT
          IF (rBono."N§ cierre central" <> 0) OR (NOT rBono."Enviar delegacion") OR
             (rBono.Facturado) OR (rBono.Replicado) THEN BEGIN
            IF NOT rBono.Regularizacion THEN BEGIN
              rBono2.INIT;
              rBono2.TRANSFERFIELDS(rBono);
              w_ant_n_orden := rBono2."N§ Orden";
              rBono2."N§ Orden"             := w_sig_n_orden;
              rBono2.Coste                  := rBono2.Coste * (-1);
              rBono2.Ingreso                := rBono2.Ingreso * (-1);
              rBono2."Enviar delegacion"    := TRUE;
              rBono2.Facturado              := FALSE;
              rBono2."N§ envio delegacion"  := 0;
              rBono2.Replicado              := FALSE;
              rBono2.Regularizacion         := TRUE;
              rBono2."N§ cierre delegacion" := w_sig_numcierre;
              rBono2."N§ cierre central"    := 0;
              rBono2.INSERT;
              // Guardamos el ingreso anterior del bono
              //
              EVALUATE(aux_secuencia, rBono."N§ Secuencia");
              ingresoAnterior[aux_secuencia] := rBono.Ingreso;
              rCnp.RESET;
              rCnp.SETRANGE(Delegacion       , rRsv3.Delegacion);
              rCnp.SETRANGE(TourOperador     , rRsv3."TourOperador Venta");
              rCnp.SETRANGE(Bono             , rRsv3.Bono);
              rCnp.SETRANGE("N§ Reserva"     , rRsv3."N§ Reserva");
              rCnp.SETRANGE("N§ Orden"       , w_ant_n_orden);
              rCnp.SETRANGE("N§ Secuencia"   , tab_secuencias[indice_secuencias]);

              IF rCnp.FINDSET THEN
                REPEAT

                  // AJF 22/12/08 (GOC08004)
                  // La anulaci¢n para los conceptos de ajuste se generan a parte.
                  // los guardo en un temporary para generarlos despus.
                  IF rCnp."Concepto ajuste" THEN BEGIN
                    prCnpAjusteTMP := rCnp;
                    prCnpAjusteTMP.INSERT;
                  END
                  ELSE BEGIN
                    rCnp2.INIT;
                    rCnp2.TRANSFERFIELDS(rCnp);
                    rCnp2."N§ Orden"      := w_sig_n_orden;
                    rCnp2.Importe         := rCnp2.Importe * (-1);
                    rCnp2.Regularizacion  := TRUE;
                    rCnp2."N§ Prefactura" := '';
                    rCnp2."N§ Factura"    := '';
                    rCnp2."N§ cierre delegacion" := w_sig_numcierre; //+$009
                    rCnp2.INSERT;
                  END;

                UNTIL rCnp.NEXT = 0;

                rDia.RESET;
                rDia.SETRANGE(Delegacion    , rRsv3.Delegacion);
                rDia.SETRANGE(TourOperador  , rRsv3."TourOperador Venta");
                rDia.SETRANGE(Bono          , rRsv3.Bono);
                rDia.SETRANGE("N§ Reserva"  , rRsv3."N§ Reserva");
                rDia.SETRANGE("N§ Orden"    , w_ant_n_orden);
                rDia.SETRANGE("N§ Secuencia", tab_secuencias[indice_secuencias]);
                IF rDia.FINDSET THEN
                  REPEAT
                    rDia2.INIT;
                    rDia2.TRANSFERFIELDS(rDia);
                    rDia2."N§ Orden" := w_sig_n_orden;
                    rDia2.Importe := rDia2.Importe * (-1);
                    rDia2.INSERT;
                  UNTIL rDia.NEXT = 0;
              w_sig_n_orden := w_sig_n_orden + 1;
            END;
          END
      // el bono no est  facturado ni enviado, se borrar 
          ELSE BEGIN
            sw_no_enviado := TRUE;
            w_ant_n_orden := rBono."N§ Orden";
            rBono.DELETE;
            rCnp.RESET;
            rCnp.SETRANGE(Delegacion    , rRsv3.Delegacion);
            rCnp.SETRANGE(TourOperador  , rRsv3."TourOperador Venta");
            rCnp.SETRANGE(Bono          , rRsv3.Bono);
            rCnp.SETRANGE("N§ Reserva"  , rRsv3."N§ Reserva");
            rCnp.SETRANGE("N§ Orden"    , w_ant_n_orden);
            rCnp.SETRANGE("N§ Secuencia", tab_secuencias[indice_secuencias]);
            IF rCnp.FINDSET(TRUE) THEN
              rCnp.DELETEALL;
            rDia.RESET;
            rDia.SETRANGE(Delegacion    , rRsv3.Delegacion);
            rDia.SETRANGE(TourOperador  , rRsv3."TourOperador Venta");
            rDia.SETRANGE(Bono          , rRsv3.Bono);
            rDia.SETRANGE("N§ Reserva"  , rRsv3."N§ Reserva");
            rDia.SETRANGE("N§ Orden"    , w_ant_n_orden);
            rDia.SETRANGE("N§ Secuencia", tab_secuencias[indice_secuencias]);
            IF rDia.FINDSET(TRUE) THEN
              rDia.DELETEALL;
            rResumenRes.RESET;
            rResumenRes.SETCURRENTKEY(Delegacion,
                                      "N§ Responsable",
                                      "N§ Cierre");
            rResumenRes.SETRANGE(Delegacion      , rRsv3.Delegacion);
            rResumenRes.SETRANGE("N§ Responsable", rRsv3."N§ Reserva");
            rResumenRes.SETRANGE("N§ Cierre"     , ant_cierre);
            IF rResumenRes.FINDSET(TRUE) THEN
              rResumenRes.DELETEALL(TRUE);

            w_sig_n_orden := w_sig_n_orden - 1;
          END;
        UNTIL rBono.NEXT = 0;
      END;
    END;

    PROCEDURE Calc_bono@5(pwValidacionAparte@1103355000 : Boolean;VAR prCnpAjusteTMP@1103355005 : TEMPORARY Record 7010019;VAR prTTOO@1103355006 : Record 7009717);
    VAR
      ultima_prefactura@1103355001 : Code[10];
      lrCITMP@1103355002 : TEMPORARY Record 7010018;
      lrConceptoTMP@1103355003 : TEMPORARY Record 7010019;
    BEGIN
      // Calc_bono

      {--------------------------------------
      rBono2.INIT;
      rBono2.Delegacion := rRsv3.Delegacion;
      rBono2.TourOperador := rRsv3."TourOperador Venta";
      rBono2.Bono := rRsv3.Bono;
      rBono2."N§ Reserva" := rRsv3."N§ Reserva";
      rBono2."N§ Orden" := w_sig_n_orden;

      // AJS 22.02.2006
      // Los costes que se validan aparte se almacena en una variable separada

      IF pwValidacionAparte THEN BEGIN
        rBono2.Coste := -CosteHotelAparte[indice];
        rBono2.Ingreso := 0;
      END
      ELSE BEGIN
        rBono2.Coste := -CosteHotel[indice];
        rBono2.Ingreso := IngresoHotel[indice];
      END;

      rBono2."Contrato compra"      := rRsv3."Contrato compra";
      rBono2."Contrato venta"       := rRsv3."Contrato venta";
      rBono2."Hotel Pago"           := Hoteles[indice];
      rBono2."N§ Secuencia"         := NumSecuencia;
      rBono2."Hotel reservado"      := rRsv3."Hotel reservado";
      rBono2."Tipo contrato"        := rRsv3."Tipo contrato";
      rBono2."N§ Responsable"       := rRsv3."N§ Reserva";
      rBono2."Enviar delegacion"    := TRUE;
      rBono2.Facturado              := FALSE;
      rBono2."N§ envio delegacion"  := 0;
      rBono2."Fecha llegada"        := rRsv3."Fecha entrada";
      rBono2."Fecha salida"         := rRsv3."Fecha salida";
      rBono2."Nombre responsable"   := rRsv3.Nombre;
      rBono2."N§ cierre delegacion" := w_sig_numcierre;
      rBono2."Hotel TO"             := rRsv3."Hotel TO";
      rBono2."Regimen TO"           := rRsv3."Regimen TO";
      rBono2."Habitacion TO"        := rRsv3."Habitacion TO";
      rBono2.INSERT;
      --------------------------------------}

      Resumen_Conceptos(pwValidacionAparte);
      Grabar_CITemp(lrCITMP, lrConceptoTMP, pwValidacionAparte);

      // SI el £ltimo CI y el Nuevo coinciden borramos la £ltima regularizacion y
      // conservamos el £ltimo CI en lugar de insertar el Nuevo.

      IF ComparaUltimoCierre(lrCITMP, lrConceptoTMP) THEN
        BorraUltimaReg(lrCITMP)
      ELSE BEGIN

        PasarCIAReal(lrCITMP, lrConceptoTMP, prTTOO."Factura ingreso solo margen");

        IF prTTOO."Factura ingreso solo margen" THEN BEGIN
          GrabarConceptoComision(lrCITMP);
          GenerarAsientoComision(lrCITMP, prCnpAjusteTMP);
        END;

        // modificar la tabla Bono para que se pueda emitir otra factura
        // si ha variado el ingreso del bono.
        EVALUATE(aux_secuencia, rBono2."N§ Secuencia");
        IF ingresoAnterior[aux_secuencia] <> rBono2.Ingreso THEN BEGIN
          rBo.RESET;
          rBo.SETCURRENTKEY(Delegacion,
                            TourOperador,
                            Bono,
                            "N§ Reserva",
                            "N§ Secuencia");
          rBo.SETRANGE(Delegacion    , rBono2.Delegacion);
          rBo.SETRANGE(TourOperador  , rBono2.TourOperador);
          rBo.SETRANGE(Bono          , rBono2.Bono);
          rBo.SETRANGE("N§ Reserva"  , rBono2."N§ Responsable");
          rBo.SETRANGE("N§ Secuencia", rBono2."N§ Secuencia");
          IF rBo.FINDSET(TRUE) THEN BEGIN
            rBo."N§ Prefactura" := '';
            rBo."N§ Factura"    := '';
            rBo.Facturado       := FALSE;
            rBo.MODIFY(TRUE);
            // Borramos el n§ de prefactura de las lineas de concepto que no esten facturados
            //
            rCnp.RESET;
            rCnp.SETRANGE(Delegacion     , rBono2.Delegacion);
            rCnp.SETRANGE(TourOperador   , rBono2.TourOperador);
            rCnp.SETRANGE(Bono           , rBono2.Bono);
            rCnp.SETRANGE("N§ Reserva"   , rBono2."N§ Responsable");
            rCnp.SETRANGE("N§ Secuencia" , rBono2."N§ Secuencia");
            rCnp.SETRANGE("Coste/Ingreso", rCnp."Coste/Ingreso"::Ingreso);
            IF rCnp.FINDSET(TRUE) THEN BEGIN
              REPEAT
                IF rCnp."N§ Factura" = '' THEN BEGIN
                  rCnp."N§ Prefactura" := '';
                  rCnp.MODIFY;
                END;
              UNTIL rCnp.NEXT = 0;
            END;
          END;
        END;

        Resumen_Fechas(pwValidacionAparte);
        Grabar_Fechas();
      END;

      COMMIT;
    END;

    PROCEDURE Resumen_Conceptos@50(pwValidacionAparte@1103355000 : Boolean);
    VAR
      lwOk@1100253001 : Boolean;
      lwEsExtra@1100253000 : Boolean;
      lwEsHandling@1100253002 : Boolean;
    BEGIN
      // Resumen_Conceptos

      // $003 JPT 06/03/12 El handling Fee lo separamos por precio

      CLEAR(cnp_concep);
      CLEAR(cnp_ci);
      CLEAR(cnp_importe);
      CLEAR(cnp_extra);
      CLEAR(cnp_hf); // handling Fee
      CLEAR(cnp_precio); // $003

      rLin.SETRANGE(Usuario, USERID());
      rLin.SETRANGE(Garantizable);
      rLin.SETRANGE("Concepto Hotel Payment");
      rLin.SETRANGE("Hotel Pago", Hoteles[indice]);

      // AJS 22.02.2006
      // Hay que sumar por separado los conceptos de costes que validan aparte
      // AJF 15/05/08
      // Para los conceptos de costes extras hay que hacer una l¡nea por cada c¢digo extra.

      rLin.SETRANGE("Validacion HP especial", pwValidacionAparte);
      rLin.SETRANGE("Concepto Hotel Payment", TRUE);

      IF rLin.FINDSET THEN
        REPEAT
          ind := 1;
          // JPT 28/03/12 Aseguramos que el precio no sea 0
          IF rLin.Precio = 0 THEN
            IF rLin.Cantidad <> 0 THEN
              rLin.Precio := rLin.Importe / rLin.Cantidad;

          WHILE ind <= 60 DO BEGIN
            lwEsExtra    := (STRPOS(rLin."Concepto Coste", 'EXTRA') <> 0) AND (rLin."Coste/Ingreso" = rLin."Coste/Ingreso"::Coste);
            //. Unifico el tratamiento del precio para Handling y Rep service
            lwEsHandling := (rLin."Concepto Coste" = 'HANDFEEVEN') OR (rLin."Concepto Coste" = 'REPSERVICE');

            lwOk := (cnp_concep[ind] = rLin."Concepto Coste") AND
                    (cnp_ci[ind] = rLin."Coste/Ingreso");

            IF lwOk THEN BEGIN
              CASE TRUE OF
                // Extras
                lwEsExtra : lwOk := (cnp_extra[ind] = rLin.Codigo);
                // Handling
                lwEsHandling : lwOk := (cnp_hf[ind] = rLin.Codigo) AND (cnp_precio[ind] = rLin.Precio); // $003
                // Resto
                ELSE lwOk := (cnp_extra[ind] = '') AND (cnp_hf[ind]='');
              END;
            END
            ELSE BEGIN // Nuevo
              IF (cnp_concep[ind] = '') AND (cnp_ci[ind] = 0) THEN BEGIN
                  cnp_concep[ind]  := rLin."Concepto Coste";
                  cnp_ci[ind]      := rLin."Coste/Ingreso";
                  cnp_Cntr[ind]    := rLin."N§ Contrato"; // $004

                  IF lwEsExtra THEN
                    cnp_extra[ind] := rLin.Codigo;
                  // JPT 21/11/11 GOC-CAR-10003 (2) Nuevo formato factura hotel
                  // Handling Fee o Rep Service
                  IF lwEsHandling THEN BEGIN
                    cnp_hf[ind]     := rLin.Codigo;
                    cnp_precio[ind] := rLin.Precio; //$003
                  END;
                  lwOk := TRUE;
              END;
            END;
            IF lwOk THEN BEGIN
              cnp_importe[ind] += rLin.Importe;
              ind := 101;
            END;

           { JPT 21/11/11 ************************
            IF (cnp_concep[ind] = rLin."Concepto Coste") AND
               (cnp_ci[ind] = rLin."Coste/Ingreso") AND
               (cnp_extra[ind] = '') THEN BEGIN
              cnp_importe[ind] := cnp_importe[ind] + rLin.Importe;
              ind := 101;
            END
            ELSE BEGIN
              IF (cnp_concep[ind] = rLin."Concepto Coste") AND
                 (cnp_ci[ind] = rLin."Coste/Ingreso") AND
                 (STRPOS(cnp_concep[ind], Text031) <> 0) AND
                 (cnp_ci[ind] = rLin."Coste/Ingreso"::Coste ) AND
                 (cnp_extra[ind] = rLin.Codigo) THEN BEGIN
                cnp_importe[ind] := cnp_importe[ind] + rLin.Importe;
                ind := 101;
              END
              ELSE BEGIN
                IF (cnp_concep[ind] = '') AND (cnp_ci[ind] = 0) THEN BEGIN
                  cnp_concep[ind]  := rLin."Concepto Coste";
                  cnp_ci[ind]      := rLin."Coste/Ingreso";

                  IF (STRPOS(cnp_concep[ind], Text031) <> 0) AND (cnp_ci[ind] = rLin."Coste/Ingreso"::Coste ) THEN
                    cnp_extra[ind] := rLin.Codigo;
                  // JPT 21/11/11 GOC-CAR-10003 (2) Nuevo formato factura hotel
                  // Handling Fee
                  IF (cnp_concep[ind] = Text037) AND (cnp_ci[ind] = rLin."Coste/Ingreso"::Ingreso ) THEN
                    cnp_hf[ind] := rLin.Codigo;


                  cnp_importe[ind] := cnp_importe[ind] + rLin.Importe;
                  ind := 101;
                END;
              END;
            END;
            JPT 21/11/11 ************************ }

            ind := ind + 1;
          END;
        UNTIL rLin.NEXT = 0;
    END;

    PROCEDURE Resumen_Fechas@52(pwValidacionAparte@1103355000 : Boolean);
    BEGIN
      // Resumen_Fechas

      CLEAR(fec_fecha);
      CLEAR(fec_ci);
      CLEAR(fec_importe);

      rLin.SETRANGE(Usuario                 , USERID());
      rLin.SETRANGE(Garantizable            , TRUE);
      rLin.SETRANGE("Hotel Pago"            , Hoteles[indice]);

      // AJS 22.02.2006
      // Hay que sumar por separado los conceptos de costes que validan aparte

      rLin.SETRANGE("Validacion HP especial", pwValidacionAparte);

      IF rLin.FINDSET THEN
        REPEAT
          ind := 1;
          WHILE ind <= 60 DO BEGIN
            IF (fec_fecha[ind] = rLin.Fecha) AND (fec_ci[ind] = rLin."Coste/Ingreso") THEN BEGIN
              fec_importe[ind] := fec_importe[ind] + rLin.Importe;
              ind := 101;
            END
            ELSE BEGIN
              IF (fec_fecha[ind] = 0D) AND (fec_ci[ind] = 0) THEN BEGIN
                fec_fecha[ind]   := rLin.Fecha;
                fec_ci[ind]      := rLin."Coste/Ingreso";
                fec_importe[ind] := fec_importe[ind] + rLin.Importe;
                ind := 101;
              END;
            END;
            ind := ind + 1;
          END;
        UNTIL rLin.NEXT = 0;
    END;

    PROCEDURE Grabar_Fechas@53();
    BEGIN
      // Grabar_Fechas

      ind := 1;
      WHILE ind <= 60 DO BEGIN
        IF (fec_fecha[ind] <> 0D) AND (fec_importe[ind] <> 0) THEN BEGIN
          rDia.INIT;
          rDia.Delegacion      := rRsv3.Delegacion;
          rDia.TourOperador    := rRsv3."TourOperador Venta";
          rDia.Bono            := rRsv3.Bono;
          rDia."N§ Reserva"    := rRsv3."N§ Reserva";
          rDia."N§ Secuencia"  := NumSecuencia;
          rDia."N§ Orden"      := w_sig_n_orden;
          rDia.Dia             := fec_fecha[ind];
          rDia."Coste/Ingreso" := fec_ci[ind] - 1;
          rDia.Importe         := fec_importe[ind];
          rDia.Hotel           := Hoteles[indice];
          rDia.INSERT;
        END;
        ind := ind + 1;
      END;
    END;

    PROCEDURE Busca_Secuencia@3(pwValidacionAparte@1103355000 : Boolean);
    VAR
      aux_ci@1103355001 : Record 7010018;
    BEGIN
      // Busca_Secuencia

      rBo2.RESET;
      rBo2.SETCURRENTKEY(Delegacion,
                         TourOperador,
                         Bono,
                         "N§ Reserva",
                         "N§ Secuencia");
      rBo2.SETRANGE(Delegacion  , rRsv3.Delegacion);
      rBo2.SETRANGE(TourOperador, rRsv3."TourOperador Venta");
      rBo2.SETRANGE(Bono        , rRsv3.Bono);
      rBo2.SETRANGE("N§ Reserva", rRsv3."N§ Reserva");
      IF rBo2.FINDLAST THEN BEGIN
        NumSecuencia := rBo2."N§ Secuencia";

        // AJS 22.02.2006
        // Hay que buscar por separado la secuencia para los costes que validan aparte

        rBo2.SETRANGE("Validacion HP especial", pwValidacionAparte);

        rBo2.SETRANGE(Hotel, Hoteles[indice]);
        IF rBo2.FINDFIRST THEN
          NumSecuencia := rBo2."N§ Secuencia"
        ELSE
          NumSecuencia := INCSTR(NumSecuencia);
      END
      ELSE
        NumSecuencia := '1';

      // buscamos el ultimo orden para esta secuencia

      aux_ci.RESET;
      aux_ci.SETRANGE(Delegacion    , rBo2.Delegacion);
      aux_ci.SETRANGE(TourOperador  , rBo2.TourOperador);
      aux_ci.SETRANGE(Bono          , rBo2.Bono);
      aux_ci.SETRANGE("N§ Reserva"  , rBo2."N§ Reserva");
      aux_ci.SETRANGE("N§ Secuencia", NumSecuencia);
      IF aux_ci.FINDLAST THEN
        w_sig_n_orden := aux_ci."N§ Orden" + 1
      ELSE
        w_sig_n_orden := 1;
      aux_ci.RESET;
    END;

    PROCEDURE Pasar_Bono@7(pwFacturacionAparte@1103355000 : Boolean;VAR prTTOO@1103355001 : Record 7009717);
    BEGIN
      // Pasar_Bono

      rBo.RESET;
      rBo.SETCURRENTKEY(Delegacion,
                        TourOperador,
                        Bono,
                        "N§ Reserva",
                        "N§ Secuencia");
      rBo.SETRANGE(Delegacion     , rRsv3.Delegacion);
      rBo.SETRANGE(TourOperador   , rRsv3."TourOperador Venta");
      rBo.SETRANGE(Bono           , rRsv3.Bono);
      rBo.SETRANGE("N§ Reserva"   , rRsv3."N§ Reserva");
      // rBo.SETRANGE("N§ Secuencia" , NumSecuencia);
      // Si hay registros, recalcular por si ha habido un
      // cambio de hotel.
      IF rBo.FINDSET(TRUE) THEN
        REPEAT
          rBo.CALCFIELDS("Importe coste");
          rBo."Coste final" := rBo."Importe coste";
          rBo.CALCFIELDS("Importe ingreso");
          EVALUATE(aux_secuencia, rBo."N§ Secuencia");
          IF ingresoAnterior[aux_secuencia] <> rBo."Importe ingreso" THEN BEGIN
            rBo."N§ Prefactura" := '';
            rBo."N§ Factura" := '';
          END;
          rBo."Ingreso Final" := rBo."Importe ingreso";
          rBo.MODIFY(TRUE);
        UNTIL rBo.NEXT = 0;

      rBo.SETRANGE(Hotel, Hoteles[indice]);

      // AJS 22.02.2006
      // Hay que crear un bono para los conceptos que se facturan aparte

      rBo.SETRANGE("Validacion HP especial", pwFacturacionAparte);

      IF rBo.FINDFIRST THEN BEGIN
        rBo."N§ Interno"         := rRsv3."N§ Interno";
        rBo."N§ Periodo"         := rRsv3."N§ Periodo";
        rBo."Nombre Responsable" := rRsv3.Nombre;
        rBo."Fecha llegada"      := rRsv3."Fecha entrada";
        rBo.CALCFIELDS("Importe coste");
        rBo."Coste final"      := rBo."Importe coste";
        rBo.CALCFIELDS("Importe ingreso");
        rBo."Ingreso Final"      := rBo."Importe ingreso";
        rBo."Hotel Reservado"    := rRsv3."Hotel reservado";
        rBo."Fecha salida"       := rRsv3."Fecha salida";
        rBo."N§ Contrato"        := rRsv3."Contrato compra";
        rBo."Pendiente Cierre"   := TRUE;
        rBo.Facturable           := (rBo."Ingreso Final" <> 0);

        //IF rRsv3."Tipo contrato" = rRsv3."Tipo contrato"::"En nombre propio" THEN
        //  rBo.Facturable:= TRUE
        //ELSE
        //  rBo.Facturable:= FALSE;

        rBo."TourOperador Compra" := rRsv3.TourOperador;
        rBo.MODIFY(TRUE);
      END
      ELSE BEGIN  // si no existe en la tabla "Bonos", lo creamos
        rBo.INIT;
        rBo.Delegacion           := rRsv3.Delegacion;
        rBo.TourOperador         := rRsv3."TourOperador Venta";
        rBo.Bono                 := rRsv3.Bono;
        rBo."N§ Interno"         := rRsv3."N§ Interno";
        rBo."N§ Periodo"         := rRsv3."N§ Periodo";
        rBo."N§ Secuencia"       := NumSecuencia;
        rBo."Nombre Responsable" := rRsv3.Nombre;
        rBo."Fecha llegada"      := rRsv3."Fecha entrada";
        rBo."Hotel Reservado"    := rRsv3."Hotel reservado";
        rBo."Creado por"         := rBo."Creado por"::Delegacion;
        rBo."Fecha salida"       := rRsv3."Fecha salida";
        rBo."N§ Contrato"        := rRsv3."Contrato compra";
        rBo."N§ Reserva"         := rRsv3."N§ Reserva";
        rBo."Pendiente Cierre"   := TRUE;
        rBo.Hotel                := Hoteles[indice];

        //IF rRsv3."Tipo contrato" = rRsv3."Tipo contrato"::"En nombre propio" THEN
        //  rBo.Facturable         := TRUE
       // ELSE
       //   rBo.Facturable         := FALSE;

        rBo."TourOperador Compra" := rRsv3.TourOperador;
        COMMIT;
        rBo.INSERT;
        rBo.CALCFIELDS("Importe coste");
        rBo."Coste final"      := rBo."Importe coste";
        rBo.CALCFIELDS("Importe ingreso");
        rBo."Ingreso Final" := rBo."Importe ingreso";
        rBo.Facturable           := (rBo."Ingreso Final" <> 0);

        // AJS 23.02.2006
        // Rellenamos en el bono si se tiene que marcar como "Facturacion HP Aparte"

        rBo."Validacion HP especial" := pwFacturacionAparte;

        rBo.MODIFY;
      END;
      COMMIT;

      IF prTTOO."Factura ingreso solo margen" AND prTTOO."Traspasar Hotel Payment" THEN
        cExpHP.ExpBonoAutomatico(rBo);
    END;

    PROCEDURE buscar_secuencias@8(par_reserva@1103355000 : Record 7009743);
    VAR
      aux_bono@1103355001 : Record 7010013;
    BEGIN
      // buscar_secuencias

      aux_bono.RESET;
      aux_bono.SETRANGE(Delegacion  , par_reserva.Delegacion);
      aux_bono.SETRANGE(TourOperador, par_reserva."TourOperador Venta");
      aux_bono.SETRANGE(Bono        , par_reserva.Bono);
      aux_bono.SETRANGE("N§ Reserva", par_reserva."N§ Responsable");
      IF aux_bono.FINDSET THEN BEGIN
        REPEAT
          indice_secuencias := indice_secuencias + 1;
          tab_secuencias[indice_secuencias] := aux_bono."N§ Secuencia";
        UNTIL aux_bono.NEXT = 0;
      END;
      aux_bono.RESET;
    END;

    PROCEDURE generar_prepago@9(VAR par_rsv@1103355000 : Record 7009743);
    VAR
      rTO@1103355001 : Record 7009717;
      aux_rsv@1103355002 : Record 7009743;
      aux_bono@1103355003 : Record 7010013;
      cFunFac@1103355004 : Codeunit 7009725;
      fecha_limite@1103355005 : Date;
      dias_texto@1103355006 : Text[30];
      ventana@1103355007 : Dialog;
      w_to@1103355008 : Code[10];
    BEGIN
      // generar_prepago
      //
      w_to := par_rsv."TourOperador Venta";
      ventana.OPEN(Text011 +
                   Text012, w_to);
      ventana.INPUT(1, w_to);
      ventana.CLOSE;
      IF NOT CONFIRM(STRSUBSTNO(Text013, w_to)) THEN
        EXIT;
      IF NOT rTO.GET(w_to) THEN
        ERROR(Text014, w_to);
      IF rTO."Dias prepago" = 0 THEN
        ERROR(Text015);
      dias_texto := STRSUBSTNO(Text016, rTO."Dias prepago");
      fecha_limite := CALCDATE(dias_texto, TODAY);
      aux_rsv.RESET;
      aux_rsv.SETCURRENTKEY("Pendiente calculo",
                            "Fecha entrada",
                            "TourOperador Venta",
                            Responsable,
                            "Pendiente asignar",
                            Bono);
      aux_rsv.SETRANGE("Pendiente calculo" , TRUE);
      aux_rsv.SETRANGE("Fecha entrada"     , fecha_limite);
      aux_rsv.SETRANGE("TourOperador Venta", w_to);
      aux_rsv.SETRANGE(Responsable         , TRUE);
      aux_rsv.SETRANGE("Pendiente asignar" , FALSE);
      IF aux_rsv.FINDFIRST THEN BEGIN
        Cierre_llegada_hotel(aux_rsv, 0D, w_to, TRUE,FALSE);
        COMMIT;
        aux_bono.RESET;
        aux_bono.SETCURRENTKEY(Delegacion,
                               "N§ Prefactura",
                               TourOperador,
                               Hotel,
                               "Fecha llegada",
                               Facturable);
        aux_bono.SETRANGE(Delegacion     , aux_rsv.Delegacion);
        aux_bono.SETRANGE(TourOperador   , aux_rsv."TourOperador Venta");
        aux_bono.SETRANGE("Fecha llegada", aux_rsv."Fecha entrada");
        aux_bono.SETRANGE(Facturable     , TRUE);
        IF aux_bono.FINDFIRST THEN
          cFunFac.Crear_Prefactura(aux_bono, TRUE);
      END
      ELSE BEGIN
        ERROR(Text017, w_to, fecha_limite);
      END;
    END;

    PROCEDURE pre_cierre_hotel@15(VAR rRsvHotel@1103355000 : Record 7009743);
    VAR
      dia@1103355001 : Date;
      lrCond@1103355004 : Record 7010085;
      lfCondCierre@1103355005 : Form 7009975;
      lrTTOO@1103355006 : Record 7009717;
      lwTTOO@1103355002 : Code[10];
      lwSelTO@1103355003 : Boolean;
      lwUnTTOO@1103355007 : Boolean;
    BEGIN
      // pre_cierre_hotel

      cFunSeg.TienePermiso('HOT-CIE-RSV', TRUE); //$007

      // AJS 13.05.2005
      // Se pide al usuario si quiere marcar las reservas como cerradas

      dia := 0D;
      IF rRsvHotel.GETFILTER("Fecha entrada") <> '' THEN BEGIN
        dia  := rRsvHotel.GETRANGEMAX("Fecha entrada");
        dia2 := dia;
      END;
      IF dia = 0D THEN
        dia := TODAY();

      // 13.11.2006
      // Las condiciones se solicitan al usuario mediante un formulario

      lrCond.RESET;
      IF NOT lrCond.GET(USERID) THEN BEGIN
        lrCond.INIT;
        lrCond.Usuario := USERID;
        lrCond.INSERT;
      END;

      CLEAR(lrTTOO);
      lrTTOO.SETFILTER(TourOperador, rRsvHotel.GETFILTER("TourOperador Venta"));
      lwUnTTOO := lrTTOO.COUNT=1;
      // lwUnTTOO Indica si se ha filtrado por un solo touroperador
      IF lwUnTTOO THEN
        lrCond.TourOperador    := rRsvHotel.GETFILTER("TourOperador Venta");
      // lrCond."Fecha Entrada" := dia;
      lrCond.Validados       := FALSE;
      lrCond.MODIFY;
      COMMIT;

      lrCond.FILTERGROUP(2);
      lrCond.SETRANGE(Usuario, USERID);
      lrCond.FILTERGROUP(0);

      CLEAR(lfCondCierre);
      lfCondCierre.PasaReservas(rRsvHotel);
      lfCondCierre.SETRECORD(lrCond);
      IF lfCondCierre.RUNMODAL <> ACTION::OK THEN
        EXIT;

      CLEAR(lwTTOO);
      CLEAR(rTempTO);
      CLEAR(lwSelTO);
      rTempTO.DELETEALL; // Temporal de Touroperadores
      IF rRsvHotel.GETFILTER("TourOperador Venta") <> '' THEN BEGIN
        IF lwUnTTOO THEN
          lwTTOO := rRsvHotel.GETRANGEMIN("TourOperador Venta");
      END
      ELSE BEGIN // Recuperamos los touroperadores seleccionados
        lfCondCierre.GetTemp(rTempTO);
        lwSelTO := rTempTO.FINDFIRST;
        IF lwSelTO THEN BEGIN
          IF rTempTO.COUNT=1 THEN
            lwTTOO := rTempTO.TourOperador
          ELSE
            lwTTOO := Text029;
        END;
      END;

      lfCondCierre.GETRECORD(lrCond);

      IF (lrCond."Fecha Entrada" < dia2) AND (lrCond."Fecha Entrada" <> 0D) THEN
        ERROR(Text021 +
              Text022 +
              Text023 +
              Text024);

      IF NOT CONFIRM(Text025 +
                     Text026 +
                     Text027 +
                     Text028, FALSE, lrCond."Fecha Entrada", lwTTOO,
                              lrCond.Validados) THEN
        EXIT;

      Cierre_llegada_hotel(rRsvHotel, lrCond."Fecha Entrada", lwTTOO, lrCond.Validados, lwSelTO);
    END;

    PROCEDURE Grabar_CITemp@1103355002(VAR prCITMP@1103355001 : TEMPORARY Record 7010018;VAR prConceptoTMP@1103355000 : TEMPORARY Record 7010019;pwValidacionAparte@1103355002 : Boolean);
    BEGIN
      // Grabar_CITemp

      // Limpio los temporaries.
      prCITMP.RESET;
      prCITMP.DELETEALL;
      prConceptoTMP.RESET;
      prConceptoTMP.DELETEALL;

      prCITMP.INIT;
      prCITMP.Delegacion   := rRsv3.Delegacion;
      prCITMP.TourOperador := rRsv3."TourOperador Venta";
      prCITMP.Bono         := rRsv3.Bono;
      prCITMP."N§ Reserva" := rRsv3."N§ Reserva";
      prCITMP."N§ Orden"   := w_sig_n_orden;

      // AJS 22.02.2006
      // Los costes que se validan aparte se almacena en una variable separada

      IF pwValidacionAparte THEN BEGIN
        prCITMP.Coste := -CosteHotelAparte[indice];
        prCITMP.Ingreso := 0;
      END
      ELSE BEGIN
        prCITMP.Coste := -CosteHotel[indice];
        prCITMP.Ingreso := IngresoHotel[indice];
      END;

      prCITMP."Contrato compra"      := rRsv3."Contrato compra";
      prCITMP."Contrato venta"       := rRsv3."Contrato venta";
      prCITMP."Hotel Pago"           := Hoteles[indice];
      prCITMP."N§ Secuencia"         := NumSecuencia;
      prCITMP."Hotel reservado"      := rRsv3."Hotel reservado";
      prCITMP."Tipo contrato"        := rRsv3."Tipo contrato";
      prCITMP."N§ Responsable"       := rRsv3."N§ Reserva";
      prCITMP."Enviar delegacion"    := TRUE;
      prCITMP.Facturado              := FALSE;
      prCITMP."N§ envio delegacion"  := 0;
      prCITMP."Fecha llegada"        := rRsv3."Fecha entrada";
      prCITMP."Fecha salida"         := rRsv3."Fecha salida";
      prCITMP."Nombre responsable"   := rRsv3.Nombre;
      prCITMP."N§ cierre delegacion" := w_sig_numcierre;
      prCITMP."Hotel TO"             := rRsv3."Hotel TO";
      prCITMP."Regimen TO"           := rRsv3."Regimen TO";
      prCITMP."Habitacion TO"        := rRsv3."Habitacion TO";
      prCITMP.Habitaciones           := rRsv3."N§ Habitaciones"; //+$009
      prCITMP.Adultos                := wAdults; //+$010
      prCITMP.Ni¤os                  := wChilds; //+$010
      prCITMP.INSERT;

      ind := 1;
      WHILE ind <= 60 DO BEGIN
        IF (cnp_concep[ind] <> '') AND (cnp_importe[ind] <> 0) THEN BEGIN
          prConceptoTMP.INIT;
          prConceptoTMP.Delegacion       := rRsv3.Delegacion;
          prConceptoTMP.TourOperador     := rRsv3."TourOperador Venta";
          prConceptoTMP.Bono             := rRsv3.Bono;
          prConceptoTMP."N§ Reserva"     := rRsv3."N§ Reserva";
          prConceptoTMP."N§ Responsable" := rRsv3."N§ Responsable";
          prConceptoTMP."N§ Secuencia"   := NumSecuencia;
          prConceptoTMP."N§ Orden"       := w_sig_n_orden;
          prConceptoTMP.Concepto         := cnp_concep[ind];
          prConceptoTMP."Coste/Ingreso"  := cnp_ci[ind] - 1;
          prConceptoTMP.Precio           := cnp_precio[ind]; // $003

          // AJF 15/05/08
          // Traspasamos el codigo de extra en los extras de coste.
          IF (prConceptoTMP."Coste/Ingreso" = prConceptoTMP."Coste/Ingreso"::Coste) AND
             (STRPOS(prConceptoTMP.Concepto, 'EXTRA') <> 0) THEN
            prConceptoTMP."Codigo Extra"   := cnp_extra[ind];
          // JPT 21/11/11 GOC-CAR-10003 (2) Nuevo formato factura hotel
          prConceptoTMP."Cod Handling"   := cnp_hf[ind];

          prConceptoTMP.Importe          := cnp_importe[ind];
          prConceptoTMP."Fecha llegada"  := rRsv3."Fecha entrada";
          prConceptoTMP."Hotel Pago"     := Hoteles[indice];
          prConceptoTMP."N§ Prefactura"  := '';
          prConceptoTMP."N§ Factura"     := '';
          prConceptoTMP."Contrato Venta" := cnp_Cntr[ind]; //$004

          //+$005
          CASE cnp_concep[ind] OF
            'HANDFEEVEN', 'REPSERVICE':
              prConceptoTMP."Tipo contrato" := prConceptoTMP."Tipo contrato"::Tarifa;
            ELSE
              prConceptoTMP."Tipo contrato" := prConceptoTMP."Tipo contrato"::Contrato;
          END;
          //+$005

          // AJF Uso regularizaci¢n durante la comparaci¢n con el registro en real.
          prConceptoTMP.Regularizacion := TRUE;

          prConceptoTMP."N§ cierre delegacion" := w_sig_numcierre; //+$009
          prConceptoTMP.INSERT;
        END;
        ind := ind + 1;
      END;
    END;

    PROCEDURE PasarCIAReal@1103355006(VAR prCITMP@1103355002 : TEMPORARY Record 7010018;VAR prConceptoTMP@1103355000 : TEMPORARY Record 7010019;pwSoloMargen@1103355005 : Boolean);
    VAR
      lrCI@1103355003 : Record 7010018;
      lrConcepto@1103355001 : Record 7010019;
    BEGIN
      // PasarCIAReal

      prCITMP.RESET;

      IF prCITMP.FINDSET THEN BEGIN
        lrCI.INIT;
        lrCI := prCITMP;
        lrCI.INSERT;

        // Esta variable ha de contener el nuevo registro de C/I ya que el proceso lo consulta aqu¡.
        rBono2 := lrCI;

      END;

      prConceptoTMP.RESET;
      IF prConceptoTMP.FINDSET THEN BEGIN
        REPEAT

          lrConcepto.INIT;
          lrConcepto := prConceptoTMP;
          lrConcepto.Regularizacion := FALSE;
          lrConcepto.INSERT;

          // AJF 22/12/08 (GOC08004)
          // Si el TTOO solo factura el margen hay que generar lineas de ajuste para las l¡neas de ingreso.
          IF pwSoloMargen AND (prConceptoTMP."Coste/Ingreso" = prConceptoTMP."Coste/Ingreso"::Ingreso) THEN BEGIN
            lrConcepto.INIT;
            lrConcepto := prConceptoTMP;
            lrConcepto.Regularizacion    := FALSE;
            lrConcepto."Concepto ajuste" := TRUE;
            lrConcepto.Importe           := - lrConcepto.Importe;
            lrConcepto.Concepto          := COPYSTR('AJ' + lrConcepto.Concepto, 1, MAXSTRLEN(lrConcepto.Concepto));
            lrConcepto.INSERT;
          END;

        UNTIL prConceptoTMP.NEXT = 0;
      END;
    END;

    PROCEDURE ComparaUltimoCierre@1103355001(VAR prCITMP@1103355000 : TEMPORARY Record 7010018;VAR prConceptoTMP@1103355001 : TEMPORARY Record 7010019) : Boolean;
    VAR
      lrCI@1103355002 : Record 7010018;
      lrConceptos@1103355003 : Record 7010019;
    BEGIN
      // ComparaUltimoCierre

      prCITMP.RESET;
      prCITMP.FINDFIRST;

      lrCI.SETCURRENTKEY(TourOperador,
                         Bono,
                         "N§ Responsable",
                         "N§ Orden");
      lrCI.ASCENDING(FALSE);
      lrCI.SETRANGE (Delegacion      , rRsv3.Delegacion);
      lrCI.SETRANGE (TourOperador    , rRsv3."TourOperador Venta");
      lrCI.SETRANGE (Bono            , rRsv3.Bono);
      lrCI.SETRANGE ("N§ Responsable", rRsv3."N§ Reserva");
      lrCI.SETRANGE ("N§ Secuencia"  , prCITMP."N§ Secuencia");
      lrCI.SETFILTER("N§ Orden"      , '<>%1', prCITMP."N§ Orden");
      lrCI.SETRANGE (Regularizacion  , FALSE);

      // Si no existe CI anterior se tiene que pasar a real el CI calculado ahora.
      IF NOT lrCI.FINDFIRST THEN
        EXIT(FALSE);

      // Comparamos conceptos con el CI encontrado.

      lrConceptos.SETRANGE(Delegacion    , lrCI.Delegacion);
      lrConceptos.SETRANGE(TourOperador  , lrCI.TourOperador);
      lrConceptos.SETRANGE(Bono          , lrCI.Bono);
      lrConceptos.SETRANGE("N§ Reserva"  , lrCI."N§ Reserva");
      lrConceptos.SETRANGE("N§ Secuencia", lrCI."N§ Secuencia");
      lrConceptos.SETRANGE("N§ Orden"    , lrCI."N§ Orden");

      // AJF 22/12/08 (GOC08004)
      // No tenemos en cuenta los conceptos de ajuste para comparar.
      lrConceptos.SETRANGE("Concepto ajuste", FALSE);

      IF lrConceptos.FINDSET THEN BEGIN
        REPEAT
          prConceptoTMP.RESET;
          prConceptoTMP.SETRANGE(Delegacion    , lrConceptos.Delegacion);
          prConceptoTMP.SETRANGE(TourOperador  , lrConceptos.TourOperador);
          prConceptoTMP.SETRANGE(Bono          , lrConceptos.Bono);
          prConceptoTMP.SETRANGE("N§ Reserva"  , lrConceptos."N§ Reserva");
          prConceptoTMP.SETRANGE(Concepto      , lrConceptos.Concepto);
          prConceptoTMP.SETRANGE("Codigo Extra", lrConceptos."Codigo Extra");

          // Si no se encuentra el mismo concepto se tienen que conservar todas las lineas
          IF NOT prConceptoTMP.FINDSET(TRUE) THEN
            EXIT(FALSE);

          IF prConceptoTMP.Importe <> lrConceptos.Importe THEN
            EXIT(FALSE);

          // Marco el concepto como encontrado.
          prConceptoTMP.Regularizacion := FALSE;
          prConceptoTMP.MODIFY;

        UNTIL lrConceptos.NEXT = 0;
      END;

      // Miramos si ha quedado algun concepto nuevo sin casar con el c lculo anterior.

      prConceptoTMP.RESET;
      prConceptoTMP.SETRANGE(Regularizacion, TRUE);

      IF NOT prConceptoTMP.ISEMPTY THEN
        EXIT(FALSE);

      EXIT(TRUE);
    END;

    PROCEDURE BorraUltimaReg@1103355010(VAR prCITMP@1103355000 : Record 7010018);
    VAR
      lrCI@1103355002 : Record 7010018;
      lrConceptos@1103355001 : Record 7010019;
    BEGIN
      // BorraUltimaReg

      prCITMP.RESET;
      prCITMP.FINDFIRST;

      lrCI.SETCURRENTKEY(TourOperador,
                         Bono,
                         "N§ Responsable",
                         "N§ Orden");
      lrCI.ASCENDING(FALSE);
      lrCI.SETRANGE (Delegacion      , rRsv3.Delegacion);
      lrCI.SETRANGE (TourOperador    , rRsv3."TourOperador Venta");
      lrCI.SETRANGE (Bono            , rRsv3.Bono);
      lrCI.SETRANGE ("N§ Responsable", rRsv3."N§ Reserva");
      lrCI.SETRANGE ("N§ Secuencia"  , prCITMP."N§ Secuencia");
      lrCI.SETFILTER("N§ Orden"      , '<>%1', prCITMP."N§ Orden");
      lrCI.SETRANGE (Regularizacion  , TRUE);

      IF NOT lrCI.FINDFIRST THEN
        EXIT;

      lrConceptos.SETRANGE(Delegacion    , lrCI.Delegacion);
      lrConceptos.SETRANGE(TourOperador  , lrCI.TourOperador);
      lrConceptos.SETRANGE(Bono          , lrCI.Bono);
      lrConceptos.SETRANGE("N§ Reserva"  , lrCI."N§ Reserva");
      lrConceptos.SETRANGE("N§ Secuencia", lrCI."N§ Secuencia");
      lrConceptos.SETRANGE("N§ Orden"    , lrCI."N§ Orden");
      lrConceptos.DELETEALL;

      lrCI.DELETE;
    END;

    PROCEDURE GrabarConceptoComision@1103355004(VAR prCITMP@1103355001 : TEMPORARY Record 7010018);
    VAR
      lrConcepto@1103355000 : Record 7010019;
    BEGIN
      // GrabarConceptoComision
      // (GOC08004) Si el TourOperador de compra consta como facturar solo
      // margen tenemos que generar un concepto de comisi¢n.

      lrConcepto.INIT;
      lrConcepto.Delegacion        := rRsv3.Delegacion;
      lrConcepto.TourOperador      := rRsv3."TourOperador Venta";
      lrConcepto.Bono              := rRsv3.Bono;
      lrConcepto."N§ Reserva"      := rRsv3."N§ Reserva";
      lrConcepto."N§ Responsable"  := rRsv3."N§ Responsable";
      lrConcepto."N§ Secuencia"    := NumSecuencia;
      lrConcepto."N§ Orden"        := w_sig_n_orden;
      lrConcepto.Concepto          := 'COMISION';
      lrConcepto."Concepto ajuste" := TRUE;
      lrConcepto."Coste/Ingreso"   := lrConcepto."Coste/Ingreso"::Ingreso;

      lrConcepto.Importe           := prCITMP.Ingreso - prCITMP.Coste;

      lrConcepto."Fecha llegada"   := rRsv3."Fecha entrada";
      lrConcepto."Hotel Pago"      := Hoteles[indice];
      lrConcepto."N§ Prefactura"   := '';
      lrConcepto."N§ Factura"      := '';

      lrConcepto.INSERT;
    END;

    PROCEDURE GenerarAsientoComision@1103355005(VAR prCITMP@1103355001 : TEMPORARY Record 7010018;VAR prCnpAjusteTMP@1103355000 : TEMPORARY Record 7010019);
    VAR
      lwImporte@1103355002 : Decimal;
      lrLinDia@1103355003 : Record 81;
      lrSeccion@1103355009 : Record 232;
      lrCuentas@1103355004 : Record 7009705;
      lrContV@1103355007 : Record 7009727;
      lwCont@1103355005 : Integer;
      lwEnc@1103355006 : Boolean;
      lwNumLin@1103355011 : Integer;
      lwNumAsiento@1103355010 : Integer;
    BEGIN
      // GenerarAsientoComision
      // (GOC08004) Generamos un asiento contable para la comisi¢n

      wDiarioGeneral := rParAgencia.GetLibroDiarioGeneral;
      rParAgencia.CreaSeccionUsuario;

      // Buscamos el contrato de venta para obtener el cliente.
      IF NOT lrContV.GET(prCITMP.Delegacion, prCITMP."Contrato venta") THEN
        ERROR(Text035, prCITMP.Delegacion, prCITMP."Contrato venta");

      // Buscamos la cuenta de contrapartida del asiento.
      lwEnc := FALSE;
      FOR lwCont := 1 TO 4 DO BEGIN
        lrCuentas.RESET;

        CASE lwCont OF

          1: BEGIN
            lrCuentas.SETRANGE(Delegacion  , prCITMP.Delegacion);
            lrCuentas.SETRANGE(TourOperador, prCITMP.TourOperador);
          END;

          2: BEGIN
            lrCuentas.SETRANGE(Delegacion  , '');
            lrCuentas.SETRANGE(TourOperador, prCITMP.TourOperador);
          END;

          3: BEGIN
            lrCuentas.SETRANGE(Delegacion  , prCITMP.Delegacion);
            lrCuentas.SETRANGE(TourOperador, '');
          END;

          4: BEGIN
            lrCuentas.SETRANGE(Delegacion  , '');
            lrCuentas.SETRANGE(TourOperador, '');
          END;

        END;

        IF lrCuentas.FINDFIRST THEN
          lwEnc := lrCuentas."Cta. comision hotel" <> '';

        IF lwEnc THEN
          lwCont := 4
      END;

      IF NOT lwEnc THEN
        ERROR(Text034);

      lwImporte := prCITMP.Ingreso - prCITMP.Coste;

      // Buscamos en los conceptos de ajuste la comisi¢n.
      // Si existe, el importe es la diferencia de importes entre comisiones.
      prCnpAjusteTMP.SETRANGE(Delegacion    , prCITMP.Delegacion);
      prCnpAjusteTMP.SETRANGE(TourOperador  , prCITMP.TourOperador);
      prCnpAjusteTMP.SETRANGE(Bono          , prCITMP.Bono);
      prCnpAjusteTMP.SETRANGE("N§ Reserva"  , prCITMP."N§ Reserva");
      prCnpAjusteTMP.SETRANGE("N§ Secuencia", prCITMP."N§ Secuencia");
      prCnpAjusteTMP.SETRANGE(Concepto      , 'COMISION');
      IF prCnpAjusteTMP.FINDFIRST THEN
        lwImporte := lwImporte - prCnpAjusteTMP.Importe;

      lrLinDia.RESET;
      lrLinDia.SETRANGE("Journal Template Name", wDiarioGeneral);
      lrLinDia.SETRANGE("Journal Batch Name"   , USERID);
      IF lrLinDia.FINDLAST THEN
        lwNumLin := lrLinDia."Line No." + 10000
      ELSE
        lwNumLin := 10000;

      //-$012lrLinDia.SETCURRENTKEY("Journal Template Name", "Journal Batch Name", "Posting Date", "Transaction No.");
      lrLinDia.SETCURRENTKEY("Journal Template Name", "Journal Batch Name", "Transaction No."); //+$012
      lrLinDia.SETRANGE("Posting Date", TODAY);
      IF lrLinDia.FINDLAST THEN
        lwNumAsiento := lrLinDia."Transaction No." + 1
      ELSE
        lwNumAsiento := 1;

      lrLinDia.INIT;
      lrLinDia.VALIDATE("Journal Template Name"    , wDiarioGeneral);
      lrLinDia.VALIDATE("Journal Batch Name"       , USERID);
      lrLinDia.VALIDATE("Line No."                 , lwNumLin);
      lrLinDia.VALIDATE("Posting Date"             , TODAY);
      lrLinDia.VALIDATE("Document Type"            , lrLinDia."Document Type"::Payment);
      lrLinDia.VALIDATE("Document No."             , prCITMP.Bono);
      lrLinDia.VALIDATE("Account Type"             , lrLinDia."Account Type"::Customer);
      lrLinDia.VALIDATE("Account No."              , lrContV.Cliente);
      lrLinDia.VALIDATE(Description                , Text033 + prCITMP.Bono);
      lrLinDia.VALIDATE("Bal. Account Type"        , lrLinDia."Bal. Account Type"::"G/L Account");
      lrLinDia.VALIDATE("Bal. Account No."         , lrCuentas."Cta. comision hotel");
      lrLinDia.VALIDATE(Amount                     , lwImporte);
      lrLinDia.VALIDATE("Shortcut Dimension 1 Code", prCITMP.Delegacion);
      lrLinDia.VALIDATE("Shortcut Dimension 2 Code", prCITMP.TourOperador);
      lrLinDia.VALIDATE("Transaction No."          , lwNumAsiento);
      lrLinDia.VALIDATE("System-Created Entry"     , TRUE); //+$011
      lrLinDia."Source Code"   := rParAgencia.GetSourceCode(lrLinDia."Journal Template Name"); //+$013
      lrLinDia.INSERT(TRUE);
    END;

    LOCAL PROCEDURE _ContarPersonas@1100217000(prRsv@1100217000 : Record 7009743);
    VAR
      lrRsv2@1100217001 : Record 7009743;
      lrParPer@1100217002 : Record 7009701;
    BEGIN
      // _ContarPersonas

      wAdults := 0;
      wChilds := 0;

      lrParPer.FINDFIRST;

      lrRsv2.RESET;
      lrRsv2.SETCURRENTKEY(Delegacion,
                          "N§ Responsable");
      lrRsv2.SETRANGE(Delegacion      , prRsv.Delegacion);
      lrRsv2.SETRANGE("N§ Responsable", prRsv."N§ Reserva");
      IF lrRsv2.FINDSET(TRUE) THEN
      BEGIN
        REPEAT
          CASE lrRsv2."Tipo Persona" OF
            lrParPer."Codigo Adulto": wAdults += 1;
            lrParPer."Codigo Ni¤o": wChilds += 1;
          END;
        UNTIL lrRsv2.NEXT = 0;
      END;
    END;

    BEGIN
    {

      ## AJF 29/06/09

        .- (09/00319) cambio c¢digos de hotel de code10 a code20.

      JPT 21/11/11 GOC-CAR-10003 (2) Modificaciones Handling Fee. Nuevo formato factura hotel

      $003 JPT 06/03/12 El handling Fee lo separamos por precio. A¤adimos campo Precio a "C/I x Bono Concepto"

      $004 JPT 23/04/12 CNT-CAR-12004 HOT-18

      $005 AJS 10052012 Nuevo campo en las lineas de concepto para indicar las que apuntan a una tarifa y las
                        que vienen de contrato venta

      $006 JPT 02/08/12 GOC-LP-12019 Si no se marca "Marcar reservas" solo grabar la informaci¢n de coste.

      $007 AJS 23082012 Control de seguridad por usuario

      $008 AJS 27122012 No dejamos cerrar reservas que no han llegado, salvo en el caso de cierres de solo coste

      $009 AJS 01012013 Rellenar el numero de cierre en la tabla de detalle por concepto

      $010 AJS 02012013 Rellenar el numero de adultos/ni¤os en el cierre

      $011 AJS 10102013 Marco la linea de asiento de comision como Asiento automatico para que no se pueda borrar

      $012 AJS 19112013 Sustituyo la clave a la hora de buscar el ultimo numero de asiento

      $013 AJS 09022015 Rellenar el campo Source code del diario
    }
    END.
  }
}
