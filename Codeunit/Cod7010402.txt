OBJECT Codeunit 7010402 Importacion TRN
{
  OBJECT-PROPERTIES
  {
    Date=18/06/15;
    Time=17:35:43;
    Modified=Yes;
    Version List=TRANSFER;
  }
  PROPERTIES
  {
    OnRun=BEGIN
            Inicia(0);
          END;

  }
  CODE
  {
    VAR
      Text50000@1103355013 : TextConst 'ESP=Microsoft Common Dialog Control, version 6.0';
      Text50001@1103355014 : TextConst 'ESP=Importacion';
      Text50002@1103355015 : TextConst 'ESP=XML';
      Text50003@1103355016 : TextConst 'ESP=TXT';
      Text50004@1103355017 : TextConst 'ESP=Partes';
      Text50005@1103355018 : TextConst 'ESP=SERVICIO';
      Text50006@1103355019 : TextConst 'ESP=ZonaTrabajo';
      Text50007@1103355020 : TextConst 'ESP=Cliente';
      Text50008@1103355021 : TextConst 'ESP=TTOO';
      Text50009@1103355022 : TextConst 'ESP=Garaje';
      Text50010@1103355023 : TextConst 'ESP=Referencia';
      Text50011@1103355024 : TextConst 'ESP=NoParte';
      Text50012@1103355025 : TextConst 'ESP=CodigoServicio';
      Text50013@1103355026 : TextConst 'ESP=Fecha';
      Text50014@1103355027 : TextConst 'ESP=Guia';
      Text50015@1103355028 : TextConst 'ESP=HoraInicio';
      Text50016@1103355029 : TextConst 'ESP=LugarPresentacion';
      Text50017@1103355030 : TextConst 'ESP=Shuttle';
      Text50018@1103355031 : TextConst 'ESP=si';
      Text50019@1103355032 : TextConst 'ESP=Observaciones';
      Text50020@1103355033 : TextConst 'ESP=Letreros';
      Text50021@1103355034 : TextConst 'ESP=Vehiculo';
      Text50022@1103355035 : TextConst 'ESP=Conductor';
      Text50023@1103355036 : TextConst 'ESP=Origen-Destino';
      Text50024@1103355037 : TextConst 'ESP=Vuelos';
      Text50025@1103355038 : TextConst 'ESP=RefVuelo';
      Text50026@1103355039 : TextConst 'ESP=Hora';
      Text50027@1103355040 : TextConst 'ESP=IATA';
      Text50028@1103355041 : TextConst 'ESP=EntSal';
      Text50029@1103355042 : TextConst 'ESP=E';
      Text50030@1103355043 : TextConst 'ESP=FechaLlegadaVuelo';
      Text50031@1103355044 : TextConst 'ESP=PuntoRecogida';
      Text50032@1103355045 : TextConst 'ESP=NombrePunto';
      Text50033@1103355046 : TextConst 'ESP=Adultos';
      Text50034@1103355047 : TextConst 'ESP=Ni¤os';
      Text50035@1103355048 : TextConst 'ESP=AdultosInvitados';
      Text50036@1103355049 : TextConst 'ESP=Ni¤osInvitados';
      Text50037@1103355050 : TextConst 'ESP=HoraVuelo';
      Text50038@1103355051 : TextConst 'ESP=NombrePax';
      Text50039@1103355052 : TextConst 'ESP=localizador';
      Text50040@1103355053 : TextConst 'ESP=NombreCliente';
      Text50041@1103355054 : TextConst 'ESP=Reserva';
      Text50042@1103355055 : TextConst 'ESP=ZonaFisica';
      Text50043@1103355056 : TextConst 'ESP=CodigoSupl';
      Text50044@1103355057 : TextConst 'ESP=Cantidad';
      Text50045@1103355058 : TextConst 'ESP=Codigo';
      Text50046@1103355059 : TextConst 'ESP=touroper';
      Text50047@1103355060 : TextConst 'ESP=fecha';
      Text50048@1103355061 : TextConst 'ESP=transfer';
      Text50049@1103355062 : TextConst 'ESP=servicio';
      Text50050@1103355063 : TextConst 'ESP=observa';
      Text50051@1103355064 : TextConst 'ESP=ls';
      Text50052@1103355065 : TextConst 'ESP=VUELOS';
      Text50053@1103355066 : TextConst 'ESP=orides';
      Text50054@1103355067 : TextConst 'ESP=vuelo';
      Text50055@1103355068 : TextConst 'ESP=hora';
      Text50056@1103355069 : TextConst 'ESP=HOTELES';
      Text50057@1103355070 : TextConst 'ESP=hotel';
      Text50058@1103355071 : TextConst 'ESP=pax';
      Text50059@1103355072 : TextConst 'ESP=enclave';
      Text50060@1103355073 : TextConst 'ESP=SHU';
      Text50061@1103355074 : TextConst 'ESP=<Month Text><Year>';
      Text50062@1103355075 : TextConst 'ESP=<YEAR>';
      Text50063@1103355076 : TextConst 'ESP=[dbo].[Gasoil_Absite_Mlg]';
      Text50064@1103355077 : TextConst 'ESP="DELETE FROM %1 WHERE FinbusNumImportacion=%2"';
      Text50065@1103355078 : TextConst 'ESP=SELECT * FROM %1 ORDER BY Id';
      Text50066@1103355079 : TextConst 'ESP=Id';
      Text50067@1103355080 : TextConst 'ESP=C';
      Text50068@1103355081 : TextConst 'ESP=K';
      Text50069@1103355082 : TextConst 'ESP=INSERT INTO %1 (Id) VALUES(%2)';
      Text50070@1103355083 : TextConst 'ESP=FinbusNumImportacion';
      Text50071@1103355084 : TextConst 'ESP=TipoTransaccion';
      Text50072@1103355085 : TextConst 'ESP=FechaVolcado';
      Text50073@1103355086 : TextConst 'ESP=HoraVolcado';
      Text50074@1103355087 : TextConst 'ESP=NumeroTransaccion';
      Text50075@1103355088 : TextConst 'ESP=NumeroBorna';
      Text50076@1103355089 : TextConst 'ESP=NumeroEsclavo';
      Text50077@1103355090 : TextConst 'ESP=Identificacion';
      Text50078@1103355091 : TextConst 'ESP=NumeroTransaccionBorna';
      Text50079@1103355092 : TextConst 'ESP=FechaTransaccion';
      Text50080@1103355093 : TextConst 'ESP=HoraTransaccion';
      Text50081@1103355094 : TextConst 'ESP=IndiceExpendedor';
      Text50082@1103355095 : TextConst 'ESP=NumeroPertenenciaBorna';
      Text50083@1103355096 : TextConst 'ESP=TipoIdentificacionVehiculo';
      Text50084@1103355097 : TextConst 'ESP=NumeroServicioVehiculo';
      Text50085@1103355098 : TextConst 'ESP=IdentificacionServicioVehiculo';
      Text50086@1103355099 : TextConst 'ESP=NumeroVehiculo';
      Text50087@1103355100 : TextConst 'ESP=IdentificacionVehiculo';
      Text50088@1103355101 : TextConst 'ESP=InfoCompVeh1';
      Text50089@1103355102 : TextConst 'ESP=InfoCompVeh2';
      Text50090@1103355103 : TextConst 'ESP=InfoCompVeh3';
      Text50091@1103355104 : TextConst 'ESP=InfoCompVeh4';
      Text50092@1103355105 : TextConst 'ESP=InfoCompVeh5';
      Text50093@1103355106 : TextConst 'ESP=TipoIdentificacionConductor';
      Text50094@1103355107 : TextConst 'ESP=NumeroServicioConductor';
      Text50095@1103355108 : TextConst 'ESP=IdentificacionServicioConductor';
      Text50096@1103355109 : TextConst 'ESP=NumeroConductor';
      Text50097@1103355110 : TextConst 'ESP=IdentificacionConductor';
      Text50098@1103355111 : TextConst 'ESP=InfoCompCond1';
      Text50099@1103355112 : TextConst 'ESP=InfoCompCond2';
      Text50100@1103355113 : TextConst 'ESP=InfoCompCond3';
      Text50101@1103355114 : TextConst 'ESP=InfoCompCond4';
      Text50102@1103355115 : TextConst 'ESP=InfoCompCond5';
      Text50103@1103355116 : TextConst 'ESP=ContadorAnterior';
      Text50104@1103355117 : TextConst 'ESP=ContadorActual';
      Text50105@1103355118 : TextConst 'ESP=TipoContador';
      Text50106@1103355119 : TextConst 'ESP=Obra';
      Text50107@1103355120 : TextConst 'ESP=IdentificacionObra';
      Text50108@1103355121 : TextConst 'ESP=NumeroProducto';
      Text50109@1103355122 : TextConst 'ESP=IdentificacionProducto';
      Text50110@1103355123 : TextConst 'ESP=NumeroSurtidor';
      Text50111@1103355124 : TextConst 'ESP=VolumenTransaccionCL';
      Text50112@1103355125 : TextConst 'ESP=NumeroTanque';
      Text50113@1103355126 : TextConst 'ESP=IdentificacionTanque';
      Text50114@1103355127 : TextConst 'ESP=CantidadTanqueCL';
      Text50115@1103355128 : TextConst 'ESP=ErrorTransaccion';
      Text50116@1103355129 : TextConst 'ESP=InformeImpresoraBorna';
      Text50117@1103355130 : TextConst 'ESP=CuotaNoValidaVehiculo';
      Text50118@1103355131 : TextConst 'ESP=CuotaVehiculo';
      Text50119@1103355132 : TextConst 'ESP=CuotaNoValidaVehiculo2';
      Text50120@1103355133 : TextConst 'ESP=CuotaVehiculo2';
      Text50121@1103355134 : TextConst 'ESP=ProcedenciaTransaccion';
      Text50122@1103355135 : TextConst 'ESP=InfoCompTrs1';
      Text50123@1103355136 : TextConst 'ESP=InfoCompTrs2';
      Text50124@1103355137 : TextConst 'ESP=InfoCompTrs3';
      Text50125@1103355138 : TextConst 'ESP=InfoCompTrs4';
      Text50126@1103355139 : TextConst 'ESP=InfoCompTrs5';
      Text50127@1103355140 : TextConst 'ESP=InfoCompTrs6';
      Text50128@1103355141 : TextConst 'ESP=InfoCompTrs7';
      Text50129@1103355142 : TextConst 'ESP=InfoCompTrs8';
      Text50130@1103355143 : TextConst 'ESP=InfoCompTrs9';
      Text50131@1103355144 : TextConst 'ESP=InfoCompTrs10';
      Text50132@1103355145 : TextConst 'ESP="UPDATE %1 SET %2=%3 WHERE Id=%4"';
      Text50133@1103355146 : TextConst 'ESP=I';
      Text50134@1103355147 : TextConst 'ESP=D';
      Text50135@1103355148 : TextConst 'ESP=X';
      Text50136@1103355149 : TextConst 'ESP=G';
      Text50137@1103355150 : TextConst 'ESP=CC';
      Text50138@1103355151 : TextConst 'ESP=T';
      Text50139@1103355152 : TextConst 'ESP=S';
      Text50140@1103355153 : TextConst 'ESP=H';
      Text50141@1103355154 : TextConst 'ESP=A';
      Text50142@1103355155 : TextConst 'ESP=Z';
      Text50143@1103355156 : TextConst 'ESP=EUROPALIA';
      Text50144@1103355157 : TextConst 'ESP=<+1D>';
      SLin@1100244038 : TextConst 'ESP=""';
      Text0001@1100244000 : TextConst 'ESP=No se encuentra Archivo %1';
      wArch@1100244001 : File;
      rParImp@1100244002 : Record 7010433;
      rPar@1100244010 : Record 7010311;
      wVentana@1100244003 : Dialog;
      Text0002@1100244004 : TextConst 'ESP=Importando @1@@@@@@@\Archivo    #2##########';
      Text0003@1100244005 : TextConst 'ESP="Comprobando Errores Importaci¢n %1\#2#########  @3@@@@@@@@@ "';
      Text0004@1100244006 : TextConst 'ESP=Lineas';
      Text0005@1100244007 : TextConst 'ESP=Cabecera';
      Text0006@1100244008 : TextConst 'ESP=No se encuentra Importaci¢n %1';
      Text0007@1100244009 : TextConst 'ESP=La Importaci¢n %1 ya ha sido Transferida';
      Text0008@1100244011 : TextConst 'ESP=El Parte %1 ya est  confirmado';
      Text0009@1100244012 : TextConst 'ESP=¨Desea Realmente Traspasar %3 Toda la Importacion N§%1?';
      Text0010@1100244013 : TextConst 'ESP=¨Desea Realmente Traspasar %3 la Cabecera %2 de la Importacion N§%1?';
      Text0011@1100244014 : TextConst 'ESP="Traspasando Importaci¢n %1\Cabecera #2##  #3#######\ @4@@@@@@@@@ "';
      Text0012@1100244015 : TextConst 'ESP=La importaci¢n %1 ya est  anulada';
      Text0013@1100244016 : TextConst 'ESP="Anulando Importacion  %1 @2@@@@@@@@@ "';
      Text0014@1100244017 : TextConst 'ESP=¨Desea Realmente Anular la Importaci¢n %1?';
      Text0015@1100244018 : TextConst 'ESP=No se puede traspasar la Importacion %1 Hasta que no se haya traspasado la %2';
      Text0016@1100244019 : TextConst 'ESP=¨Desea Realmente Anular la Cabecera %2 de la Importaci¢n %1?';
      GestNoSerie@1100244020 : Codeunit 396;
      Text0017@1100244021 : TextConst 'ESP=No se encuentra ninguna importaci¢n para transferir';
      Text0018@1100244022 : TextConst 'ESP=Se ha tranferido la importaci¢n %1';
      Text0019@1100244023 : TextConst 'ESP=No se ha podido transferir toda la importaci¢n %1';
      Text0020@1100244024 : TextConst 'ESP=La Importaci¢n %1 est  Anulada';
      Text0021@1100244025 : TextConst 'ESP=IMP_';
      Text0022@1100244026 : TextConst 'ESP=No se encuentra %1 %2 \¨Desea Continuar con la importaci¢n?';
      Text0023@1100244027 : TextConst 'ESP=Operaci¢n anulada';
      Text0024@1100244029 : TextConst 'ESP="Accion= %1 Desconocida"';
      Text0025@1100244030 : TextConst 'ESP=¨Desea Actualizar las incidencias de conductor?';
      Text0026@1100244031 : TextConst 'ESP=No se ha encontrado ning£n cambio';
      Text0027@1100244032 : TextConst 'ESP=GESTRANS %1';
      Text0028@1100244033 : TextConst 'ESP=Se han producido errores';
      Text0029@1100244034 : TextConst 'ESP=No se encuentra el C¢digo %1';
      Text0030@1100244035 : TextConst 'ESP=No se encuentra cond. %1';
      Text0031@1100244036 : TextConst 'ESP=No se pudo borrar';
      Text0032@1100244037 : TextConst 'ESP=Importando @1@@@@@@@\Archivo    #2##########################\#3##';
      Text0034@1100244028 : TextConst 'ESP=No se encuentra conversion %1 %2,';
      Text0035@1100244039 : TextConst 'ESP=Fecha Registro #1#######';
      Text0036@1100244040 : TextConst 'ESP=No se ha encontrado ning£n archivo';
      cFunAdic@1103355003 : Codeunit 7010410;
      wArchDialog@1100244041 : OCX "{F9043C85-F6F2-101A-A3C9-08002B2F49FB}:'Microsoft Common Dialog Control, version 6.0'";
      Text0037@1100244042 : TextConst 'ESP=Solo puede traspasar importaciones de otro usuario si No tiene ninguna propia por traspasar';
      Text0038@1100244043 : TextConst 'ESP=Esta importaci¢n ha sido creada por el usuario %1.\¨Desea Continuar?';
      Text0039@1100244044 : TextConst 'ESP=No se ha encontrado ninguna reserva por traspasar';
      Text0040@1100244045 : TextConst 'ESP=La cabecera %1 ya ha sido traspasada';
      Text0041@1100244046 : TextConst 'ESP=La cabecera %1 Tiene errores';
      Text0042@1100244047 : TextConst 'ESP=La cabecera %1 ha sido anulada';
      Text0043@1103350000 : TextConst 'ESP=e imprimir';
      Text0044@1103350001 : TextConst 'ESP="Provider=SQLOLEDB;Data Source=%1;Initial Catalog=%2;"';
      Text0045@1100253000 : TextConst 'ESP=El archivo %1\ NO tiene registros';
      Text0046@1100253001 : TextConst 'ESP=Suplementos';
      Text0047@1100253002 : TextConst 'ESP=Extras';
      Text0048@1100253003 : TextConst 'ESP=El Servicio %1 No est  autorizado';
      Text0049@1103355000 : TextConst 'ESP=El servicio %1 esta repetido en este fichero para la agencia %2 dia %3.';
      Text0050@1103355001 : TextConst 'ESP=El archivo %1 ya ha sido impotado por usuario %2 (%3 %4)\La importaci¢n debe de ser Transferida o Anulada antes de volverse a cargar';
      Text0051@1103355002 : TextConst 'ESP=Este parte ha sido facturado como minimo una vez, no puede ser borrado, puede emitir el abono dejando el parte como pendiente.';
      Text0052@1103355004 : TextConst 'ESP=La importaci¢n %1 a£n tiene lineas Modificacion sin autorizar.\¨Desea Marcarla como Traspasada de Todos Modos?';
      Text0053@1103355005 : TextConst 'ESP=La anulaci¢n de la importaci¢n %1 conllevar  el borrado de %2 Partes ya creados.¨Desea Seguir?';
      Text0054@1103355006 : TextConst 'ESP=BORRADO';
      Text0055@1103355007 : TextConst 'ESP=''FECHA PARTE  ''';
      Text0056@1103355008 : TextConst 'ESP=Es necesario especificar el Codigo Finbus de Cliente %1 %2';
      Text0057@1103355009 : TextConst 'ESP=Es necesario especificar el Codigo Finbus de Touroperador %1 %2';
      Text0058@1103355010 : TextConst 'ESP=No est n permitidos los archivos de tipo %1';
      Text0059@1103355011 : TextConst 'ESP=Linea Manual, debe definir un orden(No puede tener orden 0)';
      cGestionParte@1103355012 : Codeunit 7010318;
      Text50145@1000000000 : TextConst 'ESP=CSV';
      cImpIBZ@1000000001 : Codeunit 7035328;

    PROCEDURE Inicia@1100244005(pwTipo@1100244004 : 'Reserva,Surtidor');
    VAR
      lrArchivos@1100244000 : Record 2000000022;
      lwTotal@1100244001 : Integer;
      lwCont@1100244002 : Integer;
      lwPath@1100244003 : Text[1000];
      lwShow@1100244005 : Boolean;
    BEGIN
      // Inicia

      rPar.GET;
      rParImp.GET;

      lrArchivos.RESET;
      IF NOT BuscarArchivo(lrArchivos,pwTipo) THEN
        EXIT;

      lwShow := pwTipo IN [pwTipo::Reserva];

      IF lrArchivos.FINDSET THEN BEGIN
        IF lwShow THEN BEGIN
          wVentana.OPEN(Text0002);
          lwTotal := lrArchivos.COUNT;
          lwCont  := 0;
        END;
        REPEAT
          IF lwShow THEN
            wVentana.UPDATE(2, lrArchivos.Name);
          lwPath := lrArchivos.Path;
          IF lwPath[STRLEN(lwPath)] <>'\' THEN
            lwPath := lwPath +'\';
          CASE pwTipo OF
            pwTipo::Reserva : ImportaArchivo(lwPath + lrArchivos.Name);
            pwTipo::Surtidor: ImportaArchivoSurtidor2(lwPath + lrArchivos.Name);
          END;
          lwCont +=1;
          IF lwShow THEN
            wVentana.UPDATE(1,ROUND(lwCont/lwTotal*10000,1));
        UNTIL lrArchivos.NEXT=0;
        IF lwShow THEN
          wVentana.CLOSE;
      END ELSE
        ERROR(Text0036);
    END;

    PROCEDURE IniciaSurtidor@1100244026();
    VAR
      lwArchivo@1100244000 : Text[1024];
    BEGIN
      // IniciaSurtidor

      lwArchivo:= BuscarArchivo2(1);
      IF NOT EXISTS(lwArchivo) THEN
        EXIT;
      ImportaArchivoSurtidor2(lwArchivo);
    END;

    PROCEDURE BuscarArchivo@1100244001(VAR prArchivos@1100244001 : Record 2000000022;pwTipo@1100244003 : 'Reserva,Surtidor') : Boolean;
    VAR
      lfDirect@1100244000 : Form 7035279;
      lwOk@1100244002 : Boolean;
      lwDirectINI@1100244004 : Text[500];
    BEGIN
      // BuscarArchivo

      rParImp.FINDFIRST;
      rParImp.TESTFIELD("Directorio Archivos");
      lwOk:= FALSE;

      CASE pwTipo OF
        pwTipo::Reserva : lwDirectINI := rParImp."Directorio Archivos";
        pwTipo::Surtidor: lwDirectINI := rParImp."Directorio Archivos Surtidor";
      END;

      lfDirect.FiltrarDirectorio(lwDirectINI);
      IF NOT(lfDirect.RUNMODAL IN [ACTION::LookupCancel,ACTION::Cancel]) THEN BEGIN
        IF lfDirect.OK THEN BEGIN
          lfDirect.PasarArchivos(prArchivos);
          prArchivos.SETRANGE("Is a file",TRUE);
          lwOk:= TRUE;
        END;
      END;
      EXIT(lwOk);
    END;

    PROCEDURE BuscarArchivo2@1100244023(pwTipo@1100244001 : 'Reserva,Surtidor') : Text[1024];
    VAR
      lfDirect@1100244000 : Form 7035279;
      lwOk@1100244002 : Boolean;
      lwDirectINI@1100244004 : Text[500];
    BEGIN
      // BuscarArchivo

      rParImp.FINDFIRST;
      rParImp.TESTFIELD("Directorio Archivos");

      CASE pwTipo OF
        pwTipo::Reserva : lwDirectINI := rParImp."Directorio Archivos";
        pwTipo::Surtidor: lwDirectINI := rParImp."Directorio Archivos Surtidor";
      END;

      wArchDialog.DefaultExt  := '*.*';
      wArchDialog.DialogTitle := Text50001;
      wArchDialog.InitDir := lwDirectINI;
      wArchDialog.ShowOpen;
      EXIT(wArchDialog.FileName);
    END;

    PROCEDURE ImportaArchivo@1100244000(pwNombreArchivo@1100244000 : Text[150]) : Text[250];
    VAR
      lrImp@1100244002 : Record 7035333;
      lrLin@1100244003 : Record 7010432;
      lrCab@1100244004 : Record 7010431;
      lrCab2@1100244008 : Record 7010431;
      lwHora@1100244005 : Time;
      lwInt@1100244007 : Integer;
      lwFecha@1100244006 : Date;
      lwExt@1100244010 : Code[3];
      lwCliente@1100244011 : Code[20];
      lwTTOO@1100244012 : Code[10];
      lwObsv@1100253000 : Text[1024];
      lwTexto@1103355000 : Text[1024];
    BEGIN
      // ImportaArchivo

      IF NOT EXISTS(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      // JPT 23/08/06 No permitimos que otro usuario importe el mismo archivo
      CompruebaImportado(pwNombreArchivo,2);

      // Si es en formato XML lo desvia a otra funci¢n
      lwExt := COPYSTR(pwNombreArchivo,STRLEN(pwNombreArchivo)-2,3);
      IF lwExt =Text50002 THEN BEGIN
        SeleccionaXML(pwNombreArchivo);
        EXIT;
      END;

      // +$001 Si es en formato CSV lo desvia a otra funci¢n
      IF lwExt =Text50145 THEN BEGIN
        ImportaCSV(pwNombreArchivo);
        EXIT;
      END;

      // JPT 14/04/08 Solo debe de permitirse archivos XML o TXT
      IF NOT (lwExt IN ['XML','TXT']) THEN
        ERROR(Text0058, lwExt);

      wArch.TEXTMODE(TRUE);

      IF NOT wArch.OPEN(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      //  Se crea Historico Importacion

      lrImp.RESET;
      lrImp.INIT;
      lrImp.Archivo := Extractfilename(pwNombreArchivo);
      lrImp.Tipo    := lrImp.Tipo::Reserva;
      lrImp.INSERT(TRUE);

      lrLin.RESET;
      REPEAT
        wArch.READ(lwTexto);
        lwTexto := ConvASCII_ANSI(lwTexto); // Convertimos de ASCII a ANSI
        IF lwTexto <> '' THEN BEGIN
          lrLin.INIT;
          lrLin.Importacion := lrImp."No Importacion";
          lrLin.Zona                 := COPYSTR(lwTexto,3,3);
          lrLin.Agencia              := DELCHR(COPYSTR(lwTexto,6,5),'<>');
          lwCliente := CreaCodigo(2,lrLin.Agencia,'','','');
          lrLin.Subagencia           := lrLin.Agencia + '-' + DELCHR(COPYSTR(lwTexto,11,4),'<>',' ');
          lwTTOO := CreaCodigo(3, lrLin.Subagencia,lwCliente,'','');
          lrLin.Emp                  := DELCHR(COPYSTR(lwTexto,1,2),'<>');
          CreaCodigo(0,lrLin.Emp,lwCliente,lwTTOO,'');
          lrLin.Servicio             := COPYSTR(lwTexto,15,5);
          lrLin."Agencia Viaje"      := DELCHR(COPYSTR(lwTexto,20,5),'<>');
          CreaCodigo(1,lrLin."Agencia Viaje",lwCliente,lwTTOO,'');
          IF EVALUATE(lwFecha , COPYSTR(lwTexto,31,2) + COPYSTR(lwTexto,29,2) + COPYSTR(lwTexto,25,4)) THEN
            lrLin.Fecha              := lwFecha;

          // AJS 21.07.2006 ## DRF 06008
          // Los vuelos es importan en una tabla aparte, esta funcionalidad se aprovecha realmente en la importacion
          // de XML, aqui se mantiene por coherencia, el codigo se ha pasado despues de crear la cabecera porque
          // necesito el numero de cabecera para la clave primaria del vuelo

          {*******
          lrLin.Vuelo1               := COPYSTR(lwTexto,33,8);
          IF EVALUATE(lwHora, STRSUBSTNO('%1:%2',COPYSTR(lwTexto,41,2),COPYSTR(lwTexto,43,2))) THEN
            lrLin."Hora Vuelo1"      := lwHora;
          lrLin.Vuelo2               := COPYSTR(lwTexto,45,8);
          IF EVALUATE(lwHora, STRSUBSTNO('%1:%2',COPYSTR(lwTexto,53,2),COPYSTR(lwTexto,55,2))) THEN
            lrLin."Hora Vuelo2"      := lwHora;
          lrLin.Vuelo3               := COPYSTR(lwTexto,57,8);
          IF EVALUATE(lwHora, STRSUBSTNO('%1:%2',COPYSTR(lwTexto,65,2),COPYSTR(lwTexto,67,2))) THEN
            lrLin."Hora Vuelo3"      := lwHora;
          *******}

          IF EVALUATE(lwHora, STRSUBSTNO('%1:%2',COPYSTR(lwTexto,69,2),COPYSTR(lwTexto,71,2))) THEN
            lrLin."Hora Aeropuerto"  := lwHora;
          lrLin."Nombre Guia"        := COPYSTR(lwTexto,73,20);
          lrLin.Destino              := COPYSTR(lwTexto,93,15);
          IF EVALUATE(lwHora, STRSUBSTNO('%1:%2',COPYSTR(lwTexto,108,2),COPYSTR(lwTexto,110,2))) THEN
            lrLin."Hora Presentacion"  := lwHora;
          lrLin."Lugar Presentacion" := DELCHR(COPYSTR(lwTexto,112,25),'<>');
          lrLin."Codigo Hotel"       := DELCHR(COPYSTR(lwTexto,137,5) ,'<>');
          lrLin."Nombre Hotel"       := DELCHR(COPYSTR(lwTexto,142,20),'<>');
          CreaCodigo(5,lrLin."Codigo Hotel",lwCliente,lwTTOO,lrLin."Nombre Hotel");

          IF EVALUATE(lwInt , COPYSTR(lwTexto,162,3)) THEN
            lrLin."Numero Adultos"     := lwInt;
          IF EVALUATE(lwInt , COPYSTR(lwTexto,165,3)) THEN
            lrLin."Numero Ni¤os"       := lwInt;
          lrLin.Observaciones        := DELCHR(COPYSTR(lwTexto,168,25),'<>');
          lrLin."Codigo Suplemento"  := DELCHR(COPYSTR(lwTexto,196,10),'<>');
          CreaCodigo(4,lrLin."Codigo Suplemento",lwCliente,lwTTOO,'');
          IF EVALUATE(lwInt , COPYSTR(lwTexto,206,3)) THEN
          lrLin."Cantidad Suplemento":= lwInt;
          lrLin."Observaciones B"    := DELCHR(COPYSTR(lwTexto,209,100),'<>');

          // Busca si existe la cabecera, si no la crea

          lrCab.RESET;
          lrCab.SETCURRENTKEY(Importacion,
                              Fecha,
                              Agencia,
                              Subagencia,
                              Servicio);
          lrCab.SETRANGE(Importacion, lrLin.Importacion);
          lrCab.SETRANGE(Fecha      , lrLin.Fecha);
          lrCab.SETRANGE(Agencia    , lrLin.Agencia);
          lrCab.SETRANGE(Subagencia , lrLin.Subagencia);
          lrCab.SETRANGE(Servicio   , lrLin.Servicio);
          IF NOT lrCab.FINDFIRST THEN BEGIN
            lrCab.INIT;       // Crea La cabecera
            lrCab.Importacion := lrLin.Importacion;
            lrCab.Agencia     := lrLin.Agencia;
            lrCab.Subagencia  := lrLin.Subagencia;
            lrCab.Servicio    := lrLin.Servicio;
            lrCab.Fecha       := lrLin.Fecha;

            // AJS 04.06.2008
            // Incluimos una marca para saber si la cabecera se ha creado a partir de
            // un fichero XML, para gestionar las observaciones de manera diferente

            lrCab."Fichero XML" := (lwExt = Text50002);

            lrCab.INSERT(TRUE);

            BuscaParte(lrCab, TRUE);

            // AJS 21.07.2006  ## DRF 06008
            // Dar de alta los vuelos en una tabla asociada a la cabecera de importacion

            InsertaVuelosTXT(lrCab, lwTexto);

          END;

          // JPT 18/04/06 Introducimos dos nuevos campos

          IF lrCab.Referencia ='' THEN BEGIN
            lrCab.Referencia := DELCHR(COPYSTR(lwTexto,409,50),'<>');
          END;
          // Observaciones cabecera
          lwObsv := DELCHR(COPYSTR(lwTexto,309,100),'<>');
          IF (lwObsv <> '')  AND (STRPOS(lrCab.Observaciones, lwObsv)=0) THEN BEGIN
            IF lrCab.Observaciones <> '' THEN
              lwObsv := STRSUBSTNO(', %1', lwObsv);
            IF STRLEN(lrCab.Observaciones)  + STRLEN(lwObsv) <= MAXSTRLEN(lrCab.Observaciones) THEN
              lrCab.Observaciones += lwObsv;
          END;
          lrCab.MODIFY;
          // JPT 18/04/06

          lrLin."No Cabecera" := lrCab."No.";
          lrLin.INSERT(TRUE);
        END;
      UNTIL wArch.POS= wArch.LEN;
      wArch.CLOSE;
      MueveArchivo(lrImp."No Importacion",pwNombreArchivo);
    END;

    PROCEDURE SeleccionaXML@1103355009(pwNombreArchivo@1103355001 : Text[150]);
    VAR
      lwTipo@1103355000 : Integer;
      Nodo@1103355002 : ARRAY [10] OF Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";
      XML@1103355003 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{F6D90F11-9C73-11D3-B32E-00C04F990BB4}:'Microsoft XML, v4.0'.DOMDocument";
    BEGIN
      // SeleccionaXML

      IF NOT EXISTS(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      IF ISCLEAR(XML) THEN
        CREATE(XML);
      IF NOT XML.load(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      CLEAR(lwTipo);

      Nodo[1] := XML.documentElement;

      Nodo[2] := Nodo[1].selectSingleNode(Text50004);
      IF Nodo[1].nodeName = Text50004 THEN
        lwTipo := 1
      ELSE
      BEGIN
        Nodo[2] := Nodo[1].selectSingleNode(Text50005);
        IF NOT ISCLEAR(Nodo[2]) THEN
          lwTipo := 2
        ELSE
          lwTipo := 3;
      END;

      CLEAR(Nodo);
      CLEAR(XML);

      CASE lwTipo OF
        1 : ImportaArchivoXML1(pwNombreArchivo);
        2 : ImportaArchivoXML2(pwNombreArchivo);
        3 : cImpIBZ.ImportaXMLIBERO(pwNombreArchivo);
      END;
    END;

    PROCEDURE ImportaArchivoXML1@1100244022(pwNombreArchivo@1100244000 : Text[150]) : Integer;
    VAR
      lrImp@1100244002 : Record 7035333;
      lrLin@1100244003 : Record 7010432;
      lrCab@1100244004 : Record 7010431;
      lrCab2@1100244008 : Record 7010431;
      lrExSupl@1100253004 : Record 7035389;
      lrVuelo@1103355009 : Record 7035391;
      Nodo@1100244010 : ARRAY [10] OF Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";
      XML@1100244011 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{F6D90F11-9C73-11D3-B32E-00C04F990BB4}:'Microsoft XML, v4.0'.DOMDocument";
      lwCont@1100244012 : ARRAY [10] OF Integer;
      lwTotal@1100244013 : ARRAY [10] OF Integer;
      lwInt@1103355000 : Integer;
      lwPos@1103355002 : Integer;
      lwNumVuelos@1103355008 : Integer;
      lwCont2@1103355001 : Integer;
      lwBol@1103350000 : Boolean;
      lwVuelos@1100253000 : Text[100];
      lwTexto@1103355005 : Text[500];
      lwCod@1100253003 : Code[25];
      lwCliente@1103355004 : Code[20];
      lwTTOO@1103355003 : Code[10];
      lwHora@1103355007 : Time;
      lwFecha@1103355006 : Date;
      lwShuttle@1103355010 : Boolean;
    BEGIN
      // ImportaArchivoXML1
      // Devuelve el numero de importacion creado

      rPar.FINDFIRST;
      rParImp.FINDFIRST;

      IF NOT EXISTS(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      IF ISCLEAR(XML) THEN
        CREATE(XML);
      IF NOT XML.load(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      //  Se crea Historico Importacion

      lrImp.RESET;
      lrImp.INIT;
      lrImp.Archivo := Extractfilename(pwNombreArchivo);
      lrImp.Tipo    := lrImp.Tipo::Reserva;
      lrImp.INSERT(TRUE);

      lrLin.RESET;

      Nodo[1] := XML.documentElement;
      //Nodo[1] := Nodo[1].selectSingleNode(Text50004);


      CLEAR(lwTotal);
      // NodeList[1] := XML.getElementsByTagName(Text50004);
      // lwTotal[1] := NodeList[1].length;
      Nodo[2]:= Nodo[1].firstChild;
      IF NOT ISCLEAR(Nodo[2]) THEN BEGIN
        REPEAT
          lwTexto:= Nodo[2].nodeName;
          lrLin.INIT;
          lrLin.Importacion := lrImp."No Importacion";
          lrLin.Zona                 := LeeAtributoTrnc(Nodo[2],Text50006, MAXSTRLEN(lrLin.Zona));
          lrLin.Agencia              := LeeAtributoTrnc(Nodo[2],Text50007, MAXSTRLEN(lrLin.Agencia));
          lwCliente:= CreaCodigo(2,lrLin.Agencia,'','','');
          lrLin.Subagencia           := lrLin.Agencia + '-' + LeeAtributoTrnc(Nodo[2],Text50008,10);
          lwTTOO:= CreaCodigo(3, lrLin.Subagencia,lwCliente,'','');
          lrLin.Emp                  := LeeAtributoTrnc(Nodo[2],Text50009, MAXSTRLEN(lrLin.Emp));
          CreaCodigo(0,lrLin.Emp,lwCliente,lwTTOO,'');
          lrLin.Servicio             := LeeAtributoTrnc(Nodo[2],Text50010, MAXSTRLEN(lrLin.Servicio));
          IF lrLin.Servicio = '' THEN
            lrLin.Servicio           := LeeAtributoTrnc(Nodo[2],Text50011, MAXSTRLEN(lrLin.Servicio));

          lrLin."Agencia Viaje"      := LeeAtributoTrnc(Nodo[2],Text50012, MAXSTRLEN(lrLin."Agencia Viaje"));
          CreaCodigo(1,lrLin."Agencia Viaje",lwCliente,lwTTOO,'');
          IF EVALUATE(lwFecha , LeeAtributo(Nodo[2],Text50013)) THEN
            lrLin.Fecha              := lwFecha;
          lrLin."Nombre Guia"        := LeeAtributoTrnc(Nodo[2],Text50014, MAXSTRLEN(lrLin."Nombre Guia"));
          IF EVALUATE(lwHora, LeeAtributo(Nodo[2],Text50015)) THEN
            lrLin."Hora Presentacion"  := lwHora;

          lrLin."Lugar Presentacion"   := LeeAtributoTrnc(Nodo[2],Text50016, MAXSTRLEN(lrLin."Lugar Presentacion"));

          // Buscamos si ya hay alg£n parte existente
          { // Sustuido por
          lrCab2.RESET;
          lrCab2.SETCURRENTKEY(Importacion,Fecha,Agencia,Subagencia,Servicio);
          lrCab2.SETRANGE(Agencia    , lrLin.Agencia);
          lrCab2.SETRANGE(Subagencia , lrLin.Subagencia);
          lrCab2.SETRANGE(Servicio   , lrLin.Servicio);
          lrCab2.SETRANGE(Fecha      , lrLin.Fecha);
          lrCab2.SETRANGE(Traspasada,TRUE);
          IF NOT lrCab2.FINDFIRST THEN
                 CLEAR(lrCab2);
          }
          lrCab.INIT;       // Crea La cabecera
          // AJF 24.01.2008
          // Campo nuevo para reservas shuttle.
          lwShuttle := FALSE;
          IF (LeeAtributoTrnc(Nodo[2],Text50017, 2) = Text50018) THEN
            lwShuttle := TRUE;
          lrCab."Servicio shuttle" := lwShuttle;
          // AJF Fin.
          lrCab.Importacion   := lrLin.Importacion;
          lrCab.Agencia       := lrLin.Agencia;
          lrCab.Subagencia    := lrLin.Subagencia;
          lrCab.Servicio      := lrLin.Servicio;
          lrCab.Fecha         := lrLin.Fecha;
          //lrCab.NoParte       := lrCab2.NoParte;
          lrCab."No. Parte Origen" := LeeAtributoTrnc(Nodo[2],Text50011, MAXSTRLEN(lrCab."No. Parte Origen"));
          lrCab.Observaciones := LeeAtributoTrnc(Nodo[2],Text50019, MAXSTRLEN(lrCab.Observaciones));
          lrCab.Referencia    := LeeAtributoTrnc(Nodo[2],Text50010, MAXSTRLEN(lrCab.Referencia));
          lrCab.Letreros      := LeeAtributoTrnc(Nodo[2],Text50020, MAXSTRLEN(lrCab.Letreros));
          lrCab.Vehiculo      := LeeAtributoTrnc(Nodo[2],Text50021, MAXSTRLEN(lrCab.Vehiculo));
          lrCab.Conductor     := LeeAtributoTrnc(Nodo[2],Text50022, MAXSTRLEN(lrCab.Conductor));
          // JPT 10/10/06 Nuevo campo
          lrCab."Origen/Destino":= LeeAtributoTrnc(Nodo[2],Text50023, MAXSTRLEN(lrCab."Origen/Destino"));

          // AJS 04.06.2008
          // Incluimos una marca para saber si la cabecera se ha creado a partir de
          // un fichero XML, para gestionar las observaciones de manera diferente

          lrCab."Fichero XML" := TRUE;

          lrCab.INSERT(TRUE);

          BuscaParte(lrCab, TRUE);

          // Para cuando los vuelos estan en el archivo de vuelos x parte
          // Vuelos

          Nodo[3] := Nodo[2].selectSingleNode(Text50024);
          IF NOT ISCLEAR(Nodo[3]) THEN BEGIN
            lwCont[2]:=0;
            Nodo[4] := Nodo[3].firstChild;
            IF NOT ISCLEAR(Nodo[4]) THEN BEGIN
              lwNumVuelos := 100;
              REPEAT

                // AJS 21.07.2006  ## DRF 06008
                // Los vuelos se insertan en una tabla aparte para poder tener un numero ilimitado de vuelos por cabecera
                {*****
                lwTexto:= Nodo[2].nodeName;
                lwCont[2] +=1;

                CASE lwCont[2] OF
                  1 : BEGIN
                        lrLin.Vuelo1            := LeeAtributoTrnc(Nodo[4],Text50025, MAXSTRLEN(lrLin.Vuelo1));
                        IF EVALUATE(lwHora, LeeAtributo(Nodo[4],Text50026)) THEN
                          lrLin."Hora Vuelo1"   := lwHora;
                        lrLin.Destino           := LeeAtributoTrnc(Nodo[4],Text50027, lrLin.Destino);
                      END;
                  2 : BEGIN
                        lrLin.Vuelo2            := LeeAtributoTrnc(Nodo[4],Text50025, MAXSTRLEN(lrLin.Vuelo2));
                        IF EVALUATE(lwHora, LeeAtributo(Nodo[4],Text50026)) THEN
                          lrLin."Hora Vuelo2"   := lwHora;
                      END;
                  3 : BEGIN
                        lrLin.Vuelo3            := LeeAtributoTrnc(Nodo[4],Text50025, MAXSTRLEN(lrLin.Vuelo3));
                        IF EVALUATE(lwHora, LeeAtributo(Nodo[4],Text50026)) THEN
                          lrLin."Hora Vuelo3"   := lwHora;
                      END;
                END;
                ******}

                // Si se trata de la primera linea de vuelo hay que rellenar el campo destino de la linea

                IF lwNumVuelos = 100 THEN
                  lrLin.Destino := LeeAtributoTrnc(Nodo[4],Text50027, MAXSTRLEN(lrLin.Destino));

                CLEAR(lrVuelo);
                lrVuelo.Importacion    := lrCab.Importacion;
                lrVuelo."No. Cabecera" := lrCab."No.";
                lrVuelo."No. Vuelo"    := lwNumVuelos;
                lrVuelo."Num Vuelo"    := LeeAtributoTrnc(Nodo[4], Text50025, MAXSTRLEN(lrVuelo."Num Vuelo"));

                IF EVALUATE(lwFecha, LeeAtributo(Nodo[4], Text50013)) THEN
                  lrVuelo.Fecha := lwFecha;

                IF EVALUATE(lwHora, LeeAtributo(Nodo[4], Text50026)) THEN
                  lrVuelo.Hora := lwHora;

                lrVuelo.IATA         := LeeAtributoTrnc(Nodo[4], Text50027, MAXSTRLEN(lrVuelo.IATA));
                lrVuelo.Touroperador := LeeAtributoTrnc(Nodo[4], Text50008, MAXSTRLEN(lrVuelo.Touroperador));

                IF LeeAtributo(Nodo[4], Text50028) = Text50029 THEN
                  lrVuelo."Entrada/Salida" := lrVuelo."Entrada/Salida"::Entrada
                ELSE
                  lrVuelo."Entrada/Salida" := lrVuelo."Entrada/Salida"::Salida;

                IF EVALUATE(lwFecha, LeeAtributo(Nodo[4], Text50030)) THEN
                  lrVuelo."Fecha llegada vuelo" := lwFecha;
                lrVuelo.INSERT;

                lwNumVuelos += 100;

                Nodo[4]:=Nodo[4].nextSibling
              UNTIL ISCLEAR(Nodo[4]);
            END;
          END;

          // Lineas Parte

          Nodo[3] := Nodo[2].selectSingleNode(Text0004);
          IF NOT ISCLEAR(Nodo[3]) THEN BEGIN
            Nodo[4] := Nodo[3].firstChild;
            IF NOT ISCLEAR(Nodo[4]) THEN
            REPEAT
              lwTexto:= Nodo[4].nodeName;
              lrLin."Codigo Hotel"       := LeeAtributoTrnc(Nodo[4],Text50031, MAXSTRLEN(lrLin."Codigo Hotel"));
              // JPT 09/08/06 El nombre del hotel lo limitamos a 20 ya que este es el maximo que puede importarse en TXT
              // Si no, daria problemas en las converesiones ya que encuentra nombres distintos segun venga de TXT o XML
              lrLin."Nombre Hotel"       := LeeAtributoTrnc(Nodo[4],Text50032, MAXSTRLEN(lrLin."Nombre Hotel"));
              CreaCodigo(5, lrLin."Codigo Hotel", lwCliente, lwTTOO, lrLin."Nombre Hotel");

              IF EVALUATE(lwInt , LeeAtributo(Nodo[4],Text50033)) THEN
                lrLin."Numero Adultos"     := lwInt;
              IF EVALUATE(lwInt , LeeAtributo(Nodo[4],Text50034)) THEN
                lrLin."Numero Ni¤os"       := lwInt;
              lwTexto := LeeAtributo(Nodo[4],Text50026);
              lwTexto += LeeAtributo(Nodo[4],Text50019);
              lrLin.Observaciones          := COPYSTR(lwTexto, 1, MAXSTRLEN(lrLin.Observaciones));

              // AJS 23.08.2006
              // Modificar la instruccion COPYSTR para que tome STRLEN de "Observaciones B" y no de "Observaciones"

              lrLin."Observaciones B"      := COPYSTR(lwTexto, STRLEN(lrLin.Observaciones) + 1,
                                              MAXSTRLEN(lrLin."Observaciones B"));

              // AJS 27.07.2006
              // Incluimos el tratamiento de los nodos de Adultos y Ni¤os invitados, se tienen que sumar a los
              // transportados en la linea

              IF EVALUATE(lwInt , LeeAtributo(Nodo[4],Text50035)) THEN BEGIN
                lrLin."Adultos invitados" := lwInt;
                lrLin."Numero Adultos"    += lwInt;
              END;
              IF EVALUATE(lwInt , LeeAtributo(Nodo[4],Text50036)) THEN BEGIN
                lrLin."Ni¤os invitados" := lwInt;
                lrLin."Numero Ni¤os"    += lwInt;
              END;
              // AJF 28.01.2008 - DRF 07004
              // Si la importacion es de shuttle sacamos solo el vuelo que toca en vuelo1.

              // AJS 29.02.2008
              // En los servicios de shuttle la hora de presentacion es la de cada linea

              IF (lwShuttle) THEN BEGIN
                EVALUATE(lrLin."Hora Presentacion", LeeAtributo(Nodo[4],Text50026));

                lrLin.Subagencia := lrLin.Agencia + '-' + LeeAtributoTrnc(Nodo[4],Text50008,10);
                CreaCodigo(3, lrLin.Subagencia,lwCliente,'','');
                lrLin.Vuelo1     := LeeAtributo(Nodo[4], Text50024);
              END
              ELSE BEGIN
                lwTexto := LeeAtributoTrnc(Nodo[4],Text50024, MAXSTRLEN(lwTexto));
                IF lwTexto <> '' THEN BEGIN // Si los vuelos vienen en el camp vuelos
                  FOR lwCont2 := 1 TO 3 DO BEGIN // Insertamos los tres primero vuelos
                    lwPos := STRPOS(lwTexto,',');
                    IF lwPos= 0 THEN
                      lwPos := STRLEN(lwTexto)+1;

                    IF lwPos > MAXSTRLEN(lrLin.Vuelo1) THEN
                       lwPos := MAXSTRLEN(lrLin.Vuelo1);

                    IF lwTexto <> '' THEN BEGIN
                      CASE lwCont2 OF
                        1: IF lrLin.Vuelo1 = '' THEN
                            lrLin.Vuelo1 := COPYSTR(lwTexto,1,lwPos-1);
                        2: IF lrLin.Vuelo2 = '' THEN
                            lrLin.Vuelo2 := COPYSTR(lwTexto,1,lwPos-1);
                        3: IF lrLin.Vuelo3 = '' THEN
                            lrLin.Vuelo3 := COPYSTR(lwTexto,1,lwPos-1);
                      END;
                    END;
                    IF lwPos > STRLEN(lwTexto) THEN
                      CLEAR(lwTexto)
                    ELSE
                      lwTexto := COPYSTR(lwTexto,lwPos+1); // Le vamos quitando vuelos
                  END;

                END;
              END;
              // AJF fin.
              lwTexto := LeeAtributo(Nodo[4],Text50037); // Hora del vuelo
              IF EVALUATE(lwHora, lwTexto) THEN
                IF lwHora <> 0T THEN
                  lrLin."Hora Vuelo1" := lwHora;

              // Es necesario insertar la linea antes de los suplementos ya que necesitamos su clave primaria

              lrLin."No Cabecera" := lrCab."No.";

              // AJF 24-01.2008
              // Para Shuttle llenaremos los campos con otros atributos.
              IF (lwShuttle) THEN BEGIN
                 lrLin."Nombre Cliente" := LeeAtributo(Nodo[4],Text50038);
                 lrLin.Reserva          := LeeAtributo(Nodo[4],Text50039);
              END
              ELSE BEGIN
                lrLin."Nombre Cliente" := LeeAtributo(Nodo[4],Text50040); // Nombre del Cliente (Ter) JPT 12/02/07
                lrLin.Reserva          := LeeAtributo(Nodo[4],Text50041); // Reserva (Ter) JPT 12/02/07
              END;

              // AJS 29.06.2009

              lrLin."Zona fisica"   := LeeAtributoTrnc(Nodo[4],Text50042, MAXSTRLEN(lrLin."Zona fisica"));

              lrLin.INSERT(TRUE);

              // Suplementos
              lrLin."Codigo Suplemento" :='';
              lrLin."Cantidad Suplemento":=0;
              Nodo[5] := Nodo[4].selectSingleNode(Text0046);
              IF NOT ISCLEAR(Nodo[5]) THEN BEGIN
                Nodo[6] := Nodo[5].firstChild;
                IF NOT ISCLEAR(Nodo[6]) THEN BEGIN
                  REPEAT
                    lwCod := LeeAtributoTrnc(Nodo[6],Text50043, MAXSTRLEN(lrExSupl.Codigo));
                    CreaCodigo(4,lwCod ,lwCliente ,lwTTOO ,'');
                    IF NOT EVALUATE(lwInt , LeeAtributo(Nodo[6],Text50044)) THEN
                      CLEAR(lwInt);

                    // Solo poder ir al primero (linea de imp)
                    IF lrLin."Codigo Suplemento"='' THEN BEGIN
                      lrLin."Codigo Suplemento"  := lwCod;
                      lrLin."Cantidad Suplemento":= lwInt;
                    END;

                    // Inserta linea de suplemento
                    CLEAR(lrExSupl);
                    lrExSupl.Importacion    := lrLin.Importacion;
                    lrExSupl."No Cabecerra" := lrLin."No Cabecera";
                    lrExSupl."No Linea"     := lrLin.No;
                    lrExSupl.Tipo           := lrExSupl.Tipo::Suplemento;
                    lrExSupl.Codigo         := lwCod;
                    lrExSupl.Cantidad       := lwInt;
                    lrExSupl.INSERT(TRUE);

                    Nodo[6]:=Nodo[6].nextSibling
                  UNTIL ISCLEAR(Nodo[6])
                END;
              END;
              lrLin.MODIFY;
              Nodo[4]:=Nodo[4].nextSibling
            UNTIL ISCLEAR(Nodo[4]);
          END;

          // Extras Parte
          Nodo[3] := Nodo[2].selectSingleNode(Text0047);
          IF NOT ISCLEAR(Nodo[3]) THEN BEGIN
            Nodo[4] := Nodo[3].firstChild;
            IF NOT ISCLEAR(Nodo[4]) THEN
            REPEAT
              CLEAR(lrExSupl);
              lrExSupl.Importacion   := lrCab.Importacion;
              lrExSupl."No Cabecerra":= lrCab."No.";
              lrExSupl.Tipo          := lrExSupl.Tipo::Extra;

              lwCod := LeeAtributoTrnc(Nodo[4],Text50045, MAXSTRLEN(lwCod));
              CreaCodigo(6,lwCod ,lwCliente ,lwTTOO ,'');
              lrExSupl.Codigo := lwCod;
              lwCod := LeeAtributoTrnc(Nodo[4],Text50008, MAXSTRLEN(lwCod));
              IF lwCod <> '' THEN BEGIN
                 lwCod      := lrCab.Agencia + '-' + lwCod;
                 CreaCodigo(3, lwCod ,lrCab.Agencia,'','');
                 lrExSupl.Subagencia := lwCod;
              END;
              lrExSupl.INSERT(TRUE);

              Nodo[4]:=Nodo[4].nextSibling
            UNTIL ISCLEAR(Nodo[4])
          END;

          Nodo[2]:=Nodo[2].nextSibling
        UNTIL ISCLEAR(Nodo[2]);
      END;

      MueveArchivo(lrImp."No Importacion",pwNombreArchivo);
      CLEAR(XML);
      // Devuelve el numero de importacion
      EXIT(lrImp."No Importacion");
    END;

    PROCEDURE ImportaArchivoXML2@1103355006(pwNombreArchivo@1100244000 : Text[150]) : Integer;
    VAR
      lrImp@1100244002 : Record 7035333;
      lrLin@1100244003 : Record 7010432;
      lrCab@1100244004 : Record 7010431;
      lrCab2@1100244008 : Record 7010431;
      lrExSupl@1100253004 : Record 7035389;
      lrVuelo@1103355009 : Record 7035391;
      lrUser@1103355011 : Record 7010420;
      Nodo@1100244010 : ARRAY [10] OF Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";
      XML@1100244011 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{F6D90F11-9C73-11D3-B32E-00C04F990BB4}:'Microsoft XML, v4.0'.DOMDocument";
      lwCont@1100244012 : ARRAY [10] OF Integer;
      lwTotal@1100244013 : ARRAY [10] OF Integer;
      lwInt@1103355000 : Integer;
      lwPos@1103355002 : Integer;
      lwNumVuelos@1103355008 : Integer;
      lwCont2@1103355001 : Integer;
      lwBol@1103350000 : Boolean;
      lwVuelos@1100253000 : Text[100];
      lwTexto@1103355005 : Text[500];
      lwCod@1100253003 : Code[25];
      lwCliente@1103355004 : Code[20];
      lwTTOO@1103355003 : Code[10];
      lwGaraje@1103355010 : Code[10];
      lwHora@1103355007 : Time;
      lwFecha@1103355006 : Date;
    BEGIN
      // ImportaArchivoXML2
      // Es un esquema distinto de documento XML
      // ESTE ES LA IMPORTACION DE XML provenientes de UEX

      // Devuelve el numero de importacion creado


      rPar.FINDFIRST;
      rParImp.FINDFIRST;

      // Buscamos el garaje del usuario que es el que pondremos por defecto
      // Ya que no viene ning£n garaje en la importacion
      lrUser.GET(USERID);
      lrUser.TESTFIELD("Garaje de trabajo");
      lwGaraje := lrUser."Garaje de trabajo";

      IF NOT EXISTS(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      IF ISCLEAR(XML) THEN
        CREATE(XML);
      IF NOT XML.load(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      //  Se crea Historico Importacion

      lrImp.RESET;
      lrImp.INIT;
      lrImp.Archivo := Extractfilename(pwNombreArchivo);
      lrImp.Tipo    := lrImp.Tipo::Reserva;
      lrImp.INSERT(TRUE);

      lrLin.RESET;

      Nodo[1] := XML.documentElement;

      CLEAR(lwTotal);
      // NodeList[1] := XML.getElementsByTagName(Text50005);
      // lwTotal[1] := NodeList[1].length;
      Nodo[2] := Nodo[1].selectSingleNode(Text50005);
      IF NOT ISCLEAR(Nodo[2]) THEN BEGIN
        REPEAT
          lwTexto:= Nodo[2].nodeName;
          lrCab.INIT;       // Crea La cabecera
          lrCab.Importacion   := lrImp."No Importacion";
          lwTexto             := LeeNodoTrnc(Nodo[2],Text50046, 35);
          lwCliente           := CreaCodigo(2, lrCab.Agencia  ,'','', lwTexto);
          lwTTOO              := CreaCodigo(3,lrCab.Subagencia,lwCliente,'', lwTexto);
          lwTexto             := LeeNodo(Nodo[2],Text50047);
          lrCab.Fecha         := SetFormFecha(2, lwTexto);
          lrCab.Servicio      := LeeNodoTrnc(Nodo[2],Text50048, 35);
          { Esto es la zona, no el punto de recogida
          lwTexto             := LeeNodoTrnc(Nodo[2],Text50049, 35);
          CreaCodigo(5, lrCab."Origen/Destino", lwCliente, lwTTOO , lwTexto);
          }
          lrCab.Observaciones := LeeNodoTrnc(Nodo[2],Text50050, MAXSTRLEN(lrCab.Observaciones));

          // AJS 04.06.2008
          // Incluimos una marca para saber si la cabecera se ha creado a partir de
          // un fichero XML, para gestionar las observaciones de manera diferente

          lrCab."Fichero XML" := TRUE;

          lrCab.INSERT(TRUE);

          BuscaParte(lrCab, TRUE);

          lrLin.INIT;
          lrLin.Importacion      := lrCab.Importacion;
          lrLin.Agencia          := lrCab.Agencia;
          lrLin.Emp              := lwGaraje;
          CreaCodigo(0,lwGaraje,lwCliente,lwTTOO,'');
          lrLin.Servicio             := lrCab.Servicio;
          lrLin."Agencia Viaje"      := LeeNodoTrnc(Nodo[2],Text50051, MAXSTRLEN(lrLin."Agencia Viaje"));
          CreaCodigo(1,lrLin."Agencia Viaje",lwCliente,lwTTOO,'');
          lrLin.Fecha                := lrCab.Fecha;

          lrLin."Nombre Guia"        := LeeNodoTrnc(Nodo[2],Text50014, MAXSTRLEN(lrLin."Nombre Guia"));


          // Para cuando los vuelos estan en el archivo de vuelos x parte
          // Vuelos

          Nodo[3] := Nodo[2].selectSingleNode(Text50052);
          IF NOT ISCLEAR(Nodo[3]) THEN BEGIN
            lwCont[2]:=0;
            IF NOT ISCLEAR(Nodo[3]) THEN BEGIN
              lwNumVuelos := 100;
              REPEAT
                IF Nodo[3].nodeName = Text50052 THEN BEGIN
                  // Si se trata de la primera linea de vuelo hay que rellenar el campo destino de la linea
                  IF lwNumVuelos = 100 THEN
                    lrLin.Destino := LeeNodoTrnc(Nodo[3],Text50053, MAXSTRLEN(lrLin.Destino));

                  CLEAR(lrVuelo);
                  lrVuelo.Importacion    := lrCab.Importacion;
                  lrVuelo."No. Cabecera" := lrCab."No.";
                  lrVuelo."No. Vuelo"    := lwNumVuelos;
                  lrVuelo."Num Vuelo"    := LeeNodoTrnc(Nodo[3], Text50054, MAXSTRLEN(lrVuelo."Num Vuelo"));


                  lwTexto             := LeeNodo(Nodo[3],Text50047);
                  lrVuelo.Fecha       := SetFormFecha(2, lwTexto);

                  IF EVALUATE(lwHora, LeeNodo(Nodo[3], Text50055)) THEN
                    lrVuelo.Hora := lwHora;

                  lrVuelo.IATA         := LeeNodoTrnc(Nodo[3], Text50027, MAXSTRLEN(lrVuelo.IATA));
                  lrVuelo.Touroperador := lrCab.Subagencia;

                  { Esto NO puede aplicarse
                  IF LeeAtributo(Nodo[3], Text50028) = Text50029 THEN
                    lrVuelo."Entrada/Salida" := lrVuelo."Entrada/Salida"::Entrada
                  ELSE
                    lrVuelo."Entrada/Salida" := lrVuelo."Entrada/Salida"::Salida;
                  }
                  lrVuelo."Entrada/Salida" := -1;

                  lrVuelo."Fecha llegada vuelo" := lrVuelo.Fecha;
                  lrVuelo."E/S depende Serv"    := TRUE; // Dependera del servicio
                  lrVuelo.INSERT;

                  lwNumVuelos += 100;
                END;
                Nodo[3]:=Nodo[3].nextSibling
              UNTIL ISCLEAR(Nodo[3]);
            END;
          END;

          // Lineas Parte

          Nodo[3] := Nodo[2].selectSingleNode(Text50056);
          IF NOT ISCLEAR(Nodo[3]) THEN BEGIN
            REPEAT
              IF Nodo[3].nodeName = Text50056 THEN BEGIN
                lwTexto    := LeeNodoTrnc(Nodo[3],Text50057, 35);
                lrLin."Nombre Hotel" := lwTexto;
                CreaCodigo(5, lrLin."Codigo Hotel", lwCliente, lwTTOO, lwTexto);


                IF EVALUATE(lwInt , LeeNodo(Nodo[3],Text50058)) THEN
                  lrLin."Numero Adultos":= lwInt;

                lwTexto := LeeNodo(Nodo[3],Text50055);

               IF EVALUATE(lwHora, lwTexto) THEN
                 lrLin."Hora Presentacion"  := lwHora;

                lwTexto += LeeNodo(Nodo[3],Text50050);
                lrLin.Observaciones     := COPYSTR(lwTexto, 1, MAXSTRLEN(lrLin.Observaciones));

                lrLin."Observaciones B" := COPYSTR(lwTexto, STRLEN(lrLin.Observaciones) + 1,
                                                MAXSTRLEN(lrLin."Observaciones B"));

                lrLin."No Cabecera"     := lrCab."No.";
                lrLin.Zona              := LeeNodoTrnc(Nodo[3],Text50059, MAXSTRLEN(lrLin.Zona));

                lrLin.INSERT(TRUE);
              END;
              Nodo[3]:=Nodo[3].nextSibling
            UNTIL ISCLEAR(Nodo[3]);
          END;


          Nodo[2]:=Nodo[2].nextSibling
        UNTIL ISCLEAR(Nodo[2]);
      END;

      MueveArchivo(lrImp."No Importacion",pwNombreArchivo);
      CLEAR(XML);
      // Devuelve el numero de importacion
      EXIT(lrImp."No Importacion");
    END;

    PROCEDURE Extractfilename@1100244003(pwNombreArchivo@1100244000 : Text[200]) : Text[100];
    VAR
      lwText@1100244001 : Text[200];
      lwCont@1100244002 : Integer;
    BEGIN
      // Extractfilename
      // Devolvemos el nombre del archivo sin el path

      lwText := pwNombreArchivo;
      REPEAT
        lwCont := STRPOS(lwText,'\');
        IF lwCont<> 0 THEN
          lwText := COPYSTR(lwText,lwCont+1,STRLEN(lwText));
      UNTIL lwCont=0;

      lwText := COPYSTR(lwText, 1,100); // Nos aseguramos que no sea mas largo que 100

      EXIT(lwText);
    END;

    PROCEDURE BuscaErrores@1100244002(pwImp@1100244000 : Integer);
    VAR
      lrCab@1100244001 : Record 7010431;
      lrLin@1100244002 : Record 7010432;
      lrConv@1100244003 : Record 7010434;
      Err001@1100244004 : TextConst 'ESP=No se encuentra conversion para %1 %2';
      Err002@1100244006 : TextConst 'ESP=No se encuentra Codigo Finbus para %1 %2';
      lrHstE@1100244007 : Record 7035334;
      lrClientTTOO@1100244008 : Record 7010313;
      Err003@1100244009 : TextConst 'ESP=No se encuentra Cliente/TTOO %1/%2';
      lrParte@1100244010 : Record 7010360;
      Err004@1100244011 : TextConst 'ESP=El Parte %1 est  ya Confirmado';
      lrVeh@1100253000 : Record 7010346;
      lrCond@1100253003 : Record 7010327;
      lrExSupl@1100253004 : Record 7035389;
      lrVuelos@1103355000 : Record 7035391;
      lrCodS@1103355001 : Record 7010320;
      lrVuel@1103355002 : Record 7035391;
      lwTotal@1100244012 : Integer;
      lwCont@1100244013 : Integer;
      Err005@1100244014 : TextConst 'ESP=El campo %1 No est  rellenado';
      Err006@1100244015 : TextConst 'ESP=No se ha indicado ning£n Pax';
      lwText@1100244016 : Text[150];
      lwCliente@1100244017 : Code[20];
      lwTTOO@1100244018 : Code[10];
      Err007@1100253001 : TextConst 'ESP=No existe el Vehiculo %1';
      Err008@1100253002 : TextConst 'ESP=No existe el conductor %1';
      lrLinManuales@1103355003 : Record 7010432;
    BEGIN
      // BuscaErrores
      // Repasa los errores de una importaci¢n entera

      lrHstE.RESET;
      lrHstE.SETRANGE("No Importacion", pwImp);
      IF lrHstE.FINDFIRST THEN
        lrHstE.DELETEALL;

      lrClientTTOO.RESET;

      // Algunos los apuntaremos solo a la cabecera y a otros a las lineas

      lrConv.RESET;
      lrConv.SETCURRENTKEY(Codigo, Tipo);
      lwText :=STRSUBSTNO(Text0003, pwImp);
      wVentana.OPEN(lwText);

      // Buscamos primero en las lineas

      lrLin.RESET;
      lrLin.SETRANGE(Importacion, pwImp);
      // AJF 04/08/08
      // Filtro las l¡neas manuales.
      lrLin.SETRANGE ("N§ Linea", 0);

      IF lrLin.FINDSET(TRUE, FALSE) THEN BEGIN
        wVentana.UPDATE(2,Text0004);
        lwTotal:= lrLin.COUNT;
        CLEAR(lwCont);
        REPEAT
          // Volvemos a realizar las operaciones de crear conversiones

          lwCliente:= CreaCodigo(2, lrLin.Agencia   , '', '', '');

          // AJS 29.02.2008
          // En los servicios shuttle hay que convertir el TTOO de cada una de las lineas de recogida

          lwTTOO := '';

          lrCab.GET(lrLin.Importacion, lrLin."No Cabecera");
          IF lrCab."Servicio shuttle" THEN BEGIN
            IF NOT BuscaConv(lrConv.Tipo::TTOO, lrLin.Subagencia, lwCliente, '', lrConv) THEN BEGIN
              InsertaError(lrCab.Importacion, lrCab."No.", lrLin.No,
                           STRSUBSTNO(Err001, lrLin.FIELDCAPTION(Subagencia), lrLin.Subagencia));
            END
            ELSE BEGIN
              lwTTOO := lrConv."Codigo FinBus";
              IF lrConv."Codigo FinBus"='' THEN
                InsertaError(lrCab.Importacion, lrCab."No.", lrLin.No,
                             STRSUBSTNO(Err002, lrLin.FIELDCAPTION(Subagencia), lrLin.Subagencia))
              ELSE
                lrClientTTOO.TTOO := lrConv."Codigo FinBus";
            END;

            // Busca relacion Cliente/TTOO

            IF (lrClientTTOO.Cliente <> '') AND (lrClientTTOO.TTOO <> '') THEN
              IF NOT lrClientTTOO.FIND THEN
                InsertaError(lrCab.Importacion, lrCab."No.", lrLin.No,
                             STRSUBSTNO(Err003, lrClientTTOO.Cliente, lrClientTTOO.TTOO));
          END
          ELSE
            lwTTOO := CreaCodigo(3, lrLin.Subagencia, lwCliente, '', '');

          CreaCodigo(0, lrLin.Emp                , lwCliente, lwTTOO , '');
          CreaCodigo(1, lrLin."Agencia Viaje"    , lwCliente, lwTTOO , '');
          CreaCodigo(4, lrLin."Codigo Suplemento", lwCliente, lwTTOO , '');
          CreaCodigo(5, lrLin."Codigo Hotel"     , lwCliente, lwTTOO , lrLin."Nombre Hotel");

          // Buscamos los codigos de cliente y touroperador necesarios para las conversiones

          CLEAR(lwCliente);
          IF BuscaConv(lrConv.Tipo::Cliente,lrLin.Agencia,'','',lrConv) THEN
            lwCliente := lrConv."Codigo FinBus";
          CLEAR(lwTTOO);
          IF BuscaConv(lrConv.Tipo::TTOO, lrLin.Subagencia, lwCliente,'',lrConv) THEN
            lwTTOO := lrConv."Codigo FinBus";

          // Busca Garaje
          IF NOT BuscaConv(lrConv.Tipo::Garaje,lrLin.Emp,lwCliente,lwTTOO,lrConv) THEN
            InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,STRSUBSTNO(Err001,lrLin.FIELDCAPTION(Emp),lrLin.Emp))
          ELSE BEGIN
            IF lrConv."Codigo FinBus"='' THEN
              InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,STRSUBSTNO(Err002,lrLin.FIELDCAPTION(Emp),lrLin.Emp));
          END;

          // Busca Codigo Servicio
          IF NOT BuscaConv(lrConv.Tipo::"Codigo Servicio",lrLin."Agencia Viaje",lwCliente,lwTTOO,lrConv) THEN
            InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,
                         STRSUBSTNO(Err001,lrLin.FIELDCAPTION("Agencia Viaje"),lrLin."Agencia Viaje"))
          ELSE BEGIN
            IF lrConv."Codigo FinBus"='' THEN
              InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,
                           STRSUBSTNO(Err002,lrLin.FIELDCAPTION("Agencia Viaje"),lrLin."Agencia Viaje"))
            ELSE BEGIN

              // Cambiamos  "Entrada/Salida" dependiendo del codigo de servicio JPT 15/06/07
              CLEAR(lrVuelos);
              lrVuelos.SETRANGE(Importacion        , lrLin.Importacion);
              lrVuelos.SETRANGE("No. Cabecera"     , lrLin."No Cabecera");
              lrVuelos.SETRANGE("E/S depende Serv" , TRUE);
              IF lrVuelos.FINDSET THEN BEGIN
                lrCodS.GET(lrConv."Codigo FinBus");
                lrVuelos.MODIFYALL("Entrada/Salida", lrCodS."Tipo orden");
              END;
            END;
          END;

          // Buscamos el Hotel
          IF NOT BuscaConv(lrConv.Tipo::Hotel,lrLin."Codigo Hotel",lwCliente,lwTTOO,lrConv) THEN
            InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,
                         STRSUBSTNO(Err001,lrLin.FIELDCAPTION("Codigo Hotel"),lrLin."Codigo Hotel"))
          ELSE BEGIN
            IF lrConv."Codigo FinBus"='' THEN
              InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,
                           STRSUBSTNO(Err002,lrLin.FIELDCAPTION("Codigo Hotel"),lrLin."Codigo Hotel"));
          END;

          // JPT introducimos el orden de la zona fisica
          // JPT 19/07/07 Eliminamos este orden
          // lrLin.Orden := BuscaOrdenZona(lrConv."Codigo FinBus");

          // Comprueba los Paxes
          IF (lrLin."Numero Adultos"=0) AND (lrLin."Numero Ni¤os"=0) THEN
            InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No, Err006);

          // Tabla de Codigos Suplemento
          CLEAR(lrExSupl);
          lrExSupl.SETRANGE(Importacion   , lrLin.Importacion);
          lrExSupl.SETRANGE("No Cabecerra", lrLin."No Cabecera");
          lrExSupl.SETRANGE("No Linea"    , lrLin.No);
          lrExSupl.SETRANGE(Tipo          , lrExSupl.Tipo::Suplemento);
          IF lrExSupl.FINDFIRST THEN BEGIN
            REPEAT
              CreaCodigo(4, lrExSupl.Codigo, lwCliente,lwTTOO ,'');
              IF NOT BuscaConv(lrConv.Tipo::Suplemento,lrExSupl.Codigo, lwCliente,lwTTOO,lrConv) THEN
                InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,
                               STRSUBSTNO(Err001,lrLin.FIELDCAPTION("Codigo Suplemento"),lrExSupl.Codigo))
              ELSE BEGIN
                IF lrConv."Codigo FinBus" ='' THEN
                  InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,
                               STRSUBSTNO(Err002,lrLin.FIELDCAPTION("Codigo Suplemento"),lrExSupl.Codigo));

            END;
            UNTIL lrExSupl.NEXT=0;
          END
          ELSE BEGIN
            // Busca Codigo Suplemento
            IF lrLin."Codigo Suplemento" <> '' THEN BEGIN
              IF NOT BuscaConv(lrConv.Tipo::Suplemento,lrLin."Codigo Suplemento",lwCliente,lwTTOO,lrConv) THEN
                InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,
                           STRSUBSTNO(Err001,lrLin.FIELDCAPTION("Codigo Suplemento"),lrLin."Codigo Suplemento"))
              ELSE BEGIN
                IF lrConv."Codigo FinBus" ='' THEN
                  InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,
                               STRSUBSTNO(Err002,lrLin.FIELDCAPTION("Codigo Suplemento"),lrLin."Codigo Suplemento"));
              END;
            END;
          END;

          lrLin.Errores := lrLin.NoErrores;
          lrLin.MODIFY;

          lwCont +=1;
          wVentana.UPDATE(3,ROUND(lwCont/lwTotal*10000,1));

        UNTIL  lrLin.NEXT = 0;
      END;

      // Luego buscamos los de cabecera  (Asi en este orden incluira tambien los errores de las lineas)

      lrCab.RESET;
      lrCab.SETRANGE(Importacion, pwImp);

      // AJS 24.07.2006
      // Filtramos para que no pase por las traspasadas

      lrCab.SETRANGE(Traspasada, FALSE);
      lrCab.SETRANGE(Anulada   , FALSE);
      IF lrCab.FINDSET(TRUE, FALSE) THEN BEGIN
        wVentana.UPDATE(2, Text0005);
        lwTotal := lrCab.COUNT;
        CLEAR(lwCont);

        REPEAT
          lrClientTTOO.INIT;
          // Buscamos los codigos de cliente y touroperador necesarios para las conversiones
          CLEAR(lwCliente);
          CLEAR(lwTTOO);

          // Busca Cliente
          IF NOT BuscaConv(lrConv.Tipo::Cliente,lrCab.Agencia,'','',lrConv) THEN BEGIN
            InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err001,lrCab.FIELDCAPTION(Agencia),lrCab.Agencia));
          END
          ELSE BEGIN
            lwCliente := lrConv."Codigo FinBus";
            IF lrConv."Codigo FinBus"='' THEN
              InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err002,lrCab.FIELDCAPTION(Agencia),lrCab.Agencia))
            ELSE
              lrClientTTOO.Cliente := lrConv."Codigo FinBus";
          END;

          // Busca TTOO
          IF NOT BuscaConv(lrConv.Tipo::TTOO, lrCab.Subagencia, lwCliente, '', lrConv) THEN BEGIN
            InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err001,lrCab.FIELDCAPTION(Subagencia),lrCab.Subagencia));
          END
          ELSE BEGIN
            lwTTOO := lrConv."Codigo FinBus";
            IF lrConv."Codigo FinBus"='' THEN
              InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err002,lrCab.FIELDCAPTION(Subagencia),lrCab.Subagencia))
            ELSE
              lrClientTTOO.TTOO := lrConv."Codigo FinBus";
          END;

          // Busca relacion Cliente/TTOO
          IF (lrClientTTOO.Cliente <>'') AND (lrClientTTOO.TTOO<>'') THEN
            IF NOT lrClientTTOO.FIND THEN
              InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err003,lrClientTTOO.Cliente,lrClientTTOO.TTOO));

          // Busca Vehiculo y Conductor
          IF lrCab.Vehiculo <> '' THEN
            IF NOT lrVeh.GET(lrCab.Vehiculo) THEN
              InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err007, lrCab.Vehiculo));

          IF lrCab.Conductor <> '' THEN
            IF NOT lrCond.GET(lrCab.Conductor) THEN
               InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err008, lrCab.Conductor));

          // Volvemos a buscar si se puede relacionar con un parte
          BuscaParte(lrCab, TRUE);

          // Si tiene un Parte relacionado se comprueba que no este confirmado
          IF lrCab."No. Parte" <> '' THEN BEGIN
            IF lrParte.GET(lrCab."No. Parte") THEN BEGIN
              IF lrParte.Confirmado THEN
                InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err004,lrCab."No. Parte"));

              // AJF 04/08/08
              // Comprobamos l¡neas manuales
              ComprobarLineasManuales(lrCab, lrParte);

            END;
          END
          // AJF 26/08/08
          // Si el parte ha sido borrado matamos la lineas manuales de importacion
          ELSE BEGIN
            lrLinManuales.SETRANGE (Importacion  , lrCab.Importacion);
            lrLinManuales.SETRANGE ("No Cabecera", lrCab."No.");
            lrLinManuales.SETFILTER("N§ Servicio", '<>%1', '');
            lrLinManuales.DELETEALL;
          END;

          // Comprueba campo Fecha
          IF lrCab.Fecha = 0D THEN
            InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err005,lrCab.FIELDCAPTION(Fecha)));

          // Comprueba campo Servicio
          IF lrCab.Servicio = '' THEN
            InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err005,lrCab.FIELDCAPTION(Servicio)));

          // Comprueba Origen/Destino
          IF lrCab."Origen/Destino" <> '' THEN
            CreaCodigo(5, lrCab."Origen/Destino", lwCliente, lwTTOO , '');

          // JPT 14/12/06 No generamos error si llega vacio
          IF lrCab."Origen/Destino" <> '' THEN BEGIN
            // Buscamos el Origen/Destino
            IF NOT BuscaConv(lrConv.Tipo::Hotel,lrCab."Origen/Destino",lwCliente,lwTTOO,lrConv) THEN
              InsertaError(lrCab.Importacion,lrCab."No.",0,
                           STRSUBSTNO(Err001,lrCab.FIELDCAPTION("Origen/Destino"),lrCab."Origen/Destino"))
            ELSE BEGIN
              IF lrConv."Codigo FinBus" ='' THEN
                InsertaError(lrCab.Importacion,lrCab."No.",0, STRSUBSTNO(Err002,lrCab.FIELDCAPTION("Origen/Destino"),
                             lrCab."Origen/Destino"));
            END;
          END;


          // Comprueba los extras
          CLEAR(lrExSupl);
          lrExSupl.SETRANGE(Importacion   , lrCab.Importacion);
          lrExSupl.SETRANGE("No Cabecerra", lrCab."No.");
          lrExSupl.SETRANGE(Tipo          , lrExSupl.Tipo::Extra);
          IF lrExSupl.FINDSET THEN BEGIN
            REPEAT
              CreaCodigo(6, lrExSupl.Codigo, lwCliente,lwTTOO ,'');
              IF NOT BuscaConv(lrConv.Tipo::Extra,lrExSupl.Codigo,lwCliente,lwTTOO,lrConv) THEN
                InsertaError(lrCab.Importacion,lrCab."No.",0,STRSUBSTNO(Err001,Text0047,lrExSupl.Codigo))
              ELSE BEGIN
                IF lrConv."Codigo FinBus" ='' THEN
                  InsertaError(lrCab.Importacion,lrCab."No.",0, STRSUBSTNO(Err002,Text0047,lrExSupl.Codigo));
              END;

              // ... y el touroperador
              CreaCodigo(3, lrExSupl.Subagencia, lwCliente,'' ,'');
              IF NOT BuscaConv(lrConv.Tipo::TTOO,lrExSupl.Subagencia, lwCliente,'',lrConv) THEN
                InsertaError(lrLin.Importacion,lrLin."No Cabecera",lrLin.No,
                               STRSUBSTNO(Err001,lrLin.FIELDCAPTION(Subagencia),lrExSupl.Subagencia))
              ELSE BEGIN
                IF lrConv."Codigo FinBus" ='' THEN
                  InsertaError(lrLin.Importacion, lrLin."No Cabecera", lrLin.No,
                               STRSUBSTNO(Err002, lrLin.FIELDCAPTION(Subagencia), lrExSupl.Subagencia));
              END;

            UNTIL lrExSupl.NEXT = 0;
          END;

          // AJS 27.07.2006
          // Comprueba que el servicio no este repetido dentro del mismo fichero

          IF CompruebaServicioRepetido(lrCab) THEN
            InsertaError(lrCab.Importacion, lrCab."No.", 0,
                         STRSUBSTNO(Text0049, lrCab.Servicio, lrCab.Agencia, lrCab.Fecha));

          // Comprobamos tambien los vuelos
          CLEAR(lrVuel);
          lrVuel.SETRANGE(Importacion   , lrCab.Importacion);
          lrVuel.SETRANGE("No. Cabecera", lrCab."No.");
          IF lrVuel.FINDSET(TRUE) THEN BEGIN
            REPEAT
              IF ErrorVuelo(lrVuel."Num Vuelo", lwText) THEN
                InsertaError(lrCab.Importacion,lrCab."No.",0, lwText)
              ELSE
                lrVuel.MODIFY; // Si no tiene errores formatea el vuelo
            UNTIL lrVuel.NEXT=0;
          END;

          lrCab.Errores := lrCab.NoErrores;
          lrCab.MODIFY;

          lwCont += 1;
          wVentana.UPDATE(3, ROUND(lwCont / lwTotal * 10000, 1));
        UNTIL lrCab.NEXT = 0;
      END;

      wVentana.CLOSE;
    END;

    PROCEDURE InsertaError@1100244006(pwImp@1100244004 : Integer;pwCab@1100244000 : Integer;pwLin@1100244001 : Integer;pwTexto@1100244002 : Text[250]);
    VAR
      lrLin@1100244003 : Record 7035334;
    BEGIN
      // InsertaError

      lrLin.RESET;
      lrLin.INIT;
      lrLin."No Importacion" := pwImp;
      lrLin.Descripcion      := COPYSTR(pwTexto,1,MAXSTRLEN(lrLin.Descripcion));
      lrLin.NoCab            := pwCab;
      lrLin.NoLin            := pwLin;
      lrLin.INSERT(TRUE);
    END;

    PROCEDURE AnularCabeceras@1100244004(VAR prCab@1100244000 : Record 7010431;pwValor@1100244002 : Boolean);
    VAR
      lrCab@1100244001 : Record 7010431;
    BEGIN
      // AnularCabeceras
      // Marca las Cabeceras como Anulada (-2) (pwValor=true) o como Pte (-1) (pwValor=False);

      lrCab.COPY(prCab);
      IF lrCab.FINDSET(TRUE, FALSE) THEN BEGIN
        REPEAT
          IF pwValor THEN
            lrCab.Errores:=-2
          ELSE
            lrCab.Errores:=-1;
          lrCab.MODIFY;
        UNTIL lrCab.NEXT=0;
      END;
    END;

    PROCEDURE BuscaParte@1100244011(VAR prCab@1100244001 : Record 7010431;pwMarcar@1100253000 : Boolean);
    VAR
      lrCab@1100244000 : Record 7010431;
      lrParte@1100253001 : Record 7010360;
      lwCliente@1103355000 : Code[20];
      lwTouroperador@1103355001 : Code[10];
      lwPasada@1103355002 : Integer;
      lwEncontrado@1103355003 : Boolean;
    BEGIN
      // BuscaParte

      // AJS 18.07.2006
      // Vamos a buscar directamente sobre la tabla parte

      lwCliente      := GetConv(2, prCab.Agencia, '', '');
      lwTouroperador := GetConv(3, prCab.Subagencia, lwCliente, '');

      lwPasada      := 0;
      lwEncontrado   := FALSE;
      lrParte.SETCURRENTKEY(Fecha, Cliente,
                            "Touroperador principal");
      lrParte.SETRANGE(Fecha                   , prCab.Fecha);
      lrParte.SETRANGE(Cliente                 , lwCliente);

      // AJF 22/05/08.
      // Si no encontramos el parte fitrando por el TTOO principal,
      // buscamos sin filtrar por el campo.

      WHILE (lwPasada < 2) AND NOT lwEncontrado DO BEGIN

        lwPasada += 1;
        IF lwPasada = 1 THEN
          lrParte.SETRANGE("Touroperador principal", lwTouroperador)
        ELSE
          lrParte.SETRANGE("Touroperador principal");

        prCab."No. Parte" :='';
        prCab."Modificacion sin autorizar" := FALSE;

        IF prCab.Referencia <> '' THEN
          lrParte.SETRANGE(Referencia, prCab.Referencia)
        ELSE
          lrParte.SETRANGE(Referencia, prCab.Servicio);

        lwEncontrado := lrParte.FINDFIRST;

        // AJS 30.05.2008
        // Para los servicios que no son shuttle solo hay una pasada

        IF NOT prCab."Servicio shuttle" THEN
          lwPasada := 2;

      END;

      IF lwEncontrado THEN BEGIN
        prCab."No. Parte" := lrParte."N§ Parte";
        IF pwMarcar THEN
          prCab."Modificacion sin autorizar" := TRUE;
      END;

      prCab.MODIFY;

      {****
      // AJS 24.07.2006
      // En los ficheros de texto la referencia esta puesta en el campo Referencia en lugar de servicio

      prCab."No. Parte" :='';
      prCab."Modificacion sin autorizar" := FALSE;
      // JPT 11/12/07 No se dese asignar el Parte Origen
      // IF prCab."No. Parte Origen" <> '' THEN
        // lrParte.SETRANGE("N§ Parte", prCab."No. Parte Origen")
      // ELSE BEGIN
        IF prCab.Referencia <> '' THEN
          lrParte.SETRANGE(Referencia, prCab.Referencia)
        ELSE
          lrParte.SETRANGE(Referencia, prCab.Servicio);
      // END;
      IF lrParte.FINDFIRST THEN BEGIN
        prCab."No. Parte" := lrParte."N§ Parte";
        IF pwMarcar THEN
          prCab."Modificacion sin autorizar" := TRUE;

      END;
      prCab.MODIFY;


      // AJS 12.05.2006
      // Buscamos todas las cabeceras que cumplan las condiciones para ver si existe el parte

      lrCab.RESET;
      lrCab.SETCURRENTKEY(Importacion,
                          Fecha,
                          Agencia,
                          Subagencia,
                          Servicio);
      lrCab.SETFILTER(Importacion, '<>%1', prCab.Importacion);
      lrCab.SETRANGE(Agencia     , prCab.Agencia);
      lrCab.SETRANGE(Subagencia  , prCab.Subagencia);
      lrCab.SETRANGE(Servicio    , prCab.Servicio);
      lrCab.SETRANGE(Fecha       , prCab.Fecha);
      lrCab.SETRANGE(Traspasada  , TRUE);
      IF lrCab.FINDSET(TRUE) THEN BEGIN
        REPEAT
          // Comprobamos que el parte exista

          CLEAR(lrParte);
          IF (lrCab.NoParte <> '') AND ( lrParte.GET(lrCab.NoParte) ) THEN BEGIN
            prCab.NoParte := lrCab.NoParte;
            IF pwMarcar THEN
              prCab."Modificacion sin autorizar" := TRUE;
            prCab.MODIFY;
          END;
        UNTIL lrCab.NEXT = 0;
      END;
      ****}
    END;

    PROCEDURE GetConv@1100244014(pwTipo@1100244002 : 'Garaje,Codigo Servicio,Cliente,TTOO,Suplemento,Hotel';pwCodigo@1100244001 : Code[21];pwCliente@1100244003 : Code[20];pwTTOO@1100244004 : Code[10]) : Code[20];
    VAR
      lrConv@1100244000 : Record 7010434;
    BEGIN
      // GetConv
      // Devuelve el Codigo Convertido
      // Si no lo encuentra para un Cliente - TTOO determinado lo busca para el generico (en blanco)
      // Si no lo encuentra dara error

      CLEAR(lrConv);

      IF pwCodigo = '' THEN
        EXIT('');

      IF NOT BuscaConv(pwTipo,pwCodigo,pwCliente,pwTTOO,lrConv) THEN
        ERROR(Text0034,pwTipo,pwCodigo);

      EXIT(lrConv."Codigo FinBus");
    END;

    PROCEDURE BuscaConv@1100244031(pwTipo@1100244002 : 'Garaje,Codigo Servicio,Cliente,TTOO,Suplemento';pwCodigo@1100244001 : Code[21];pwCliente@1100244003 : Code[20];pwTTOO@1100244004 : Code[10];VAR prConv@1100244005 : Record 7010434) : Boolean;
    VAR
      lwOk@1100244000 : Boolean;
    BEGIN
      // BuscaConv
      // Muy parecida al anterior solo que no genera error y ademas devuelve el registro si lo encuentra
      // Sirve entre otras para comprobaciones
      // Si no lo encuentra para un Cliente - TTOO determinado lo busca para el generico (en blanco)
      // Si no lo encuentra devuelve FALSE

      CLEAR(prConv);
      lwOk := FALSE;

      IF pwCodigo = '' THEN
        EXIT(FALSE);

      prConv.RESET;
      prConv.SETCURRENTKEY(Codigo,Tipo,Cliente,Touroperador);
      prConv.SETRANGE(Codigo, pwCodigo);
      prConv.SETRANGE(Tipo  , pwTipo);
      IF pwCliente <> '' THEN
        prConv.SETRANGE(Cliente     , pwCliente);
      IF pwTTOO <> '' THEN
        prConv.SETRANGE(Touroperador, pwTTOO);

      IF (NOT prConv.FINDFIRST) AND (pwTTOO <>'') THEN
        prConv.SETFILTER(Touroperador,'%1','');
      IF (NOT prConv.FINDFIRST) AND (pwCliente <> '') THEN
        prConv.SETFILTER(Cliente,'%1','');
      lwOk := prConv.FINDFIRST;
      IF NOT lwOk THEN
        CLEAR(prConv);

      EXIT(lwOk);
    END;

    PROCEDURE BuscaConvNom@1103355015(pwTipo@1100244002 : 'Garaje,Codigo Servicio,Cliente,TTOO,Suplemento';pwNombre@1100244001 : Text[50];pwCliente@1100244003 : Code[20];pwTTOO@1100244004 : Code[10];VAR prConv@1100244005 : Record 7010434) : Boolean;
    VAR
      lwOk@1100244000 : Boolean;
    BEGIN
      // BuscaConvNom
      // Parecida a BuscaConv solo que busca por nombre y no por codigo
      // Tiene que ser para un Cliente - TTOO  especifico
      // Si no lo encuentra devuelve FALSE

      CLEAR(prConv);
      lwOk := FALSE;

      IF pwNombre = '' THEN
        EXIT(FALSE);

      prConv.RESET;
      prConv.SETCURRENTKEY(Codigo,Tipo,Cliente,Touroperador);
      prConv.SETRANGE(Tipo  , pwTipo);
      prConv.SETRANGE(Nombre, pwNombre);
      prConv.SETRANGE(Cliente     , pwCliente);
      prConv.SETRANGE(Touroperador, pwTTOO);

      lwOk := prConv.FINDFIRST;

      IF (NOT lwOk) AND (pwTTOO <>'') THEN BEGIN
        prConv.SETFILTER(Touroperador,'%1','');
        lwOk := prConv.FINDFIRST;

        IF (NOT lwOk) AND (pwCliente <> '') THEN BEGIN
          prConv.SETFILTER(Cliente,'%1','');
          lwOk := prConv.FINDFIRST;
        END;
      END;

      IF NOT lwOk THEN
        CLEAR(prConv);

      EXIT(lwOk);
    END;

    PROCEDURE Hora1erVuelo@1100244015(VAR prLin@1100244001 : Record 7010432) : Time;
    VAR
      lrVuelo@1100244000 : Record 7035391;
      lwHora@1100244002 : Time;
    BEGIN
      // Hora1erVuelo

      CLEAR(lwHora);

      // AJS 21.07.2006  ## DRF 06008
      // La informacion referente a vuelos estar  a partir de ahora en una tabla aparte

      //lrLin.COPY(prLin);
      //lrLin.SETCURRENTKEY("Hora Vuelo1","Hora Vuelo2","Hora Vuelo3");
      //IF lrLin.FINDFIRST THEN
      //  lwHora := lrLin."Hora Vuelo1";

      lrVuelo.SETCURRENTKEY(Importacion,
                            "No. Cabecera",
                            Fecha,
                            Hora);
      lrVuelo.SETRANGE(Importacion   , prLin.Importacion);
      lrVuelo.SETRANGE("No. Cabecera", prLin."No Cabecera");
      IF lrVuelo.FINDFIRST THEN
        lwHora := lrVuelo.Hora;
      EXIT(lwHora);
    END;

    PROCEDURE GetHoraPresentacion@1100244008(VAR prLin@1100244000 : Record 7010432) : Time;
    VAR
      lrLin@1100244002 : Record 7010432;
      lwHora@1100244001 : Time;
    BEGIN
      // GetHoraPresentacion
      // Busca la primera hora de presentaci¢n
      // En teoria esto deberia ser superfluo, es solo para asegurar

      CLEAR(lwHora);
      lrLin.COPY(prLin);
      IF lrLin.FINDSET THEN BEGIN
        lwHora := lrLin."Hora Presentacion";
        REPEAT
          IF (lrLin."Hora Presentacion" < lwHora) AND (lrLin."Hora Presentacion" <> 0T) THEN
            // AJS 30.05.2008
            // Si la diferencia entre horas de presentacion es mayor de 5 horas la ignoramos

            IF (lwHora - lrLin."Hora Presentacion") < 18000000 THEN
              lwHora := lrLin."Hora Presentacion";

        UNTIL lrLin.NEXT=0;
      END;
      EXIT(lwHora);
    END;

    PROCEDURE GetHoraFinal@1100244020(pwCodigoServicio@1100244000 : Code[10];VAR prLin@1100244001 : Record 7010432) : Time;
    BEGIN
      // GetHoraFinal
      //
      // Si trabajamos con una salida, la hora aeropuerto se convierte en la hora de final del servicio

      IF pwCodigoServicio = rPar."Codigo Salidas" THEN
        EXIT(prLin."Hora Aeropuerto")
      ELSE
        EXIT(0T);
    END;

    PROCEDURE GetVuelos@1100244009(VAR prLin@1100244000 : Record 7010432) : Text[150];
    VAR
      lrVuelos@1100244001 : Record 7035391;
      lwTexto@1100244002 : Text[150];
    BEGIN
      // GetVuelos

      CLEAR(lwTexto);

      lrVuelos.RESET;
      lrVuelos.SETRANGE(Importacion   , prLin.Importacion);
      lrVuelos.SETRANGE("No. Cabecera", prLin."No Cabecera");
      IF lrVuelos.FINDSET THEN
      BEGIN
        REPEAT
          IF STRPOS(lwTexto, lrVuelos."Num Vuelo") = 0 THEN
          BEGIN
            IF lwTexto <> '' THEN
              lwTexto += ',';

            IF STRLEN(lwTexto) + STRLEN(lrVuelos."Num Vuelo") < MAXSTRLEN(lwTexto) THEN
              lwTexto += lrVuelos."Num Vuelo";
          END;
        UNTIL lrVuelos.NEXT = 0;
      END;

      EXIT(lwTexto);
    END;

    PROCEDURE BuscaServicio@1100244017(VAR prParte@1100244002 : Record 7010360;VAR prServicio@1100244001 : Record 7010358);
    VAR
      lrServicio@1100244000 : Record 7010358;
    BEGIN
      // BuscaServicio
      // Devuelve el servicio que le toque

      lrServicio.RESET;
      lrServicio.SETCURRENTKEY(Garaje,Fecha,Cliente,"Codigo Servicio",Referencia);
      lrServicio.SETRANGE(Garaje           , prParte.Garaje);
      lrServicio.SETRANGE(Fecha            , prParte.Fecha);
      lrServicio.SETRANGE(Cliente          , prParte.Cliente);
      lrServicio.SETRANGE("Codigo Servicio", prParte."Codigo Servicio");
      //+$005 <
      IF prParte."Origen creacion" <> prParte."Origen creacion"::Shuttle THEN
        lrServicio.SETRANGE(Touroperador     , prParte."Touroperador principal");
      //+$005 >
      //-$003lrServicio.SETRANGE(Referencia       , prParte.Referencia);
      IF NOT lrServicio.FINDFIRST THEN BEGIN
        lrServicio.INIT;
        lrServicio.INSERT  (TRUE);
        lrServicio.Garaje := prParte.Garaje; // Tiene que ser por asignaci¢n y no por validaci¢n
        lrServicio.VALIDATE (Cliente            , prParte.Cliente);
        lrServicio.VALIDATE ("Codigo Servicio"  , prParte."Codigo Servicio");
        lrServicio.VALIDATE ("Tipo Servicio"    , prParte."Tipo Servicio");
        lrServicio.VALIDATE(Fecha               , prParte.Fecha);
        //-$003lrServicio.VALIDATE(Referencia          , prParte.Referencia);
        lrServicio.VALIDATE(Touroperador        , prParte."Touroperador principal");
        lrServicio.Guia                         := prParte.Guia;
        lrServicio.MODIFY (TRUE);
      END;
      prServicio:=lrServicio;
    END;

    PROCEDURE Retroceder@1100244010(pwImp@1100244000 : Integer;pwCab@1100244009 : Integer);
    VAR
      lrImp@1100244001 : Record 7035333;
      lrCab@1100244017 : Record 7010431;
      lrCab2@1103355000 : Record 7010431;
      lrLin@1100244016 : Record 7010432;
      lrSup@1100244006 : Record 7010363;
      lrHstE@1100244010 : Record 7035334;
      lwTotal@1100244005 : Integer;
      lwCont@1100244004 : Integer;
      lwText@1100244003 : Text[150];
    BEGIN
      // Retroceder
      // Retrocede una importacion determinada
      // Si pwCab es distinto a 0 solo se elimina una cabecera determinada

      IF NOT lrImp.GET(lrImp.Tipo::Reserva,pwImp) THEN
        ERROR(Text0006,pwImp);

      IF lrImp.Anulada THEN
        ERROR(Text0012, lrImp."No Importacion");


      IF pwCab =0 THEN
        lwText := Text0014
      ELSE
        lwText := Text0016;

      IF NOT CONFIRM(lwText,FALSE,pwImp,pwCab) THEN
        EXIT;

      lrCab.SETRANGE(Importacion , pwImp);
      IF pwCab <> 0 THEN
        lrCab.SETRANGE("No."        , pwCab);
      IF lrCab.FINDSET(TRUE) THEN BEGIN
        // JPT 04/06/07 Avisamos si va a eliminar alg£n parte
        lrCab2.COPY(lrCab);
        lrCab2.SETRANGE(Traspasada, TRUE);
        IF lrCab2.FINDFIRST THEN
          IF NOT CONFIRM (Text0053, FALSE, pwImp, lrCab2.COUNT) THEN
            EXIT;

        lwTotal:= lrCab.COUNT;
        CLEAR(lwCont);
        lwText := STRSUBSTNO(Text0013,pwImp);
        wVentana.OPEN(lwText);
        REPEAT
          IF lrCab.Traspasada THEN BEGIN
            BorraParte(lrCab."No. Parte");
          END;

          // Borramos las lineas de error
          lrHstE.RESET;
          lrHstE.SETCURRENTKEY("No Importacion",NoCab,NoLin);
          lrHstE.SETRANGE("No Importacion" , lrCab.Importacion);
          lrHstE.SETRANGE(NoCab            , lrCab."No.");
          IF lrHstE.FINDFIRST THEN
            lrHstE.DELETEALL;

          lwCont +=1;
          wVentana.UPDATE(2,ROUND(lwCont/lwTotal*10000,1));
        UNTIL lrCab.NEXT=0;
        lrCab.MODIFYALL(Anulada    , TRUE);
        lrCab.MODIFYALL(Traspasada , FALSE);
        lrCab.MODIFYALL(Errores    , -2);
        lrCab.MODIFYALL("No. Parte"    ,'');
        wVentana.CLOSE;
      END;

      // Comprueba si se han anulado todas de la importacion
      lrCab.RESET;
      lrCab.SETCURRENTKEY(Traspasada,Anulada);
      lrCab.SETRANGE(Importacion , pwImp);
      lrCab.SETRANGE(Anulada     , FALSE);
      IF NOT lrCab.FINDFIRST THEN BEGIN
        lrImp.Anulada := TRUE;
        lrImp."Fecha Anulacion" := TODAY;
        lrImp.MODIFY;
      END
      ELSE BEGIN
        // Si Todas son anuladas y traspasadas marcar como traspasada
        lrCab.SETRANGE(Traspasada    ,FALSE);
        IF NOT lrCab.FINDFIRST THEN BEGIN
          lrImp.Transferida          := TRUE;
          lrImp."Fecha Trasferencia" := TODAY;
          lrImp.MODIFY;
        END;
      END;
    END;

    PROCEDURE TransferirSiguiente@1100244012();
    VAR
      lrImp@1100244000 : Record 7035333;
      lrCab@1100244001 : Record 7010431;
    BEGIN
      // TransferirSiguiente

      lrImp.RESET;
      lrImp.BuscaPrimero(lrImp);
      IF lrImp.Transferida OR lrImp.Anulada THEN
        ERROR(Text0017);
      Traspasa(lrImp."No Importacion",0,FALSE,FALSE);


      lrCab.RESET;
      lrCab.SETCURRENTKEY(Traspasada,Anulada);
      lrCab.SETRANGE(Importacion , lrImp."No Importacion");
      lrCab.SETRANGE(Anulada     , FALSE);
      lrCab.SETRANGE(Traspasada  , FALSE);
      IF lrCab.FINDFIRST THEN
        MESSAGE(Text0019,lrImp."No Importacion")
      ELSE
        MESSAGE(Text0018,lrImp."No Importacion");
    END;

    PROCEDURE MueveArchivo@4(pwNoImportacion@1100244000 : Integer;pwNomArch@1100244006 : Text[500]);
    VAR
      lwDirectorio@1100244001 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
      lwSubdirectorio@1100244002 : Text[250];
      lwContador@1100244003 : Integer;
      lwArch1@1100244004 : Text[250];
      lwArch2@1100244005 : Text[250];
    BEGIN
      // MueveArchivo
      // Esta funci¢n se encarga de abrir un Subdiectorio para esa importaci¢n y mover
      // all¡ todos los archivos importados
      // pwNoImportacion Es el N§ asignado a esa importaci¢n.

      CREATE(lwDirectorio);

      rParImp.FINDFIRST;
      rParImp.TESTFIELD("Directorio Archivos Importados");
      lwSubdirectorio   := rParImp."Directorio Archivos Importados";
      IF lwSubdirectorio[STRLEN(lwSubdirectorio)] <> '\' THEN
        lwSubdirectorio := lwSubdirectorio + '\';

      lwSubdirectorio := lwSubdirectorio + FORMAT(TODAY,0,Text50061) + '\';

      IF NOT lwDirectorio.FolderExists (lwSubdirectorio) THEN
        lwDirectorio.CreateFolder (lwSubdirectorio);

      lwSubdirectorio := lwSubdirectorio  + Text0021 + PonCeros(pwNoImportacion , 4) + '_' + PonFecha(TODAY);

      IF NOT lwDirectorio.FolderExists (lwSubdirectorio) THEN
        lwDirectorio.CreateFolder (lwSubdirectorio);

      lwArch1 := pwNomArch;
      IF EXISTS(lwArch1) THEN BEGIN
        lwArch2 := lwSubdirectorio + '\' + lwDirectorio.GetFileName(pwNomArch);
        lwDirectorio.MoveFile(lwArch1 , lwArch2);
      END;
    END;

    PROCEDURE PonCeros@6(pwNumero@1100244000 : Integer;pwCuantos@1100244001 : Integer) : Code[20];
    VAR
      lwTexto@1100244002 : Code[20];
    BEGIN
      // PonCeros
      // A partir del entero pasado como parametro "pwNumero" devuelve un code, pero CON ceros delante en "pwCuantos" cifras


      lwTexto := FORMAT (pwNumero);

      IF STRLEN (lwTexto) < pwCuantos THEN
        REPEAT
          lwTexto := '0' + lwTexto;
        UNTIL STRLEN (lwTexto) >= pwCuantos;

      EXIT(lwTexto);
    END;

    PROCEDURE PonFecha@7(pwFecha@1100244000 : Date) : Code[8];
    BEGIN
      // PonFecha
      // Devuelve la fecha en formato code y sin barras
      EXIT(PonCeros(DATE2DMY(pwFecha,1),2) + PonCeros(DATE2DMY(pwFecha,2),2) + FORMAT(pwFecha,0,Text50062));
    END;

    PROCEDURE CreaCodigo@1100244013(pwTipo@1100244000 : 'Garaje,Codigo Servicio,Cliente,TTOO,Suplemento,Hotel,Extra';VAR pwCodigo@1100244001 : Code[21];pwCliente@1100244004 : Code[20];pwTTOO@1100244003 : Code[10];pwNombre@1100244006 : Text[50]) : Code[20];
    VAR
      lrConv@1100244002 : Record 7010434;
      lrConv2@1100244007 : Record 7010434;
      lwEnc@1100244005 : Boolean;
      lwEnc2@1100244009 : Boolean;
      lwDistNom@1100244008 : Boolean;
      lwObligaCliTo@1103355000 : Boolean;
      lwCodFinbus@1103355001 : Code[20];
    BEGIN
      // CreaCodigo
      // Si no existe el codigo en la tabla de conversiones las crea
      // Si existe devuelve el codigo finbus

      CLEAR(lrConv2);
      CLEAR(lrConv);

      IF (pwCodigo='') AND (pwNombre='') THEN
        EXIT;

      pwCodigo := DELCHR(pwCodigo,'<>',' ');

      // Es importante considerar el nombre sin espacios en blanco
      pwNombre      := UPPERCASE(DELCHR(pwNombre ,'<>',' '));
      pwCliente     := DELCHR(pwCliente,'<>',' ');
      pwTTOO        := DELCHR(pwTTOO   ,'<>',' ');

      CLEAR(lwObligaCliTo);
      CLEAR(lwCodFinbus);
      IF pwCodigo='' THEN BEGIN
        // JPT 14/06/07
        // NOTA IMPORTANTE : Si la busqueda va a ser por nombre en vez de codigo considero que es imprescindible
        // que se filtre por Cliente y TTOO. Por lo cual si lo que estamos haciendo es la conversi¢n de
        // uno de esos pediremos el codigo Finbus YA. Si es otro tipo y no esta filtrado  damos error

        lwEnc    := BuscaConvNom(pwTipo,pwNombre,pwCliente,pwTTOO,lrConv);
        pwCodigo := lrConv.Codigo;
        IF pwCodigo = '' THEN
          pwCodigo := SiguienteCodigo(pwTipo,pwCliente,pwTTOO);

        {
        IF NOT lwEnc THEN
                  PideCliTO(pwTipo,pwCodigo, pwNombre, pwCliente, pwTTOO, lwCodFinbus); // Obliga a Introducir el codigo Finbus del Client
      e
      y
      TT
      OO

        lwObligaCliTo := TRUE;
        }
      END
      ELSE
        lwEnc := BuscaConv(pwTipo,pwCodigo,pwCliente,pwTTOO,lrConv);

      lrConv.Nombre := UPPERCASE((DELCHR(lrConv.Nombre    ,'<>',' ')));
      lrConv.Cliente:= DELCHR(lrConv.Cliente   ,'<>',' ');
      lrConv.Touroperador := DELCHR(lrConv.Touroperador ,'<>',' ');

      // Si se ha encontrado con nombre distinto forzamos el a¤adir cliente/TTOO
      lwDistNom := lwEnc AND (lrConv.Nombre <> pwNombre) ;
      lwEnc2    := lwEnc AND ((lrConv.Nombre = pwNombre) OR (pwNombre=''));
      IF NOT lwEnc2 THEN BEGIN

        CLEAR(lrConv2);
        lrConv2.Tipo         := pwTipo;
        lrConv2.Codigo       := pwCodigo;
        lrConv2.Nombre       := pwNombre;
        lrConv2.Cliente      := pwCliente;
        lrConv2.Touroperador := pwTTOO;

        IF NOT lwObligaCliTo THEN BEGIN
          BuscaCTCodigo(lrConv2.Cliente,lrConv2.Touroperador);
          IF lwDistNom THEN BEGIN  // Si igual codigo y distinto nombre forzamos al menos el cliente;
            IF lrConv.Cliente <> pwCliente THEN
              lrConv2.Cliente    := pwCliente
            ELSE
              IF lrConv.Touroperador <> pwTTOO THEN
                lrConv2.Touroperador := pwTTOO
              ELSE
                IF lrConv.No <>0 THEN
                  BEGIN    // Si ya existia con otro nombre y mismo cliente/ttoo simplemente le cambiamos el nombre
                  lrConv2.No := lrConv.No;
                  lrConv2.CompDupl; // Comprueba duplicidades
                  lrConv2.MODIFY(TRUE);
                  EXIT;
                END;
          END;
        END;
        lrConv2."Codigo FinBus" := lwCodFinbus;
        lrConv2.CompDupl; // Comprueba duplicidades
        lrConv2.INSERT(TRUE);
        lrConv := lrConv2;
      END;

      EXIT(lrConv."Codigo FinBus");
    END;

    PROCEDURE BuscaCTCodigo@1100244027(VAR pwCliente@1100244002 : Code[20];VAR pwTTOO@1100244001 : Code[10]);
    VAR
      lrConv@1100244000 : Record 7010434;
    BEGIN
      // BuscaCTCodigo

      // aqui lo que hacemos es comprobar si este cliente/TTOO ya tiene registros
      // En caso de no tenerlos devolvemos los campos pwCliente y pwTTOO en blanco

      IF (pwCliente='') AND (pwTTOO='') THEN
        EXIT;

      lrConv.RESET;
      { JPT 28/04/06 Modifico, ya que as¡ no parece ir muy bien
      lrConv.SETCURRENTKEY(Codigo,Tipo,Cliente,Touroperador);
      IF pwCliente <> '' THEN
        lrConv.SETRANGE(Cliente     , pwCliente);
      IF pwTTOO <> '' THEN
        lrConv.SETRANGE(Touroperador, pwTTOO);
      }

      lrConv.SETFILTER(Cliente     ,'=%1', pwCliente);
      lrConv.SETFILTER(Touroperador,'=%1', pwTTOO);

      IF (NOT lrConv.FINDFIRST) AND (pwTTOO <>'') THEN
        lrConv.SETFILTER(Touroperador,'%1','');
      IF (NOT lrConv.FINDFIRST) AND (pwCliente <> '') THEN
        lrConv.SETFILTER(Cliente,'%1','');

      IF NOT lrConv.FINDFIRST THEN
        CLEAR(lrConv);

      pwCliente := lrConv.Cliente;
      pwTTOO    := lrConv.Touroperador;
    END;

    PROCEDURE ImportaArchivoSurtidor2@1103350001(pwNombreArchivo@1100244000 : Text[150]);
    VAR
      lwconnect@1103350005 : Automation "{EF53050B-882E-4776-B643-EDA472E8E3F2} 2.7:{00000514-0000-0010-8000-00AA006D2EA4}:'Microsoft ActiveX Data Objects 2.7 Library'.Connection";
      lwRecordSet@1103350011 : Automation "{EF53050B-882E-4776-B643-EDA472E8E3F2} 2.7:{00000535-0000-0010-8000-00AA006D2EA4}:'Microsoft ActiveX Data Objects 2.7 Library'.Recordset";
      lwField@1103350013 : Automation "{EF53050B-882E-4776-B643-EDA472E8E3F2} 2.7:{00000569-0000-0010-8000-00AA006D2EA4}:'Microsoft ActiveX Data Objects 2.7 Library'.Field";
      lwTexto@1100244002 : Text[50];
      lwTexto2@1103350010 : Text[250];
      lrImp@1100244001 : Record 7035333;
      lrReg@1100244006 : Record 7035342;
      lrVeh@1100244008 : Record 7010346;
      lrConductor@1100244013 : Record 7010327;
      lrGaraje@1103355001 : Record 7010310;
      lwHora@1100244005 : Time;
      lwInt@1100244004 : Integer;
      lwFecha@1100244003 : Date;
      lwCod10@1100244007 : Code[10];
      lwCod20@1100244014 : Code[10];
      lwDec@1100244009 : Decimal;
      lwChar@1100244011 : Char;
      lwText001@1100244012 : TextConst 'ESP=El tipo de contador tiene que ser por Kilometro (K)';
      wlOk@1100244015 : Boolean;
      wlPosIni@1100244016 : Integer;
      wlCont@1100244017 : Integer;
      lwFechaReg@1100244019 : Date;
      lwVentana2@1100244020 : Dialog;
      lwFechaImp@1103350000 : Date;
      lwRet@1103350001 : Integer;
      lwCamp@1103350002 : Integer;
      lwId@1103350003 : Integer;
      lwTId@1103350012 : Text[30];
      lwNomCampo@1103350006 : Text[50];
      lwMax@1103350007 : Integer;
      lwOkSQL@1103350008 : Boolean;
      lwNomTabla@1103350009 : ARRAY [3] OF Text[50];
      Tcms@1103350004 : TextConst 'ESP=''';
      lwBorna@1103355000 : Code[10];
    BEGIN
      // ImportaArchivoSurtidor2
      // Importa los archivos de combustible

      wlOk   := TRUE;
      lwOkSQL:= TRUE;


      IF NOT EXISTS(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      CLEAR(wArch);
      wArch.TEXTMODE(FALSE);
      rParImp.FINDFIRST;

      IF NOT wArch.OPEN(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      IF wArch.LEN=0 THEN
        ERROR(Text0045,pwNombreArchivo);

      //  Se crea Historico Importacion

      lrImp.RESET;
      lrImp.INIT;
      lrImp.Archivo := Extractfilename(pwNombreArchivo);
      lrImp.Tipo    := lrImp.Tipo::Surtidor;
      lrImp.INSERT(TRUE);

      IF lwOkSQL THEN BEGIN
        rParImp.TESTFIELD("BD Gasoil");
        rParImp.TESTFIELD("Servidor Exportacion");
        rParImp.TESTFIELD("Usuario Exportacion");
        rParImp.TESTFIELD("Contrase¤a Exportacion");

        CLEAR(lwNomTabla);
        // Los nombres de las tablas se definen aqu¡
        lwNomTabla[1] := Text50063;
        CLEAR(lwconnect);
        CREATE(lwconnect);
        CLEAR(lwRecordSet);
        CREATE(lwRecordSet);

        lwTexto2 :=STRSUBSTNO(Text0044,rParImp."Servidor Exportacion",rParImp."BD Gasoil");
        lwconnect.Open(lwTexto2,rParImp."Usuario Exportacion",rParImp."Contrase¤a Exportacion");

        // Borramos todos los registros con este numero de importacion
        lwTexto2 := STRSUBSTNO(Text50064,lwNomTabla[1], lrImp."No Importacion");
        lwconnect.Execute(lwTexto2);

        // Buscamos el siguiente numero de id de la tabla
        lwRecordSet.Open(STRSUBSTNO(Text50065,lwNomTabla[1]), lwconnect,1,3);
        lwInt := lwRecordSet.RecordCount;
        IF lwInt >0 THEN BEGIN
          lwRecordSet.MoveLast;
          lwId := (lwRecordSet.Fields.Item(Text50066).Value);
        END
        ELSE
          lwId:=0;

        lwRecordSet.Close;

      END;


      lrReg.RESET;
      lrVeh.RESET;
      CLEAR(wlCont);
      CLEAR(wlPosIni); // Posicion inicial
      wVentana.OPEN(Text0032);
      wVentana.UPDATE(2,pwNombreArchivo);

      CLEAR(lrReg);

      CLEAR(lwCamp); // Numero de campo

      lrReg.INIT;
      lrReg."No Importacion":= lrImp."No Importacion";
      REPEAT
        lwCamp +=1;
        lwRet := LeeArch(lwTexto);
        lwTexto := DELCHR(lwTexto,'<>');

        // Traspaso a Registro Diario
        IF wlOk THEN BEGIN
          CASE lwCamp OF // Numero de campo
            1:  BEGIN // Tipo de Transaccion
                  wlOk := EVALUATE(lwInt,lwTexto);
                  wlOk := wlOk AND (lwInt=1);
                END;
            2:  BEGIN // Fecha de Volcado
                END;
            3:  BEGIN // Hora de Volcado
                END;
            9:  BEGIN // Fecha de Transacci¢n
                  IF EVALUATE(lwFecha,lwTexto) THEN
                    lrReg.VALIDATE(Dia, lwFecha);
                END;
            10: BEGIN // Hora de la Transacci¢n
                  IF EVALUATE(lwHora,lwTexto) THEN
                    lrReg.VALIDATE("Hora repostaje" , lwHora);
                END;
            16: BEGIN // Numero del Vehiculo
                  // JPT 04/11/05  A partir de ahora Solo se tiene en cuenta el numero de vehiculo, no la matricula
                  // Si no exite en FB se pone como matricula el mismo numero de vehiculo
                  // P.O Gori Carvajal 03/11/05
                  // JPT 07/02/06 Seg£n Toni Carvajal cojemos las tres £ltimas cifras del codigo de vehiculo
                  // eso es as¡ ya que puede haber codigos que empiezan por 0
                  // En realidad lo que hacemos es que si tiene menos de 3 digitos lo rellenamos con 0
                  lwTexto := DELCHR(lwTexto,'<','0');
                  IF STRLEN(lwTexto) < 3 THEN REPEAT
                    lwTexto := '0' + lwTexto;
                  UNTIL STRLEN(lwTexto)=3;

                  lrReg.Vehiculo := lwTexto;
                  lrVeh.RESET;
                  lrVeh.SETCURRENTKEY(Garaje, Numero);
                  lrVeh.SETRANGE(Numero     , lwTexto);
                  IF lrVeh.FINDFIRST THEN BEGIN
                    lrReg.Matricula  := lrVeh.Matricula;
                    lrReg.Carroceria := lrVeh.Carroceria;
                    lrReg.Garaje           := lrVeh.Garaje;

                    // AJS 25.07.2008
                    // Los campos Marca y Plazas se tienen rellenar desde la ficha del vehiculo

                    lrReg.Marca  := lrVeh.Marca;
                    lrReg.Plazas := lrVeh.Plazas;
                  END
                  ELSE
                    lrReg.VALIDATE(Matricula ,lrReg.Vehiculo);
                END;
            17: BEGIN // Identificaci¢n del Vehiculo
                  // JPT 04/11/05  A partir de ahora Solo se tiene en cuenta el numero de vehiculo, no la matricula
                  // Si no exite en FB se pone como matricula el mismo numero de vehiculo
                  // P.O Gori Carvajal 03/11/05
                  { ** ANULADO**
                  // Para asegurar buscamos el vehiculo por la matricula, si no le pone el codigo importado
                  lwCod10 := COPYSTR(lwTexto,1,10);
                  IF lrVeh.GET(lwCod10) THEN BEGIN
                    lrReg.Vehiculo := lrVeh.Numero;
                    lrReg.Garaje   := lrVeh.Garaje;
                  END;
                  lrReg.Matricula  := COPYSTR(lwTexto,1,10);
                  ** ANULADO** }

                  // JPT 08/02/06 Insertamos nuevo campo Matricula Importaci¢n
                  lwCod10 := COPYSTR(lwTexto,1,10);
                  lrReg."Matricula Importacion" := lwCod10;
                END;
            23: BEGIN // Tipo identificador conductor
                  // Solo entran los del tipo C
                  lrReg."Tipo Conductor" := FORMAT(lwTexto[1]);
                  IF  lwTexto[1] <>'C' THEN
                    lrReg.Sospechoso:= TRUE;
                END;
            26: BEGIN // N£mero de Conductor
                  lrReg."Cod. Conductor" := DELCHR(COPYSTR(lwTexto,1,10),'<','0');
                  // Buscamos el nombre abreviado
                  lrConductor.RESET;
                  IF lrConductor.GET(lrReg."Cod. Conductor") THEN
                    lrReg.Conductor := lrConductor."Nombre Abreviado"
                  ELSE
                    lrReg.Conductor := '';
                END;
            27: BEGIN // Identificacion de conductor
                  lrReg.VALIDATE("Conductor Importacion", lwTexto);
                END;
            33: BEGIN // Contador anterior
                  IF NOT EVALUATE(lwDec, lwTexto) THEN // Contador Km
                    CLEAR(lwDec);
                  lrReg."Kms Reg Anterior" := lwDec;
                END;
            34: BEGIN // Contador actual
                  IF NOT EVALUATE(lwDec, lwTexto) THEN // Contador Km
                    CLEAR(lwDec);

                  // Si no tiene kilometros ponemos los anteriores
                  IF lwDec=0 THEN  // Lo intentamos con los kms importacion
                    lwDec := lrReg."Kms Reg Anterior";
                  IF lwDec=0 THEN
                    lwDec := BuscaKmsAnts(lrReg);

                  // No se insertan lineas sin kilometros
                  // JPT 28/11/05 Insertar registro aunque no tenga kms (P.O. Gori)
                  //wlOk := wlOk AND (lwDec <> 0);
                  IF lwDec <> 0 THEN BEGIN
                    lrReg.Kms:= lwDec;
                    IF lrReg."Kms Reg Anterior" >= lrReg.Kms THEN
                      lrReg.VALIDATE("Rotura Tacografo",TRUE);

                    // JPT 04/11/05 A partir de ahora consideraremos como real la informaci¢n que llega de surtidor
                    // por lo que el registro anterior de Kms es el que viene en el mismo registro de importacion (Gori C.)
                    // Confirmado Toni C. 24/02/06
      // AJS 27.05.2003 El calculo de los kilometros reales se hace sumando los kilometros realizados a los kilometros  ----

                    IF lrReg."Rotura Tacografo" THEN
                      lrReg."Kms realizados" := 0
                    ELSE
                      lrReg."Kms realizados" := lrReg.Kms - lrReg."Kms Reg Anterior";

                    lrReg."Kilometros Reales" :=  lrReg.Kms;
                  END
                  ELSE BEGIN
                    lrReg."Kilometros Reales" := lrReg."Kms Reg Anterior";
                    lrReg.Sospechoso := TRUE;
                  END;
                END;
            35: BEGIN // Tipo de contador
                  lwChar := lwTexto[1];
                  lrReg."Tipo Contador" := FORMAT(lwChar);
                  IF lwChar<>'K'THEN
                    lrReg.Sospechoso := TRUE;
                    //ERROR(lwText001);
                END;
            41: BEGIN // Volumen transacci¢n (cl)
                  IF EVALUATE(lwDec, lwTexto) THEN BEGIN
                    lwDec:= lwDec / 100;
                    // JPT 28/11/05 Insertar registro aunque no se reposte (P.O. Gori)
                    // wlOk := wlOk AND (lwDec <> 0);
                    IF (lrReg.Kms=0) OR (lwDec > 1000) THEN
                      lrReg."Litros repostados" := lwDec
                    ELSE
                      lrReg.VALIDATE("Litros repostados", lwDec);
                    IF (lwDec=0) OR (lwDec > 1000) THEN
                      lrReg.Sospechoso := TRUE;
                  END;
                END;
            42:  BEGIN // NumeroTanque
                   // AJS 30.05.2008
                   // Gori Carvajal indica que el codigo de la borna esta en este campo [NumeroTanque]

                   lrReg."ID Borna" := lwTexto;

                   // AJF 22/05/08
                   // si encontramos la borna en uno de los garajes lo ponemos en el registro.

                   IF EVALUATE(lwBorna, lwTexto) THEN BEGIN
                     lrGaraje.SETRANGE("ID Borna combustible", lwBorna);
                     IF lrGaraje.FINDFIRST THEN
                       lrReg.VALIDATE("Garaje Borna", lrGaraje.Garaje);
                   END;
                 END;
            43:  BEGIN // Descripcion Tanque
                   // AJS 30.05.2008
                   // Gori Carvajal indica que hay que almacenar la descripcion de la borna
                   // en este campo [NumeroTanque]

                   lrReg."Descripcion Borna" := lwTexto;
                 END;
          END;
        END;


        // Traspaso a SQL
        IF lwOkSQL THEN BEGIN
          // Solo debe insertarse en "Registro diario" si "Tipo de Transacci¢n"  es 1, es decir Transacci¢n
          // sin embargo en la tabla SQL de TransUniono se traspasa TODO
          CASE lwCamp OF // Numero de campo
            1: BEGIN
                  lwOkSQL := EVALUATE(lwInt,lwTexto);
                  lwOkSQL := wlOk AND (lwInt=1);
                  IF wlOk THEN BEGIN
                    // Inserta el registro
                    lwId+=1;
                    lwTexto2 := STRSUBSTNO(Text50069,lwNomTabla[1],lwId);
                    lwconnect.Execute(lwTexto2);
                    // Introducimos aqui el numero de importaci¢n
                    lwNomCampo:=Text50070;
                    InsertaCampo(lwconnect,lwNomTabla[1],lwId,lwNomCampo,FORMAT(lrImp."No Importacion"));
                    lwNomCampo:=Text50071;                lwMax:=0;
                  END
                  ELSE
                    lwCamp := 0
               END; // Tipo de Transaccion
            2: BEGIN lwNomCampo:=Text50072;                   lwMax:=0;  END; // Fecha de Volcado
            3: BEGIN lwNomCampo:=Text50073;                    lwMax:=0;  END; // Hora de Volcado
            4: BEGIN lwNomCampo:=Text50074;              lwMax:=0;  END; // N£mero de Transacci¢n
            5: BEGIN lwNomCampo:=Text50075;                    lwMax:=0;  END; // N£mero de Borna
            6: BEGIN lwNomCampo:=Text50076;                  lwMax:=0;  END; // N£mero de esclavo
            7: BEGIN lwNomCampo:=Text50077;                 lwMax:=20; END; // Identificaci¢n
            8: BEGIN lwNomCampo:=Text50078;         lwMax:=0;  END; // Numero de Transaccion de Borna
            9: BEGIN lwNomCampo:=Text50079;               lwMax:=0;  END; // Fecha de Transacci¢n
            10:BEGIN lwNomCampo:=Text50080;                lwMax:=0;  END; // Hora de la Transacci¢n
            11:BEGIN lwNomCampo:=Text50081;               lwMax:=0;  END; // Indice de expendedor
            12:BEGIN lwNomCampo:=Text50082;         lwMax:=0;  END; // N£mero de Pertenencia
            13:BEGIN lwNomCampo:=Text50083;     lwMax:=1;  END; // Tipo de Identificaci¢n de Vehiculo
            14:BEGIN lwNomCampo:=Text50084;         lwMax:=0;  END; // N£mero de Servicio de Vehiculo
            15:BEGIN lwNomCampo:=Text50085; lwMax:=15; END; // Identificaci¢n del servicio del vehiculo
            16:BEGIN lwNomCampo:=Text50086;                 lwMax:=0;  END; // Numero del Vehiculo
            17:BEGIN lwNomCampo:=Text50087;         lwMax:=15; END; // Identificaci¢n del Vehiculo
            18:BEGIN lwNomCampo:=Text50088;                   lwMax:=40; END; // Info comp veh 1
            19:BEGIN lwNomCampo:=Text50089;                   lwMax:=40; END; // Info comp veh 2
            20:BEGIN lwNomCampo:=Text50090;                   lwMax:=40; END; // Info comp veh 3
            21:BEGIN lwNomCampo:=Text50091;                   lwMax:=40; END; // Info comp veh 4
            22:BEGIN lwNomCampo:=Text50092;                   lwMax:=40; END; // Info comp veh 5
            23:BEGIN lwNomCampo:=Text50093;    lwMax:=1;  END; // Tipo de identificacion de conductor
            24:BEGIN lwNomCampo:=Text50094;        lwMax:=0;  END; // N£mero de Servicio de conductor
            25:BEGIN lwNomCampo:=Text50095;lwMax:=15; END; // Identificacion del servicio del conductor
            26:BEGIN lwNomCampo:=Text50096;                lwMax:=0;  END; // N£mero de Conductor
            27:BEGIN lwNomCampo:=Text50097;        lwMax:=15; END; // Identificacion Conductor
            28:BEGIN lwNomCampo:=Text50098;                  lwMax:=40; END; // Info comp cond 1
            29:BEGIN lwNomCampo:=Text50099;                  lwMax:=40; END; // Info comp cond 2
            30:BEGIN lwNomCampo:=Text50100;                  lwMax:=40; END; // Info comp cond 3
            31:BEGIN lwNomCampo:=Text50101;                  lwMax:=40; END; // Info comp cond 4
            32:BEGIN lwNomCampo:=Text50102;                  lwMax:=40; END; // Info comp cond 5
            33:BEGIN lwNomCampo:=Text50103;               lwMax:=0;  END; // Contador Anterior
            34:BEGIN lwNomCampo:=Text50104;                 lwMax:=0;  END; // Contador actual
            35:BEGIN lwNomCampo:=Text50105;                   lwMax:=1;  END; // Tipo de contador
            36:BEGIN lwNomCampo:=Text50106;                           lwMax:=0;  END; // Obra
            37:BEGIN lwNomCampo:=Text50107;             lwMax:=20; END; // Identificacion Obra
            38:BEGIN lwNomCampo:=Text50108;                 lwMax:=0;  END; // Numero de producto
            39:BEGIN lwNomCampo:=Text50109;         lwMax:=10; END; // Identificaci¢n de producto
            40:BEGIN lwNomCampo:=Text50110;                 lwMax:=0;  END; // Numero de surtidor
            41:BEGIN lwNomCampo:=Text50111;           lwMax:=0;  END; // Volumen transacci¢n (cl)
            42:BEGIN lwNomCampo:=Text50112;                   lwMax:=0;  END; // Numero de Tanque
            43:BEGIN lwNomCampo:=Text50113;           lwMax:=20; END; // Identificaci¢n del tanque asociado
            44:BEGIN lwNomCampo:=Text50114;               lwMax:=0;  END; // Cantidad del tanque (cl)
            45:BEGIN lwNomCampo:=Text50115;               lwMax:=1;  END; // Error Transaccion
            46:BEGIN lwNomCampo:=Text50116;          lwMax:=0;  END; // Informe Transaccion Borna
            47:BEGIN lwNomCampo:=Text50117;          lwMax:=0;  END; // Cuota no v lida vehiculo
            48:BEGIN lwNomCampo:=Text50118;                  lwMax:=0;  END; // Cuota vehiculo
            49:BEGIN lwNomCampo:=Text50119;         lwMax:=0;  END; // Cuota no v lida vehiculo 2
            50:BEGIN lwNomCampo:=Text50120;                 lwMax:=0;  END; // Cuota chauffer
            51:BEGIN lwNomCampo:=Text50121;         lwMax:=0;  END; // Procedencia Transaccion
            52:BEGIN lwNomCampo:=Text50122;                   lwMax:=40; END; // Info comp trs 1
            53:BEGIN lwNomCampo:=Text50123;                   lwMax:=40; END; // Info comp trs 2
            54:BEGIN lwNomCampo:=Text50124;                   lwMax:=40; END; // Info comp trs 3
            55:BEGIN lwNomCampo:=Text50125;                   lwMax:=40; END; // Info comp trs 4
            56:BEGIN lwNomCampo:=Text50126;                   lwMax:=40; END; // Info comp trs 5
            57:BEGIN lwNomCampo:=Text50127;                   lwMax:=40; END; // Info comp trs 6
            58:BEGIN lwNomCampo:=Text50128;                   lwMax:=40; END; // Info comp trs 7
            59:BEGIN lwNomCampo:=Text50129;                   lwMax:=40; END; // Info comp trs 8
            60:BEGIN lwNomCampo:=Text50130;                   lwMax:=40; END; // Info comp trs 9
            61:BEGIN lwNomCampo:=Text50131;                  lwMax:=40; END; // Info comp trs 10
          END;


          // Las fechas tienen que ir entrecomilladas
          // IF lwCamp IN [2,3,9,10] THEN
          //  lwTexto := STRSUBSTNO('%1%2%1',Tcms,lwTexto,Tcms);

          IF Formato(lwTexto,lwMax) THEN // No se insertan los campos en blanco en la SQL
            InsertaCampo(lwconnect,lwNomTabla[1],lwId,lwNomCampo,lwTexto);
        END;

        CASE lwRet OF
          2,3: BEGIN // Salto de l¡nea
                 IF wlOk THEN
                   lrReg.INSERT(TRUE);
                 lrReg.INIT;
                 lrReg."No Importacion":= lrImp."No Importacion";
                 wlCont+=1;
                 wVentana.UPDATE(3,wlCont);
                 wlOk    := TRUE;
                 lwOkSQL := TRUE;
                 CLEAR(lwCamp);
               END;
        END;
        wVentana.UPDATE(1,ROUND(wArch.POS/wArch.LEN*10000,1));

      UNTIL lwRet=3;
      wVentana.CLOSE;
      wArch.CLOSE;
    END;

    PROCEDURE LeeArch@1103350004(VAR prValor@1103350001 : Text[50]) : Integer;
    VAR
      lrRet@1103350000 : Integer;
      lwChar@1103350002 : Char;
    BEGIN
      // LeeArch
      // Lee el siguiente campo del archivo
      // Retorna:
      // 1: Fin de Palabra
      // 2: Fin de Linea
      // 3: Fin de Archivo
      // El parametro prValor es de salida, devolviendo el valor del siguiente campo del Archivo

      CLEAR(prValor);
      CLEAR(lrRet);
      REPEAT
        wArch.READ(lwChar);
        CASE lwChar OF
          ';' : lrRet := 1; // Separador de campos
          10..13  : lrRet := 2; // Salto de l¡nea. Separador de registros
        END;
        IF lrRet=0 THEN BEGIN
          prValor := prValor + FORMAT(lwChar);
          IF STRLEN(prValor) = MAXSTRLEN(prValor) THEN
            lrRet:=1;
        END;
        IF wArch.POS >= wArch.LEN THEN
          lrRet:=3;
      UNTIL (lrRet > 0);
      EXIT(lrRet);
    END;

    PROCEDURE InsertaCampo@1103350011(VAR pwconnect@1103350000 : Automation "{EF53050B-882E-4776-B643-EDA472E8E3F2} 2.7:{00000514-0000-0010-8000-00AA006D2EA4}:'Microsoft ActiveX Data Objects 2.7 Library'.Connection";pwNomtabla@1103350005 : Text[50];pwId@1103350003 : Integer;pwCampo@1103350001 : Text[50];pwValor@1103350002 : Text[50]);
    VAR
      wlTexto@1103350004 : Text[100];
    BEGIN
      // InsertaCampo
      // Inserta el campo dado en la tabla SQL
      // pwId es identificaci¢n de la clave primaria

      wlTexto := STRSUBSTNO(Text50132,pwNomtabla,pwCampo,pwValor,pwId);
      pwconnect.Execute(wlTexto);
    END;

    PROCEDURE BuscaFinLin@1100244021(VAR pwPos@1100244000 : Integer) : Boolean;
    VAR
      lwPos2@1100244001 : Integer;
      lwEnc@1100244002 : Boolean;
      lwCod@1100244003 : Code[2];
    BEGIN
      // BuscaFinLin
      // Busca el fin de la linea
      // Devuelve true si la encuentra
      // pwPos Es la posicion tanto de entrada como de salida. Si encuentra un fin de linea indica el inicio de la siguiente
      // SLin es una text constant

      lwPos2 := pwPos;
      REPEAT
        wArch.SEEK(lwPos2);
        wArch.READ(lwCod);
        lwEnc:= lwCod=SLin;
        lwPos2+=1;
      UNTIL lwEnc OR (lwPos2 >= wArch.LEN);
      IF lwEnc THEN
        pwPos := wArch.POS;
      EXIT(lwEnc);
    END;

    PROCEDURE Formato@1103350016(VAR pwValor@1103350000 : Text[50];pwMax@1103350001 : Integer) : Boolean;
    VAR
      Tcms@1103350002 : TextConst 'ESP=''';
    BEGIN
      // Formato
      //

      IF pwValor='' THEN
        EXIT(FALSE);

      IF pwMax <> 0 THEN BEGIN
        pwValor:= COPYSTR(pwValor,1,pwMax)
      END;

      // tiene que ir entrecomillado
      pwValor := STRSUBSTNO('%1%2%1',Tcms,pwValor,Tcms);
      EXIT(TRUE);
    END;

    PROCEDURE LeeTexto@1100244016(pwPos@1100244001 : Integer;pwLargo@1100244004 : Integer) : Text[100];
    VAR
      lwTexto@1100244003 : Text[100];
      wlPos@1100244005 : Integer;
      lwTexto2@1100244006 : Text[100];
      lwChar@1100244007 : Char;
      lwN@1100244008 : Integer;
    BEGIN
      // LeeTexto
      // Devuelve el texto en el punto asignado

      CLEAR(lwTexto);
      wlPos := pwPos-1;
      wArch.SEEK(wlPos);
      FOR lwN:=1 TO pwLargo DO BEGIN
        wArch.READ(lwChar);
        lwTexto[lwN]:=lwChar;
      END;
      EXIT(lwTexto);
    END;

    PROCEDURE LeeNodo@1100222007(VAR NodoEntrada@1100222000 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";pwNombre@1100222001 : Text[30]) : Text[100];
    VAR
      Nodo@1100222003 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";
    BEGIN
      // LeeNodo

      Nodo := NodoEntrada.selectSingleNode(pwNombre);
      IF NOT ISCLEAR(Nodo) THEN
        EXIT(Nodo.text)
      ELSE
        EXIT('');
      CLEAR(Nodo);
    END;

    PROCEDURE LeeNodoTrnc@1103355011(VAR NodoEntrada@1100222000 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";pwNombre@1100222001 : Text[30];pwMax@1103355001 : Integer) : Text[100];
    VAR
      lwText@1103355000 : Text[250];
    BEGIN
      // LeeNodoTrnc
      // Lee Nodo Truncando. pwMax indica el m ximo de caracteres
      //

      lwText := LeeNodo(NodoEntrada, pwNombre);
      IF pwMax <> 0 THEN
        lwText := COPYSTR(lwText,1,pwMax);
      EXIT(lwText);
    END;

    PROCEDURE LeeAtributo@1100222017(VAR NodoEntrada@1100222001 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";pwNombre@1100222000 : Text[30]) : Text[250];
    VAR
      Nodo@1100222002 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";
      TempAttribute@1100222003 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF83-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNamedNodeMap";
      lwText@1103355000 : Text[250];
    BEGIN
      // LeeAtributo
      Nodo :=  NodoEntrada.attributes.getNamedItem(pwNombre);
      IF NOT ISCLEAR(Nodo) THEN BEGIN
        lwText := Nodo.nodeValue;
        EXIT(lwText);
      END
      ELSE
        EXIT('');
      CLEAR(Nodo);
    END;

    PROCEDURE LeeAtributoTrnc@1103355001(VAR NodoEntrada@1100222001 : Automation "{F5078F18-C551-11D3-89B9-0000F81FE221} 4.0:{2933BF80-7B36-11D2-B20E-00C04F983E60}:'Microsoft XML, v4.0'.IXMLDOMNode";pwNombre@1100222000 : Text[30];pwMax@1103355001 : Integer) : Text[250];
    VAR
      lwText@1103355000 : Text[250];
    BEGIN
      // LeeAtributoTrnc
      // Lee Atributo Truncando. pwMax indica el m ximo de caracteres

      lwText := LeeAtributo(NodoEntrada, pwNombre);
      IF pwMax <> 0 THEN
        lwText := COPYSTR(lwText,1,pwMax);
      EXIT(lwText);
    END;

    PROCEDURE BuscaProveedor@1103350000(VAR prParte@1103350001 : Record 7010360) : Boolean;
    VAR
      lrConf@1103350000 : Record 7010371;
      lwPax@1103350002 : Decimal;
      lwOk@1103350003 : Boolean;
      laTTOOs@1103355000 : ARRAY [2] OF Code[10];
      i@1103355001 : Integer;
    BEGIN
      // BuscaProveedor
      // JPT 23/08/04
      // Si el parte cumple unas determinadas caracteristicas estipuladas en una tabla de configuraci¢n
      // se le asigna automaticamente un conductor y vehiculo (asociado a este un proveedor)
      // Devuelve true si se ha encontrado una configuraci¢n

      IF NOT prParte.FIND THEN
        EXIT;

      // AJF 29/04/08
      // Hago una pasada con TTOO principal y si no lo encuentro vuelvo a buscarlo con el TTOO en Blanco.

      laTTOOs[1] := prParte."Touroperador principal";
      laTTOOs[2] := '';

      i := 0;
      lwOk := FALSE;

      WHILE (NOT lwOk) AND (i < 2) DO BEGIN

        i += 1;

        CLEAR(lrConf);
        lrConf.SETCURRENTKEY("Tipo Busqueda",Cliente,TTOO,"Zona Trabajo",Garaje,"Rango Desde","Rango Hasta");
        lrConf.SETRANGE("Tipo Busqueda",lrConf."Tipo Busqueda"::Proveedor);
        lrConf.SETFILTER(Cliente        ,'=%1', prParte.Cliente);
        lrConf.SETFILTER(TTOO           ,'=%1', laTTOOs[i]);  // AJF 29/04/08
        lrConf.SETFILTER(Garaje         ,'=%1', prParte.Garaje);

        prParte.CALCFIELDS("Adultos transportados","Ni¤os transportados");
        lwPax := prParte."Adultos transportados" + prParte."Ni¤os transportados";
        lrConf.SETFILTER("Rango Desde",'<=%1', lwPax);
        lrConf.SETFILTER("Rango Hasta",'>=%1', lwPax);
        IF NOT lrConf.FINDFIRST THEN BEGIN
          lrConf.SETFILTER("Rango Desde",'<=%1|=%2', lwPax, 0);
          lrConf.SETFILTER("Rango Hasta",'>=%1|=%2', lwPax, 0);
        END;

        lrConf.SETFILTER(lrConf."Zona Fisica" ,'=%1', prParte."Zona parte");
        lwOk := lrConf.FINDFIRST;

        // JPT 24/04/06 ampliamos la funcionalidad, adem s de zona de trabajo puede ir por zona fisica
        IF NOT lwOk THEN BEGIN
          lrConf.SETRANGE("Zona Fisica");
          lrConf.SETFILTER("Zona Trabajo" ,'=%1', prParte."Zona trabajo");
          lwOk := lrConf.FINDFIRST;
        END;

      END;

      IF lwOk THEN BEGIN
        prParte."Asignacion rapida":= TRUE;
        prParte.SetBol(1,TRUE); // Eso elimina el control diario
        IF prParte.Vehiculo='' THEN
          prParte.VALIDATE(Vehiculo         , lrConf.GetMatricula);
        IF prParte."Cod Conductor" ='' THEN
          prParte.VALIDATE("Cod Conductor"  , lrConf.Conductor);
        prParte."Asignacion rapida":= FALSE;
      END;

      EXIT(lwOk);
    END;

    PROCEDURE BuscaKmsAnts@1100253001(prReg@1100253001 : Record 7035342) : Integer;
    VAR
      lrReg@1100253000 : Record 7035342;
    BEGIN
      // BuscaKmsAnts
      // Busca Los Kms del £ltimo registro

      CLEAR(lrReg);
      lrReg.ASCENDING(FALSE);
      lrReg.SETCURRENTKEY(Matricula,Dia,Anulado);
      lrReg.SETRANGE(Matricula, prReg.Matricula);
      lrReg.SETRANGE(Anulado,FALSE);
      lrReg.SETFILTER(Dia, '<=%1', prReg.Dia);
      IF lrReg.FINDFIRST THEN
        EXIT(lrReg.Kms);
    END;

    PROCEDURE InsertaVuelosTXT@1103355003(prCab@1103355000 : Record 7010431;pwTexto@1103355001 : Text[1024]);
    VAR
      lrLinVuelo@1103355002 : Record 7035391;
      lwHora@1103355003 : Time;
      lwCodAV@1103355004 : Code[5];
    BEGIN
      // InsertaVuelosTXT
      //


      lwCodAV := DELCHR(COPYSTR(pwTexto,20,5),'<>');

      IF DELCHR(COPYSTR(pwTexto, 33, 8), '<>') <> '' THEN BEGIN
        CLEAR(lrLinVuelo);
        lrLinVuelo.Importacion    := prCab.Importacion;
        lrLinVuelo."No. Cabecera" := prCab."No.";
        lrLinVuelo."No. Vuelo"    := 100;
        lrLinVuelo."Num Vuelo"    := COPYSTR(pwTexto, 33, 8);
        IF EVALUATE(lwHora, STRSUBSTNO('%1:%2', COPYSTR(pwTexto, 41, 2), COPYSTR(pwTexto, 43, 2))) THEN
          lrLinVuelo.Hora := lwHora;
        IF lwCodAV = Text50029 THEN
          lrLinVuelo."Entrada/Salida" := lrLinVuelo."Entrada/Salida"::Entrada
        ELSE
          lrLinVuelo."Entrada/Salida" := lrLinVuelo."Entrada/Salida"::Salida;
        lrLinVuelo.INSERT;
      END;

      IF DELCHR(COPYSTR(pwTexto, 45, 8), '<>') <> '' THEN BEGIN
        CLEAR(lrLinVuelo);
        lrLinVuelo.Importacion    := prCab.Importacion;
        lrLinVuelo."No. Cabecera" := prCab."No.";
        lrLinVuelo."No. Vuelo"    := 200;
        lrLinVuelo."Num Vuelo"    := COPYSTR(pwTexto, 45, 8);
        IF EVALUATE(lwHora, STRSUBSTNO('%1:%2', COPYSTR(pwTexto, 53, 2), COPYSTR(pwTexto, 55, 2))) THEN
          lrLinVuelo.Hora := lwHora;
        IF lwCodAV = Text50029 THEN
          lrLinVuelo."Entrada/Salida" := lrLinVuelo."Entrada/Salida"::Entrada
        ELSE
          lrLinVuelo."Entrada/Salida" := lrLinVuelo."Entrada/Salida"::Salida;
        lrLinVuelo.INSERT;
      END;

      IF DELCHR(COPYSTR(pwTexto,57, 8), '<>') <> '' THEN BEGIN
        CLEAR(lrLinVuelo);
        lrLinVuelo.Importacion    := prCab.Importacion;
        lrLinVuelo."No. Cabecera" := prCab."No.";
        lrLinVuelo."No. Vuelo"    := 300;
        lrLinVuelo."Num Vuelo"    := COPYSTR(pwTexto, 57, 8);
        IF EVALUATE(lwHora, STRSUBSTNO('%1:%2', COPYSTR(pwTexto, 65, 2), COPYSTR(pwTexto, 67, 2))) THEN
          lrLinVuelo.Hora := lwHora;
        IF lwCodAV = Text50029 THEN
          lrLinVuelo."Entrada/Salida" := lrLinVuelo."Entrada/Salida"::Entrada
        ELSE
          lrLinVuelo."Entrada/Salida" := lrLinVuelo."Entrada/Salida"::Salida;
        lrLinVuelo.INSERT;
      END;
    END;

    PROCEDURE CompruebaServicioRepetido@1103355000(prCab@1103355000 : Record 7010431) : Boolean;
    VAR
      lrCab@1103355001 : Record 7010431;
    BEGIN
      // CompruebaServicioRepetido
      //

      // AJS 27.07.2006
      // Comprueba que el servicio no este repetido dentro del mismo fichero
      // A peticion del cliente la comprobacion se hace a nivel de agencia y no de subagencia para que el error sea
      // mas restrictivo

      lrCab.RESET;
      lrCab.SETCURRENTKEY(Importacion,
                          Fecha,
                          Agencia,
                          Subagencia,
                          Servicio,
                          Traspasada);

      lrCab.SETRANGE (Importacion, prCab.Importacion);
      lrCab.SETRANGE (Servicio   , prCab.Servicio);
      lrCab.SETFILTER("No."      , '<>%1', prCab."No.");
      lrCab.SETRANGE (Anulada    , FALSE);
      EXIT( lrCab.FINDFIRST );
    END;

    PROCEDURE ConvASCII_ANSI@1103355002(pwTexto@1103355000 : Text[1024]) : Text[1024];
    VAR
      lwTexto@1103355001 : Text[1024];
      AsciiStr@1103355003 : TextConst 'ESP=" ¡¢£¤¥¦§¨©ª«¬­®¯ÝÝÝÝÝµ¶·¸ÝÝ++½¾++--+-+ÆÇ++--Ý-+ÏÐÑÒÓÔiÖ×Ø++Ý_ÝÞîàáâãäåæçèéêëìíîïðñ=óôõö÷øùúûüýÝ"';
      AnsiStr@1103355002 : TextConst 'ESP="ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×áíóúñÑªº¿®¬½¼¡«»___¦¦ÁÂÀ©¦¦++¢¥++--+-+ãÃ++--¦-+¤ðÐÊËÈiÍÎÏ++__¦Ì¯ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±=¾¶§÷¸°¨·¹³²_"';
    BEGIN
      // ConvASCII_ANSI

      lwTexto := CONVERTSTR(pwTexto,AnsiStr,AsciiStr);
      EXIT(lwTexto);
    END;

    PROCEDURE CompruebaImportado@1103355004(pwNombreArchivo@1103355000 : Text[150];pwAccion@1103355003 : ',Aviso,Error') : Boolean;
    VAR
      lwNArch@1103355001 : Text[100];
      lrImp@1103355002 : Record 7035333;
      lwEnc@1103355004 : Boolean;
      lwText@1103355005 : Text[1024];
    BEGIN
      // CompruebaImportado
      // Devuelve true si hay alguna importacion que no est traspasada ni anulada con el mismo nombre de archvio

      lwNArch:= Extractfilename(pwNombreArchivo);
      CLEAR(lrImp);
      lrImp.SETCURRENTKEY(Tipo,Archivo);
      lrImp.SETRANGE(Tipo    , lrImp.Tipo::Reserva);
      lrImp.SETRANGE(Archivo , lwNArch);
      lrImp.SETRANGE(Transferida , FALSE);
      lrImp.SETRANGE(Anulada     , FALSE);
      lwEnc := lrImp.FINDFIRST;
      IF lwEnc  THEN BEGIN
        lwText := STRSUBSTNO(Text0050, lwNArch, lrImp.Usuario, lrImp.Fecha,lrImp.Hora);
        CASE pwAccion OF
          pwAccion::Aviso : MESSAGE(lwText);
          pwAccion::Error : ERROR(lwText);
        END;
      END;

      EXIT(lwEnc);
    END;

    PROCEDURE BorraParte@1103355007(pwParte@1103355001 : Code[10]);
    VAR
      lrLinPar@1103355000 : Record 7010359;
      lrLinPar2@1103355011 : Record 7010359;
      lrElePto@1103355002 : Record 7010363;
      lrCI@1103355004 : Record 7010414;
      lrExtPar@1103355005 : Record 7010362;
      lrZonPar@1103355006 : Record 7010364;
      lrToPar@1103355007 : Record 7010365;
      lrZonFisPar@1103355008 : Record 7010366;
      lrVueloxParte@1103355009 : Record 7035335;
      lrParte@1103355010 : Record 7010360;
      lrServ@1103355012 : Record 7010358;
      lrAnota@1103355013 : Record 7010435;
      lrHist@1103355014 : Record 7010361;
    BEGIN
      // BorraParte
      // Funci¢n m s o menos rapida de elimninar todo un parte

      IF pwParte='' THEN
        EXIT;

      IF lrParte.GET(pwParte) THEN BEGIN
        IF lrParte.Confirmado THEN
          ERROR(Text0008, lrParte."N§ Parte");
        lrParte.DELETE;
      END;

      lrLinPar.RESET; // Primero borramos las lineas
      lrLinPar.SETCURRENTKEY("N§ Parte","N§ Linea");
      lrLinPar.SETRANGE("N§ Parte"      , pwParte);
      IF lrLinPar.FINDSET(TRUE) THEN BEGIN
        REPEAT
          lrLinPar.DELETE;
          // Comprobamos que no queden servicios sin lineas
          lrLinPar2.SETRANGE("N§ Servicio",lrLinPar."N§ Servicio");
          IF NOT lrLinPar2.FINDFIRST THEN
          IF lrServ.GET(lrLinPar."N§ Servicio") THEN
            lrServ.DELETE(TRUE);
        UNTIL lrLinPar.NEXT=0;
      END;

      // ----  Borrar los elementos a transportar asociados a esta linea  ----
      CLEAR(lrElePto);
      lrElePto.SETCURRENTKEY("N§ Parte","N§ Linea");
      lrElePto.SETRANGE("N§ Parte", pwParte);
      IF lrElePto.FINDSET(TRUE) THEN
        lrElePto.DELETEALL;

      // Comprueba de que no tenga lineas de coste/ingreso
      lrCI.RESET;
      lrCI.SETRANGE("N§ Parte", pwParte);
      IF lrCI.FINDSET(TRUE) THEN
        ERROR(Text0051);

      // Extras
      CLEAR(lrExtPar);
      lrExtPar.SETRANGE("N§ Parte", pwParte);
      IF lrExtPar.FINDSET(TRUE) THEN
        lrExtPar.DELETEALL;

      // Zonas Precio Parte
      CLEAR(lrZonPar);
      lrZonPar.SETRANGE("N§ Parte", pwParte);
      IF lrZonPar.FINDSET(TRUE) THEN
        lrZonPar.DELETEALL;

      // Touroperador x Parte
      CLEAR(lrToPar);
      lrToPar.SETRANGE("N§ Parte", pwParte);
      IF lrToPar.FINDSET(TRUE) THEN
        lrToPar.DELETEALL;

      // Zona fisica Parte
      CLEAR(lrZonFisPar);
      lrZonFisPar.SETRANGE("N§ Parte", pwParte);
      IF lrZonFisPar.FINDSET(TRUE) THEN
        lrZonFisPar.DELETEALL;

      // Borra todas las lineas Vuelos X Parte asignadas - UEX
      lrVueloxParte.RESET;
      lrVueloxParte.SETRANGE("N§Parte" , pwParte);
      IF lrVueloxParte.FINDSET(TRUE) THEN
        lrVueloxParte.DELETEALL;

      // Borramos tambien las lineas de anotaciones de Parte
      CLEAR(lrAnota);
      lrAnota.SETRANGE("N§ Parte", pwParte);
      IF lrAnota.FINDSET(TRUE) THEN
        lrAnota.DELETEALL;


      // JPT 04/06/07 Introducimos registro en el Historico
      lrHist.inserta_registro(lrHist."Tipo Fichero"::Parte, pwParte, 0, Text0054,
                             Text0055 + FORMAT(lrParte.Fecha),
                             DELCHR(lrParte.Cliente, '<>') + ' - ' + DELCHR(lrParte."Codigo Servicio", '<>'));
    END;

    PROCEDURE BuscaOrdenZona@1103355008(pwPunt@1103355000 : Code[10]) : Integer;
    VAR
      lrPunt@1103355001 : Record 7010315;
      lrZonF@1103355002 : Record 7010314;
    BEGIN
      // BuscaOrdenZona

      IF pwPunt = '' THEN
        EXIT;

      IF lrPunt.GET(pwPunt) THEN BEGIN
       IF lrZonF.GET(lrPunt."Zona fisica") THEN
         EXIT(lrZonF.Orden);
      END;
    END;

    PROCEDURE SiguienteCodigo@1103355022(pwTipo@1103355004 : 'Garaje,Codigo Servicio,Cliente,TTOO,Suplemento,Hotel,Extra';pwCliente@1103355002 : Code[20];pwTTOO@1103355001 : Code[10]) : Code[21];
    VAR
      lwCod@1103355000 : Code[20];
      lrConv@1103355003 : Record 7010434;
      lwEnc@1103355005 : Boolean;
      lwPre@1103355006 : Code[10];
    BEGIN
      // SiguienteCodigo

      // Cuando una conversi¢n se busca por el nombre y no por el codigo
      // porque no tiene codigo (xml de TransUnion), y no se encuentra, nos inventamos uno
      // Esta funci¢n busca un codigo del tipo X000001 buca uno que no exista para ese tipo, clienete y TTOO

      lwPre := Text50135;
      CASE pwTipo OF
        pwTipo::Garaje            : lwPre := lwPre + Text50136;
        pwTipo::"Codigo Servicio" : lwPre := lwPre + Text50137;
        pwTipo::Cliente           : lwPre := lwPre + Text50067;
        pwTipo::TTOO              : lwPre := lwPre + Text50138;
        pwTipo::Suplemento        : lwPre := lwPre + Text50139;
        pwTipo::Hotel             : lwPre := lwPre + Text50140;
        pwTipo::Extra             : lwPre := lwPre + Text50029;
      END;

      lwCod := lwPre + '000001';

      lrConv.SETCURRENTKEY(Codigo,Tipo,Cliente,Touroperador);
      lrConv.SETRANGE(Tipo        , pwTipo);
      lrConv.SETRANGE(Cliente     , pwCliente);
      lrConv.SETRANGE(Touroperador, pwTTOO);

      REPEAT
        lrConv.SETRANGE(Codigo, lwCod);
        lwEnc := lrConv.FINDFIRST;
        IF lwEnc THEN
          lwCod := INCSTR(lwCod);
      UNTIL NOT lwEnc;

      EXIT(lwCod);
    END;

    PROCEDURE SetFormFecha@1103355035(pwModo@1103355000 : Integer;pwTexto@1103355001 : Text[30]) : Date;
    VAR
      lwFecha@1103355002 : Date;
      lwText@1103355003 : Text[30];
      lwOk@1103355004 : Boolean;
    BEGIN
      // SetFormFecha
      // Dado el formato de fecha, devuelve el campo fecha Navision

      CLEAR(lwFecha);
      CLEAR(lwText);
      CASE pwModo OF
       2: BEGIN // Formato UEX (2007-06-14)
         lwText := COPYSTR(pwTexto,9,2) + COPYSTR(pwTexto,6,2) + COPYSTR(pwTexto,1,4);
         lwOk := EVALUATE(lwFecha, lwText);
       END;
      END;

      EXIT(lwFecha);
    END;

    PROCEDURE PideCliTO@1103355013(pwTipo@1103355004 : 'Garaje,Codigo Servicio,Cliente,TTOO,Suplemento,Hotel,Extra';pwCodigo@1103355005 : Code[21];pwNombre@1103355010 : Code[50];pwCliente@1103355002 : Code[20];pwTTOO@1103355001 : Code[10];VAR pwCodFinbus@1103355011 : Code[20]);
    VAR
      lrCli@1103355000 : Record 18;
      lrCliTo@1103355003 : Record 7010313;
      lwVentana2@1103355006 : Dialog;
      lText001@1103355007 : TextConst 'ESP=Debe de indicar Un codigo Finbus para Cliente %1 %2';
      lText003@1103355008 : TextConst 'ESP=\#1#############';
      lText002@1103355009 : TextConst 'ESP=Debe de indicar Un codigo Finbus para TTOO %1 %2';
    BEGIN
      // PideCliTO

      // Fuerza a Rellendar el codigo Finbus, si el codigo es cliente o TTOO
      // Para todos los dem s genera un error si no esta debidamente rellenado
      CASE pwTipo OF
        pwTipo::Cliente: BEGIN
          IF pwCliente='' THEN BEGIN
            {
            CLEAR(lrCli);
            IF FORM.RUNMODAL(0, lrCli)= ACTION::LookupOK THEN
              pwCliente := lrCli."No."
            }
            lwVentana2.OPEN(STRSUBSTNO(lText001,pwCodigo,pwNombre) + lText003);
            lwVentana2.INPUT(1, pwCliente);
            lwVentana2.CLOSE;
            IF pwCliente <> '' THEN
              lrCli.GET(pwCliente);
          END;
          pwCodFinbus := pwCliente;
        END;
        pwTipo::TTOO : BEGIN
          IF (pwCliente <> '') AND (pwTTOO='') THEN BEGIN
            {
            CLEAR(lrCliTo);
            lrCliTo.FILTERGROUP(2);
            lrCliTo.SETRANGE(Cliente, pwCliente);
            lrCliTo.FILTERGROUP(0);
            IF FORM.RUNMODAL(0, lrCliTo)= ACTION::LookupOK THEN
              pwTTOO := lrCliTo.TTOO;
            }
            lwVentana2.OPEN(STRSUBSTNO(lText002,pwCodigo,pwNombre) + lText003);
            lwVentana2.INPUT(1, pwTTOO);
            lwVentana2.CLOSE;
            IF pwTTOO <> '' THEN
              lrCliTo.GET(pwCliente,pwTTOO);
          END;
          pwCodFinbus := pwTTOO;
        END;
      END;

      IF pwCliente='' THEN
        ERROR(Text0056, pwCodigo, pwNombre);

      IF (pwTTOO ='') AND (pwTipo <> pwTipo::Cliente) THEN
        ERROR(Text0057, pwCodigo, pwNombre);
    END;

    PROCEDURE ErrorVuelo@1103355010(VAR pw_listavuelos@1103355000 : Code[150];VAR pwError@1103355001 : Text[150]) : Boolean;
    VAR
      lw_listavuelos@1103355010 : Text[150];
      lw_caracter@1103355009 : Char;
      lw_numvuelo@1103355008 : Code[10];
      lw_compvuelo@1103355007 : Code[10];
      lw_posicion@1103355006 : Integer;
      lw_carsnum@1103355005 : Integer;
      lw_carscomp@1103355004 : Integer;
      lw_nuevovuelo@1103355003 : Boolean;
      lErr1@1103355012 : TextConst 'ESP=El Codigo de Compa¤ia %1 tiene m s de 3 digitos';
      lErr2@1103355011 : TextConst 'ESP=El Codigo de Vuelo %1 tiene m s de 5 cifras';
      lwOk@1103355002 : Boolean;
    BEGIN
      // ErrorVuelo
      // Se formatea la lista de vuelos devolviendo la lista formateada si est  ok

      rPar.FINDFIRST;

      lwOk := FALSE;
      lw_listavuelos := '';
      lw_nuevovuelo  := TRUE;
      lw_compvuelo  := '';
      lw_numvuelo   := '';
      lw_carsnum    := 0;
      lw_carscomp   := 0;
      pw_listavuelos := UPPERCASE(pw_listavuelos);
      CLEAR(pwError);

      FOR lw_posicion := 1 TO STRLEN (pw_listavuelos) DO BEGIN
        lw_caracter := pw_listavuelos[lw_posicion];

        IF (lw_caracter IN ['A'..'Z']) OR (lw_compvuelo='') THEN BEGIN

          // ----  si se trata de un nuevo vuelo supondremos que el caracter pertenece a la  ----
          // ----  compa¤ia del vuelo                                                        ----

          IF lw_nuevovuelo AND (lw_caracter <> ' ') THEN BEGIN
            lw_compvuelo := lw_compvuelo + FORMAT(lw_caracter, 0);
            lw_carscomp += 1;
          END

          // ----  sino supondremos que es un caracter que se pone detras del numero de vuelo  ----

          ELSE BEGIN
            lw_numvuelo := lw_numvuelo + FORMAT(lw_caracter, 0);
            lw_carsnum += 1;
          END;
        END
        ELSE
          IF lw_caracter IN ['0'..'9'] THEN BEGIN
            lw_numvuelo   := lw_numvuelo + FORMAT(lw_caracter, 0);
            lw_carsnum    += 1;
            lw_nuevovuelo := FALSE;
          END;

        IF (lw_caracter = ',') OR (lw_posicion = STRLEN(pw_listavuelos)) THEN BEGIN
           // En algunas empresas no generamos errores
          IF NOT (rPar."Empresa Real" IN[rPar."Empresa Real"::TRN]) THEN BEGIN
            IF lw_carscomp > 3 THEN BEGIN
              pwError := STRSUBSTNO(lErr1, lw_compvuelo);
              lwOk := TRUE;
            END;
            IF lw_carsnum > 5 THEN BEGIN
              pwError := STRSUBSTNO(lErr2, lw_numvuelo);
              lwOk := TRUE;
            END;
          END;
          IF DELCHR(lw_compvuelo, '=', ',') <> '' THEN BEGIN

            IF lw_listavuelos <> '' THEN
              lw_listavuelos := lw_listavuelos + ', ';

            lw_listavuelos := lw_listavuelos + DELCHR(lw_compvuelo, '<>') + DELCHR(lw_numvuelo, '<>');
          END;
          lw_nuevovuelo := TRUE;
          lw_compvuelo  := '';
          lw_numvuelo   := '';
          lw_carsnum    := 0;
          lw_carscomp   := 0;
        END;
      END;

      IF NOT lwOk THEN
        pw_listavuelos := lw_listavuelos;

      EXIT(lwOk);
    END;

    PROCEDURE ComprobarLineasManuales@1103355012(VAR prCabecera@1103355004 : Record 7010431;VAR prParte@1103355001 : Record 7010360);
    VAR
      lrLinPar@1103355000 : Record 7010359;
      lrLinAux@1103355003 : Record 7010432;
      lrLinImp@1103355002 : Record 7010432;
      lwFin@1103355005 : Boolean;
    BEGIN
      // ComprobarLineasManuales

      // Comprobamos que las l¡neas manuales de la importaci¢n a£n existan.

      lrLinImp.SETRANGE (Importacion  , prCabecera.Importacion);
      lrLinImp.SETRANGE ("No Cabecera", prCabecera."No.");
      lrLinImp.SETFILTER("N§ Linea"   , '<>%1', 0);
      IF lrLinImp.FINDSET(TRUE) THEN BEGIN
        REPEAT

          lrLinAux := lrLinImp;
          lwFin := (lrLinImp.NEXT = 0);

          lrLinPar.RESET;
          lrLinPar.SETRANGE("N§ Servicio" , lrLinAux."N§ Servicio");
          lrLinPar.SETRANGE("N§ Linea"    , lrLinAux."N§ Linea");
          lrLinPar.SETRANGE("Linea Manual", TRUE);
          IF lrLinPar.ISEMPTY THEN
            lrLinAux.DELETE;

        UNTIL lwFin;
      END;

      // Si encontramos l¡neas manuales en el parte insertamos errores
      // y las insertamos como l¡neas de importaci¢n.

      lrLinImp.SETRANGE("N§ Linea");

      lrLinPar.RESET;
      lrLinPar.SETCURRENTKEY("N§ Parte","N§ Linea");
      lrLinPar.SETRANGE("N§ Parte",     prParte."N§ Parte");
      lrLinPar.SETRANGE("Linea Manual", TRUE);

      IF lrLinPar.FINDSET THEN BEGIN
        REPEAT
          // Miramos si la l¡nea ya ha sido introducida como linea de importacion.

          lrLinImp.SETRANGE("N§ Servicio", lrLinPar."N§ Servicio");
          lrLinImp.SETRANGE("N§ Linea"   , lrLinPar."N§ Linea");
          IF lrLinImp.FINDFIRST THEN BEGIN

            IF lrLinImp.Orden = 0 THEN
              InsertaError(prCabecera.Importacion, prCabecera."No.", lrLinImp.No,
                           STRSUBSTNO(Text0059, lrLinPar.Reserva, lrLinPar."Punto recogida", lrLinPar."FechaHora Vuelo"));

              lrLinImp.Errores := lrLinImp.NoErrores;
              lrLinImp.MODIFY;

          END
          ELSE BEGIN

            // Insertamos la l¡nea manual como l¡nea de importaci¢n y la asociamos a su contraparte en servicios-partes.
            lrLinAux.INIT;
            lrLinAux.Importacion         := prCabecera.Importacion;
            lrLinAux."No Cabecera"       := prCabecera."No.";

            lrLinAux.Emp                 := prParte.Garaje;
            lrLinPar.CALCFIELDS("Zona Trabajo");
            lrLinAux.Zona                := lrLinPar."Zona Trabajo";
            lrLinAux.Agencia             := prCabecera.Agencia;
            lrLinAux.Subagencia          := prCabecera.Agencia + ' - ' + lrLinPar.Touroperador;
            lrLinAux.Servicio            := prCabecera.Servicio;
            lrLinAux."Agencia Viaje"     := lrLinPar."Codigo Servicio";
            lrLinAux.Fecha               := prCabecera.Fecha;
            lrLinAux.Vuelo1              := COPYSTR(lrLinPar.Vuelo, 1, MAXSTRLEN(lrLinAux.Vuelo1));
            lrLinAux."Hora Vuelo1"       := lrLinPar."Hora Vuelo";
            lrLinAux."Hora Presentacion" := lrLinPar."Hora recogida";
            lrLinAux."Codigo Hotel"      := lrLinPar."Punto recogida";
            lrLinAux."Nombre Hotel"      := lrLinPar."Descripcion Punto Recogida";
            lrLinAux."Numero Adultos"    := lrLinPar."Adultos transportados";
            lrLinAux."Numero Ni¤os"      := lrLinPar."Ni¤os transportados";
            lrLinAux.Observaciones       := COPYSTR(lrLinPar.Observaciones, 1, MAXSTRLEN(lrLinAux.Observaciones));
            lrLinAux."Observaciones B"   := COPYSTR(lrLinPar.Observaciones, MAXSTRLEN(lrLinAux.Observaciones),
                                                      MAXSTRLEN(lrLinAux."Observaciones B"));
            lrLinAux."Adultos invitados" := lrLinPar."Adultos invitados ingreso";
            lrLinAux."Ni¤os invitados"   := lrLinPar."Ni¤os invitados ingreso";
            lrLinAux."Nombre Cliente"    := lrLinPar."Nombre Cliente";
            lrLinAux.Reserva             := lrLinPar.Reserva;

            lrLinAux."N§ Linea"      := lrLinPar."N§ Linea";
            lrLinAux."N§ Servicio"   := lrLinPar."N§ Servicio";

            lrLinAux.INSERT(TRUE);

            InsertaError(prCabecera.Importacion, prCabecera."No.", lrLinAux.No, Text0059);

            lrLinAux.Errores := lrLinAux.NoErrores;
            lrLinAux.MODIFY;

          END;

        UNTIL lrLinPar.NEXT = 0;
      END;
    END;

    PROCEDURE ProcesarLineaManual@1103355030(VAR prLinImp@1103355000 : Record 7010432;VAR prLinNueva@1103355010 : Record 7010359;pwNumLinea@1103355001 : Integer);
    VAR
      lrLinParte@1103355003 : Record 7010359;
      lrLinNueva@1103355004 : Record 7010359;
      lrSup@1103355002 : Record 7010363;
      lrNuevoSup@1103355007 : Record 7010363;
      lrNuevoPartAy@1103355008 : Record 7035330;
      lrHistorico@1103355006 : Record 7010361;
      lrNuevoHist@1103355009 : Record 7010361;
    BEGIN
      // ProcesarLineaManual

      lrLinParte.GET(prLinImp."N§ Servicio", prLinImp."N§ Linea");

      prLinNueva.INIT;

      prLinNueva := lrLinParte;
      prLinNueva."N§ Linea" := pwNumLinea;
      prLinNueva.INSERT;

      lrSup.SETCURRENTKEY("N§ Parte","N§ Linea");
      lrSup.SETRANGE("N§ Parte", lrLinParte."N§ Parte");
      lrSup.SETRANGE("N§ Linea", lrLinParte."N§ Linea");
      IF lrSup.FINDSET(TRUE) THEN BEGIN
        REPEAT

          lrNuevoSup := lrSup;
          lrNuevoSup."N§ Servicio" := lrLinParte."N§ Servicio";
          lrNuevoSup."N§ Linea"    := pwNumLinea;
          lrNuevoSup.INSERT;

        UNTIL lrSup.NEXT = 0;

        lrSup.DELETEALL;

      END;

      lrHistorico.SETRANGE("Tipo Fichero", lrHistorico."Tipo Fichero"::Linea);
      lrHistorico.SETRANGE("N§"          , lrLinParte."N§ Servicio");
      lrHistorico.SETRANGE("N§ Linea"    , lrLinParte."N§ Linea");

      IF lrHistorico.FINDSET(TRUE) THEN BEGIN
        REPEAT
          lrNuevoHist            := lrHistorico;
          lrNuevoHist."N§"       := lrLinNueva."N§ Servicio";
          lrNuevoHist."N§ Linea" := lrLinNueva."N§ Linea";
          lrNuevoHist.INSERT;
        UNTIL lrHistorico.NEXT = 0;

        lrHistorico.DELETEALL;
      END;

      lrLinParte.DELETE;
    END;

    PROCEDURE InsertaExtrasParte@1103355005(VAR prCab@1103355000 : Record 7010431;VAR prParte@1103355001 : Record 7010360;VAR prExtrasTMP@1103355009 : TEMPORARY Record 7010362;pwCliente@1103355007 : Code[20];pwTO@1103355008 : Code[10]);
    VAR
      lrExtSupl@1103355002 : Record 7035389;
      lwNumExtr@1103355003 : Integer;
      lwCodExtra@1103355006 : Code[10];
      lwTO@1103355005 : Code[10];
    BEGIN
      // InsertaExtrasParte

      CLEAR(lrExtSupl);
      lrExtSupl.SETRANGE(Importacion    , prCab.Importacion);
      lrExtSupl.SETRANGE("No Cabecerra" , prCab."No.");
      lrExtSupl.SETRANGE(Tipo, lrExtSupl.Tipo::Extra);

      IF lrExtSupl.FINDSET THEN BEGIN

        lwNumExtr := 0;

        REPEAT

          lwCodExtra := GetConv(6, lrExtSupl.Codigo, pwCliente, pwTO);  // C¢digo Extra.
          lwTO       := GetConv(3, lrExtSupl.Subagencia, pwCliente,''); // C¢digo TourOperador.

          CLEAR(prExtrasTMP);
          prExtrasTMP."N§ Parte"   := prParte."N§ Parte";
          prExtrasTMP.Extra        := lwCodExtra;
          prExtrasTMP.Touroperador := lwTO;
          lwNumExtr                += 1000;
          prExtrasTMP."N§ Extra"   := lwNumExtr;

          prExtrasTMP.INSERT;  // No se valida

        UNTIL lrExtSupl.NEXT=0;

      END;
    END;

    PROCEDURE InsertaSuplLinea@1103355018(VAR prLinImp@1103355003 : Record 7010432;VAR prLinpar@1103355002 : Record 7010359;VAR prSuplTMP@1103355008 : TEMPORARY Record 7010363;pwCodSupl@1103355000 : Code[10];pwCliente@1103355006 : Code[20];pwTO@1103355007 : Code[10]);
    VAR
      lrExtSupl@1103355004 : Record 7035389;
      lwCodSupl@1103355005 : Code[10];
    BEGIN
      // InsertaSuplLinea
      // Si el codigo de suplemento es el codificado como gratis, en lugar de crear un suplemento
      // los a¤adiremos a la cantidad de ni¤os transportados y a los ni¤os invitados

      IF pwCodSupl <> rParImp."Codigo Ni¤os gratuitos" THEN BEGIN

        prSuplTMP.INIT;

        prSuplTMP."N§ Servicio"     := prLinpar."N§ Servicio";
        prSuplTMP."N§ Linea"        := prLinpar."N§ Linea";
        prSuplTMP."Cod. Suplemento" := pwCodSupl;
        prSuplTMP.Cantidad          := prLinImp."Cantidad Suplemento";
        //lrSuplemento."N§ Parte"        := prLinpar."N§ Parte";
        prSuplTMP.INSERT;

        IF pwCodSupl = rPar."Cod. Suplemento Rapido 1" THEN
          prLinpar."Suplemento Rapido 1" := prSuplTMP.Cantidad;
        IF pwCodSupl = rPar."Cod. Suplemento Rapido 2" THEN
          prLinpar."Suplemento Rapido 2" := prSuplTMP.Cantidad;
      END
      ELSE BEGIN
        prLinpar."Ni¤os transportados"    := prLinImp."Numero Ni¤os" + prLinImp."Cantidad Suplemento";
        prLinpar."Ni¤os invitados ingreso":= prLinImp."Cantidad Suplemento";
      END;

      lrExtSupl.SETRANGE(Importacion    , prLinImp.Importacion);
      lrExtSupl.SETRANGE("No Cabecerra" , prLinImp."No Cabecera");
      lrExtSupl.SETRANGE("No Linea"     , prLinImp.No);
      lrExtSupl.SETRANGE(Tipo, lrExtSupl.Tipo::Suplemento);
      IF lrExtSupl.FINDSET THEN BEGIN
        REPEAT
          // El primero codigo est  en la linea. No queremos que se duplique
          IF lrExtSupl.Codigo <> prLinImp."Codigo Suplemento" THEN BEGIN
            CLEAR(prSuplTMP);
            lwCodSupl := GetConv(4, lrExtSupl.Codigo, pwCliente, pwTO);
            prSuplTMP."N§ Servicio"     := prLinpar."N§ Servicio";
            prSuplTMP."N§ Linea"        := prLinpar."N§ Linea";
            prSuplTMP."Cod. Suplemento" := lwCodSupl;
            prSuplTMP.Cantidad          := lrExtSupl.Cantidad;
            //prSuplTMP."N§ Parte"        := prLinpar."N§ Parte";
            prSuplTMP.INSERT;

            IF lwCodSupl = rPar."Cod. Suplemento Rapido 1" THEN
              prLinpar."Suplemento Rapido 1" := prSuplTMP.Cantidad;
            IF lwCodSupl = rPar."Cod. Suplemento Rapido 2" THEN
              prLinpar."Suplemento Rapido 2" := prSuplTMP.Cantidad;
          END;
        UNTIL lrExtSupl.NEXT=0;
      END;
    END;

    PROCEDURE InsertaVuelosLinea@1103355014(VAR prCabImp@1103355000 : Record 7010431;VAR prLinImp@1103355002 : Record 7010432;VAR prLinPar@1103355003 : Record 7010359;VAR prVueloParteTMP@1103355004 : TEMPORARY Record 7035335);
    VAR
      lrVuelos@1103355001 : Record 7035391;
    BEGIN
      // InsertaVuelosLinea

      lrVuelos.SETRANGE(Importacion   , prCabImp.Importacion);
      lrVuelos.SETRANGE("No. Cabecera", prCabImp."No.");

      IF (prCabImp."Servicio shuttle") THEN BEGIN
        lrVuelos.SETRANGE("Num Vuelo", prLinImp.Vuelo1);
        IF lrVuelos.FINDFIRST THEN BEGIN
          A¤adeVuelo2(prLinPar, lrVuelos, prVueloParteTMP);
        END;
        lrVuelos.SETRANGE("Num Vuelo");
      END
      ELSE BEGIN
        IF lrVuelos.FINDSET THEN BEGIN
          REPEAT
            A¤adeVuelo2(prLinPar, lrVuelos, prVueloParteTMP);
          UNTIL lrVuelos.NEXT = 0;
        END;
      END;
    END;

    PROCEDURE ProcesarObservaciones@1103355016(VAR prCabImp@1103355000 : Record 7010431;VAR prLinImp@1103355005 : Record 7010432;VAR prLinPar@1103355001 : Record 7010359);
    VAR
      lwHora@1103355004 : Time;
      lwBebes@1103355003 : Integer;
      lwPosHora@1103355002 : Integer;
      lrCodSer@1000000000 : Record 7010320;
    BEGIN
      // ProcesarObservaciones

      lrCodSer.GET(prLinPar."Codigo Servicio");

      IF prCabImp."Fichero XML" THEN
      BEGIN
        IF EVALUATE(lwHora, COPYSTR(prLinPar.Observaciones, 1, 5)) THEN
        BEGIN
          IF (lwHora <> 0T) AND (lwHora <> 000000T) AND (lrCodSer."Tipo orden" = lrCodSer."Tipo orden"::Salida) THEN
            prLinPar."Hora recogida" := lwHora;
          prLinPar.Observaciones := COPYSTR(prLinPar.Observaciones, 6, STRLEN(prLinPar.Observaciones));
          prLinPar.Observaciones := DELCHR(prLinPar.Observaciones, '<>');
        END;
      END
      ELSE
      BEGIN
        lwPosHora := STRPOS(prLinPar.Observaciones,':');
        IF lwPosHora  = 6 THEN
        BEGIN
          IF EVALUATE(lwBebes, COPYSTR(prLinPar.Observaciones,1, 3)) THEN
          BEGIN
            IF EVALUATE(lwHora, COPYSTR(prLinPar.Observaciones, 4, 5)) THEN
            BEGIN
              IF (lwHora <> 0T) AND (lwHora <> 000000T) AND (lrCodSer."Tipo orden" = lrCodSer."Tipo orden"::Salida) THEN
              BEGIN
                prLinPar."Hora recogida" := lwHora;
                prLinPar.Observaciones := COPYSTR(prLinPar.Observaciones,1, 3) + ' ' +
                                          COPYSTR(prLinPar.Observaciones, 9, STRLEN(prLinPar.Observaciones));
              END;
              prLinPar.Observaciones := DELCHR(prLinPar.Observaciones, '<>');
            END;
          END;
        END
        ELSE
        BEGIN
          IF EVALUATE(lwHora, COPYSTR(prLinPar.Observaciones, 1, 5)) THEN
          BEGIN
            IF (lwHora <> 0T) AND (lwHora <> 000000T) AND (lrCodSer."Tipo orden" = lrCodSer."Tipo orden"::Salida) THEN
            BEGIN
              prLinPar."Hora recogida" := lwHora;
              prLinPar.Observaciones := COPYSTR(prLinPar.Observaciones, 6, STRLEN(prLinPar.Observaciones));
            END;
            prLinPar.Observaciones := DELCHR(prLinPar.Observaciones, '<>');
            lwBebes := 0;
          END;
        END;
      END;

      IF prLinImp."Observaciones B" <> '' THEN
      BEGIN
        prLinPar.Observaciones += COPYSTR(prLinImp."Observaciones B",1,
                                          MAXSTRLEN(prLinPar.Observaciones)-STRLEN(prLinPar.Observaciones));
        prLinPar.Observaciones := DELCHR(prLinPar.Observaciones, '<>');
      END;
    END;

    PROCEDURE LimpiaParteReimportar@1103355025(VAR prParte@1103355000 : Record 7010360;pwTTOO@1103355008 : Code[10]);
    VAR
      lrLinPar@1103355001 : Record 7010359;
      lrLinAux@1103355004 : Record 7010359;
      lrSup@1103355002 : Record 7010363;
      lrToPar@1103355007 : Record 7010365;
      lwFin@1103355005 : Boolean;
    BEGIN
      // LimpiaParteReexportar

      lrLinPar.SETCURRENTKEY("N§ Parte","N§ Linea");
      lrLinPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      // AJF 31/07/08
      // Solo borramos las l¡neas no manuales.
      // Tamb¡en tenemos que borrar los suplementos de uno en uno
      // ya que si no borrar  los de las l¡neas manuales.
      lrLinPar.SETRANGE("Linea Manual", FALSE);
      IF lrLinPar.FINDSET(TRUE) THEN BEGIN
        REPEAT

          // Borramos tambien los registros relacionados
          // Suplementos
          CLEAR(lrSup);
          lrSup.SETCURRENTKEY("N§ Parte","N§ Linea");
          lrSup.SETRANGE("N§ Parte", prParte."N§ Parte");
          lrSup.SETRANGE("N§ Linea", lrLinPar."N§ Linea");
          IF lrSup.FINDFIRST THEN
            lrSup.DELETEALL;

          lrLinAux := lrLinPar;
          lwFin := (lrLinPar.NEXT = 0);
          lrLinAux.DELETE;

        UNTIL lwFin;
      END;

      CLEAR(lrToPar);
      lrToPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      lrToPar.DELETEALL;
    END;

    PROCEDURE ActualizaTTOOParte@1103355019(VAR prCabImp@1103355003 : Record 7010431;VAR prParte@1103355000 : Record 7010360;VAR prLinParte@1103355001 : Record 7010359;VAR prToPar@1103355002 : Record 7010365;pwCliente@1103355005 : Code[20];pwTo@1103355004 : Code[10]);
    BEGIN
      // ActualizaTTOOParte

      IF NOT prToPar.GET(prParte."N§ Parte", pwTo) THEN BEGIN

        prToPar."Cliente operativo"        := pwCliente;
        prToPar."Cliente estadistico"      := prParte.GetClienteEstadistico(pwTo);
        prToPar.Touroperador               := pwTo;
        prToPar."N§ Parte"                 := prParte."N§ Parte";
        prToPar.INSERT;

        prToPar.Garaje                     := prParte.Garaje;
        prToPar.Bono                       := prParte.Bono;
        prToPar."Fecha Servicio Parte"     := prParte.Fecha;
        prToPar."Fecha Facturacion"        := prParte."Fecha facturacion";
        prToPar.Facturable                 := prParte.Facturable;
        prToPar."Ingreso Precios Por"      := prParte."Ingreso Precios por";
        prToPar."Coste Precios Por"        := prParte."Coste Precios por";
        prToPar.Gestor                     := prParte.Gestor;
        prToPar.Vehiculo                   := prParte.Vehiculo;
        prToPar."Tipo Vehiculo"            := prParte."Tipo Vehiculo facturacion";
        prToPar."Codigo Servicio"          := prParte."Codigo Servicio";
        prToPar."Tipo Servicio"            := prParte."Tipo Servicio";
        prToPar."Adultos transportados"    := 0;
        prToPar."Ni¤os transportados"      := 0;
        prToPar."Adultos invitados ingreso":= 0;
        prToPar."Ni¤os invitados ingreso"  := 0;
        prToPar."Adultos invitados coste"  := 0;
        prToPar."Ni¤os invitados coste"    := 0;
        prToPar."Pax Transportados"        := 0;

      END;

      prToPar."Adultos transportados"     += prLinParte."Adultos transportados";
      prToPar."Ni¤os transportados"       += prLinParte."Ni¤os transportados";
      prToPar."Adultos invitados ingreso" += prLinParte."Adultos invitados ingreso";
      prToPar."Ni¤os invitados ingreso"   += prLinParte."Ni¤os invitados ingreso";
      prToPar."Adultos invitados coste"   += prLinParte."Adultos invitados coste";
      prToPar."Ni¤os invitados coste"     += prLinParte."Ni¤os invitados coste";
      prToPar."Pax Transportados"         += prLinParte."Adultos transportados" + prLinParte."Ni¤os transportados";

      prToPar.MODIFY;
    END;

    PROCEDURE InsertaDatosParte@1103355020(VAR prParte@1103355003 : Record 7010360;VAR prCabImp@1103355005 : Record 7010431;VAR prLinImp@1103355006 : Record 7010432;VAR pwCliente@1103355007 : Code[20];VAR pwTTOO@1103355008 : Code[10];pwModParte@1103355009 : Boolean);
    VAR
      lrCliente@1103355004 : Record 18;
      lrCodSer@1103355002 : Record 7010320;
      lrTipSer@1103355001 : Record 7010319;
      lrPunt@1103355000 : Record 7010315;
      lrClientTTOO@1103355010 : Record 7010313;
      lwReferencia@1103355011 : Text[30];
    BEGIN
      // InsertaDatosParte

      IF NOT pwModParte THEN
        prParte.Garaje            := GetConv(0,prLinImp.Emp,pwCliente,pwTTOO);

      prParte.Fecha               := prCabImp.Fecha;
      prParte."Fecha facturacion" := prCabImp.Fecha;
      prParte.Cliente             := pwCliente;

      lrCliente.GET(pwCliente);
      prParte."Busca precio ingreso" := lrCliente."Busca precio ingreso";

      prParte."Codigo Servicio"   :=  GetConv(1,prLinImp."Agencia Viaje",pwCliente,pwTTOO);
      lrCodSer.RESET; // Buscamos el tipo de Servicio
      IF lrCodSer.GET(prParte."Codigo Servicio") THEN
        prParte."Tipo Servicio":= lrCodSer."Tipo servicio";
      IF lrTipSer.GET(lrCodSer."Tipo servicio") THEN BEGIN
        prParte."Calcular maletas" :=  lrTipSer."Calcular Maletas";
        prParte."Origen/Destino"   :=  lrTipSer."Pto Origen x Defecto";
      END;

      IF prCabImp."Origen/Destino" <> '' THEN
        prParte."Origen/Destino" :=  GetConv(5,prCabImp."Origen/Destino",pwCliente,pwTTOO);
      IF prParte."Origen/Destino" <> '' THEN BEGIN
        IF lrPunt.GET(prParte."Origen/Destino") THEN
          prParte.Presentacion := COPYSTR(lrPunt.Descripci¢n, 1, MAXSTRLEN(prParte.Presentacion));
      END;

      // AJS 23.03.2006
      // Temporalmente Europalia no rellena el lugar de presentacion

      IF (prCabImp.Agencia <> Text50143) THEN BEGIN
        IF prLinImp."Lugar Presentacion" <> '' THEN
          prParte.Presentacion     := prLinImp."Lugar Presentacion";
      END;

      // AJS 28.05.2004
      // El lugar de presentacion en las salidas es el primer hotel

      IF prLinImp."Lugar Presentacion" = '' THEN
        IF prParte."Codigo Servicio" <> rPar."Codigo Entradas" THEN
          prParte.Presentacion := prLinImp."Nombre Hotel";

      prParte.Observaciones := DELCHR(prCabImp.Observaciones, '<>');

      prParte.Guia                    := prLinImp."Nombre Guia";
      prParte."Touroperador principal":= pwTTOO;
      CLEAR(lrClientTTOO);
      lrClientTTOO.GET(pwCliente, pwTTOO);
      prParte."Ingreso Precios por" := lrClientTTOO."Precios por";
      IF prParte."Ingreso Precios por" = prParte."Ingreso Precios por"::"Zona mas alejada" THEN
        prParte."Busca precio pasaje x zona ing" := FALSE;
      prParte.Gestor := lrClientTTOO.Gestor;

      prParte."Hora 1er Vuelo"  := Hora1erVuelo(prLinImp);
      prParte."Hora inicio"     := GetHoraPresentacion(prLinImp);

      prParte."Dia siguiente"   := prCabImp."D¡a siguiente";
      prParte.ActualizaHoraDT;

      // AJS 29.04.2004
      // Rellenar la hora de final en las salidas
      prParte."Hora final"      := GetHoraFinal(prParte."Codigo Servicio", prLinImp);

      // JPT 19/12/05 Aplicamos los nuevos campos
      CLEAR(lwReferencia);
      // prParte.Referencia      := prLinImp.Servicio;
      // JPT 18/04/06 Se trunca a 30 en Partes (Gori Carvajal)
      lwReferencia := COPYSTR(prCabImp.Referencia,1, MAXSTRLEN(lwReferencia));
      IF lwReferencia = '' THEN
        lwReferencia := prLinImp.Servicio;
      prParte.Referencia          := lwReferencia;
      prParte.Letreros            := prCabImp.Letreros;

      prParte.Vuelos              := GetVuelos(prLinImp);

      CLEAR (prParte."Adultos trans. soporte");
      CLEAR (prParte."Ni¤os trans. soporte");

      // AJS 08.11.2005
      // Rellenamos el campo Usuario y origen creacion

      prParte.Usuario := USERID;

      // AJF 28.01.2008 - DRF 07004
      // Si es una reserva proveniente de shuttle la marcamos como tal en el origen de creacion.

      IF (prCabImp."Servicio shuttle") THEN BEGIN
        prParte."Origen creacion" := prParte."Origen creacion"::Shuttle;
      END
      ELSE BEGIN
        prParte."Origen creacion" := prParte."Origen creacion"::Importacion;
      END;

      // AJF fin.

      prParte.Vehiculo        := prCabImp.Vehiculo;
      prParte."Cod Conductor" := prCabImp.Conductor;
    END;

    PROCEDURE InsertaDatosLinea@1103355026(VAR prLinParte@1103355000 : Record 7010359;VAR prCabImp@1103355001 : Record 7010431;VAR prLinImp@1103355002 : Record 7010432;VAR prParte@1103355003 : Record 7010360;VAR prServicio@1103355007 : Record 7010358;pwNumLinea@1103355004 : Integer;pwCliente@1103355005 : Code[20];VAR pwTTOO@1103355006 : Code[10]);
    VAR
      lrPunt@1103355008 : Record 7010315;
      lrZonaFis@1103355009 : Record 7010314;
      lrCodSer@1103355010 : Record 7010320;
    BEGIN
      // InsertaDatosLinea

      prLinParte.INIT;
      prLinParte."N§ Linea"    := pwNumLinea;
      prLinParte."N§ Servicio" := prServicio."N§ Servicio";

      prLinParte."N§ Parte"              := prParte."N§ Parte";

      // AJF 01/02/2008 - DRF 07004
      // Necesitamos la informaci¢n de Origen creacion en las lineas de pate para reagrupar reservas.
      prLinParte."Origen creacion"       := prParte."Origen creacion";

      prLinParte."Punto recogida"        := GetConv(5,prLinImp."Codigo Hotel",pwCliente,pwTTOO);
      lrPunt.GET(prLinParte."Punto recogida");
      lrPunt.TESTFIELD("Zona fisica");
      prLinParte."Zona fisica" := lrPunt."Zona fisica";
      lrZonaFis.GET(prLinParte."Zona fisica");
      prLinParte."Orden zona" := lrZonaFis.Orden;

      lrCodSer.GET(prParte."Codigo Servicio");
      IF lrCodSer."Tipo orden" = lrCodSer."Tipo orden"::Entrada THEN
        prLinParte."Orden Hotel en zona" := lrPunt."Orden entrada"
      ELSE
        prLinParte."Orden Hotel en zona" := lrPunt."Orden salida";
      prLinParte."Imprimir Documento Descriptivo" := lrPunt."Marcar Doc.Descrpt por defecto" AND
                                                   (lrPunt."Documento Descriptivo" <>'');
      prLinParte."Descripcion Punto Recogida"     := lrPunt.Descripci¢n;

      prLinParte.Fecha             := prParte.Fecha;

      // AJF 06/02/2008 - DRF 07004
      // S¡ es un servicio shuttle necesitaremos el campo FH Vuelo actualizado.
      IF (prCabImp."Servicio shuttle") THEN
      BEGIN
        IF (prLinImp."Hora Vuelo1" < prParte."Hora inicio") AND (lrCodSer."Tipo orden" = lrCodSer."Tipo orden"::Salida) THEN
        BEGIN
          prLinParte."FechaHora Vuelo" :=
            CREATEDATETIME(CALCDATE(Text50144, prLinImp.Fecha), prLinImp."Hora Vuelo1");
        END
        ELSE
        BEGIN
          prLinParte."FechaHora Vuelo" := CREATEDATETIME(prLinImp.Fecha, prLinImp."Hora Vuelo1");
        END;
        // JPT 02/02/10 Funci¢n para asignar el valor "FechaHora Vuelo BI"
        prLinParte.ConvDTBIV;

        // AJF 01/04/08
        // Hay que rellenar tambin la FechaHora parte en las l¡neas
        // para que se ordenen bin en la ventana de reservas.

        // JPT 02/02/10 Validamos par que se rellena "FechaHora Parte BI"
        // prLinParte."FechaHora Parte" := prParte."Hora Inicio DT";
        prLinParte.VALIDATE("FechaHora Parte", prParte."Hora Inicio DT");
      END;

      // AJS 29.02.2008
      // En los partes de shuttle la conversion de touroperador se hace para cada linea

      IF prCabImp."Servicio shuttle" THEN BEGIN
        pwTTOO                := GetConv(3, prLinImp.Subagencia, pwCliente,'');
        prLinParte.Touroperador := pwTTOO;
      END
      ELSE
        prLinParte.Touroperador := pwTTOO;

      prLinParte."Codigo Servicio"          := prParte."Codigo Servicio";
      prLinParte."Tipo Servicio"            := prParte."Tipo Servicio";
      prLinParte."Adultos transportados"    := prLinImp."Numero Adultos";
      prLinParte."Ni¤os transportados"      := prLinImp."Numero Ni¤os";
      prLinParte."Paxes transportados"      := prLinImp."Numero Adultos" + prLinImp."Numero Ni¤os";
      prLinParte."Adultos invitados ingreso":= prLinImp."Adultos invitados";
      prLinParte."Ni¤os invitados ingreso"  := prLinImp."Ni¤os invitados";

      //. La hora de recogida no la queremos en las entradas
      IF lrCodSer."Tipo orden" = lrCodSer."Tipo orden"::Salida THEN
        prLinParte."Hora recogida"            := prLinImp."Hora Presentacion";

      prLinParte.Observaciones              := DELCHR(prLinImp.Observaciones, '<>');
      prLinParte.IATA                       := prLinImp.Destino;
      prLinParte.Letra                      := prLinImp.Letra;

      ProcesarObservaciones(prCabImp, prLinImp, prLinParte);

      prLinParte."Nombre Cliente"  := prLinImp."Nombre Cliente"; // Nombre del Cliente (Ter) JPT 12/02/07
      prLinParte.Reserva           := prLinImp.Reserva;          // Reserva (Ter) JPT 12/02/07
    END;

    PROCEDURE Traspasa@1103355021(pwImp@1100244000 : Integer;pwNumCab@1100244017 : Integer;pwImprimir@1103350000 : Boolean;pwAutomatica@1103350005 : Boolean);
    VAR
      lrCab@1100244010 : Record 7010431;
      lrLin@1100244009 : Record 7010432;
      lrConvHot@1100244007 : Record 7035322;
      lrHstE@1100244006 : Record 7035334;
      lrClientTTOO@1100244005 : Record 7010313;
      lrParte@1100244004 : Record 7010360;
      lrToPar@1103355006 : Record 7010365;
      lrImp@1100244011 : Record 7035333;
      lrLinPar@1100244012 : Record 7010359;
      lrCodSer@1100244008 : Record 7010320;
      lrServicio@1100244014 : Record 7010358;
      lrSup@1100244016 : Record 7010363;
      lrConv@1100244015 : Record 7010434;
      lrInf@1103350003 : Record 7035384;
      lrPartAy@1103355002 : Record 7035330;
      lrTipSer@1103355003 : Record 7010319;
      lrPunt@1103355004 : Record 7010315;
      lrZonFis@1103355005 : Record 7010314;
      lrGaraje@1103355008 : Record 7010310;
      lrCliente@1103355010 : Record 18;
      lrLinAux@1103355012 : Record 7010359;
      lrParteTMP@1103355001 : TEMPORARY Record 7010360;
      lrLinParteTMP@1103355009 : TEMPORARY Record 7010359;
      lrVuelosParteTMP@1103355011 : TEMPORARY Record 7035335;
      lrSuplParteTMP@1103355015 : TEMPORARY Record 7010363;
      lrToParteTMP@1103355016 : TEMPORARY Record 7010365;
      lrExtrasTMP@1103355017 : TEMPORARY Record 7010362;
      cFunParAd@1100253001 : Codeunit 7010410;
      lwTotal@1100244003 : Integer;
      lwCont@1100244002 : Integer;
      lwText@1100244001 : Text[150];
      lwText2@1103350006 : Text[150];
      lwCodSupl@1100244018 : Code[10];
      lwNumLinea@1100244013 : Integer;
      lwCliente@1100244020 : Code[20];
      lwTTOO@1100244021 : Code[10];
      lwIdInforme@1103350002 : Integer;
      lwFechas@1103350004 : ARRAY [2] OF Date;
      lwNPartes@1103350001 : ARRAY [2] OF Code[10];
      lwReferencia@1100253000 : Text[30];
      lwCode@1100253004 : Code[10];
      lwNumExtr@1100253005 : Integer;
      lwModificaParte@1103355000 : Boolean;
      lwTraspasa@1103355007 : Boolean;
      lwFin@1103355013 : Boolean;
      lwLineasManuales@1103355014 : Boolean;
    BEGIN
      // Traspasa

      // JPT 11/12/06 Procuramos eliminar toda validaci¢n de campos par evitar que la logica de negocio
      // enrede el traspaso m s de la cuenta. Todas las funciones necesarias deber n de implementarse por separado

      rParImp.FINDFIRST;

      // Traspasa una cabecera de importacion o una importacion entera si el parametro pwNumcab se deja a 0

      CLEAR(lwNPartes); // Array para delimitar de que parte a que parte se ha de imprimir
      CLEAR(lwFechas);

      IF NOT lrImp.GET(lrImp.Tipo::Reserva, pwImp) THEN
        ERROR(Text0006);

      IF lrImp.Transferida THEN
        ERROR(Text0007);

      IF lrImp.Anulada THEN
        ERROR(Text0020);

      IF NOT pwAutomatica THEN BEGIN
        IF lrImp.Usuario = UPPERCASE(USERID) THEN BEGIN
          // Comprobamos que estamos traspasando la primera importaci¢n sin traspasar ni anular
          lrImp.RESET;
          lrImp.BuscaPrimero(lrImp);
          IF lrImp."No Importacion" <> pwImp THEN
            ERROR(Text0015,pwImp,lrImp."No Importacion");
        END
        ELSE BEGIN
          IF NOT CONFIRM(Text0038,FALSE,lrImp.Usuario) THEN
            EXIT;

          // Si la importacion es de otro usuario solo lo permitimos si el usuario actual no tiene
          // importaciones pendientes de traspasar.

          lrImp.RESET;
          lrImp.SETCURRENTKEY(Transferida,Anulada,Usuario);
          lrImp.SETRANGE(Tipo       , lrImp.Tipo::Reserva);
          lrImp.SETRANGE(Transferida, FALSE);
          lrImp.SETRANGE(Anulada    , FALSE);
          lrImp.SETRANGE(Usuario    , USERID);
          IF lrImp.FINDFIRST THEN
            ERROR(Text0037);
        END;
      END;

      lrImp.RESET;
      IF NOT lrImp.GET(lrImp.Tipo::Reserva, pwImp) THEN
        ERROR(Text0006, pwImp);

      rPar.GET;

      lrParte.RESET;
      lrLinPar.RESET;

      IF NOT pwAutomatica THEN BEGIN

        IF pwNumCab = 0 THEN
          lwText := Text0009
        ELSE
          lwText := Text0010;

        IF pwImprimir THEN
          lwText2:= Text0043;

        IF NOT CONFIRM(lwText,TRUE,pwImp,pwNumCab,lwText2) THEN
          EXIT;
      END;

      lrCab.RESET;
      lrCab.SETRANGE(Importacion , pwImp);
      IF pwNumCab <> 0 THEN BEGIN
        lrCab.SETRANGE("No." , pwNumCab);
      END
      ELSE BEGIN
        lrCab.SETRANGE(Traspasada  , FALSE);
        lrCab.SETRANGE(Errores     , 0);
        lrCab.SETRANGE(Anulada     , FALSE);
      END;

      // No dejamos pasar las modificaciones sin autorizar. Si se ha filtrado por cabecera no filtramos para que salte el error
      IF pwNumCab = 0 THEN
        lrCab.SETRANGE("Modificacion sin autorizar", FALSE);

      IF lrCab.FINDSET THEN BEGIN
        lwText :=STRSUBSTNO(Text0011,pwImp);
        wVentana.OPEN(lwText);
        lwTotal := lrCab.COUNT;
        CLEAR(lwCont);
        REPEAT
          IF lrCab."Modificacion sin autorizar" THEN
            ERROR(Text0048, lrCab.Servicio);

          wVentana.UPDATE(2, lrCab."No.");
          wVentana.UPDATE(3, lrCab.Servicio);
          IF lrCab.Traspasada THEN
            ERROR(Text0040,lrCab."No.");
          IF lrCab.Errores > 0 THEN
            ERROR(Text0041, lrCab."No.");
          IF lrCab.Anulada THEN
            ERROR(Text0042, lrCab."No.");

          // Buscamos el cliente y el touroperador ya que los necesitaremos para las conversiones

          lwCliente := GetConv(2,lrCab.Agencia,'','');
          lwTTOO    := GetConv(3,lrCab.Subagencia,lwCliente,'');

          // Volvemos a buscar si se puede relacionar con un parte

          BuscaParte(lrCab,FALSE);

          // AJS 28.07.2006
          // Incluyo un locktable para permitir que el usuario se quede bloqueado pero en espera
          // y no de un error de ejecucion

          lrParte.LOCKTABLE;

          LimpiaTempsParte(lrParteTMP, lrLinParteTMP, lrVuelosParteTMP, lrSuplParteTMP, lrToParteTMP, lrExtrasTMP);

          CLEAR(lrParteTMP);

          lwModificaParte := (lrCab."No. Parte" <>'') AND lrParte.GET(lrCab."No. Parte");

          IF lwModificaParte THEN BEGIN // Si existe lo limpia, si no lo Crea

            IF lrParte.Confirmado THEN
              ERROR(Text0008, lrParte."N§ Parte");

            LimpiaParteReimportar(lrParte, lwTTOO);

            // Comprobamos si hay l¡neas manuales para respetar el orden que ha modificado el usuario.
            lrLinPar.RESET;
            lrLinPar.SETCURRENTKEY("N§ Parte","N§ Linea");
            lrLinPar.SETRANGE("N§ Parte", lrParte."N§ Parte");
            lwLineasManuales := NOT lrLinPar.ISEMPTY;

            lrParte.FIND; // JPT 11/05/06 Debemos de recuperar el puntero

            lrParteTMP := lrParte;

          END
          ELSE BEGIN
            CLEAR(lrParte);
            rPar.TESTFIELD("Serie Partes");
          END;

          IF NOT lrCab.Cancelacion THEN
          BEGIN // +$001
            lrLin.RESET;
            lrLin.SETRANGE(Importacion  , lrCab.Importacion);
            lrLin.SETRANGE("No Cabecera", lrCab."No.");
            IF lrLin.FINDFIRST THEN BEGIN

              InsertaDatosParte(lrParteTMP, lrCab, lrLin, lwCliente, lwTTOO, lwModificaParte);
              InsertaExtrasParte(lrCab, lrParteTMP, lrExtrasTMP, lwCliente, lwTTOO);
              BuscaServicio(lrParteTMP,lrServicio);

            END;

            // AJF 05/08/08
            //definimos el bucle dependiendo si hay lineas manuales o no.
            lrLin.RESET;
            IF lwLineasManuales THEN
              lrLin.SETCURRENTKEY(Importacion, "No Cabecera", Orden);

            lrLin.SETRANGE(Importacion  , lrCab.Importacion);
            lrLin.SETRANGE("No Cabecera", lrCab."No.");

              // Buscamos el primer numero de linea
            IF lrLin.FINDSET THEN BEGIN
              lrLinPar.RESET;
              lrLinPar.SETRANGE("N§ Servicio" , lrServicio."N§ Servicio");
              IF lrLinPar.FINDLAST THEN
                lwNumLinea := lrLinPar."N§ Linea"
              ELSE
                lwNumLinea := 0;
              lrLinPar.RESET;

              // Ahora introducimos las lineas de los partes
              REPEAT

                lwNumLinea += 1000;

                IF lrLin."N§ Linea" <> 0 THEN BEGIN
                  // Si es una l¡nea manual simplemente hay que recopiarla.
                  ProcesarLineaManual(lrLin, lrLinParteTMP, lwNumLinea);
                END
                ELSE BEGIN

                  // JPT 09/05/08 Buscamos de nuevo el TTOO ya que ahora va por linea (Shuttle)
                  IF lrCab."Servicio shuttle" THEN
                    lwTTOO    := GetConv(3,lrLin.Subagencia,lwCliente,'');

                  InsertaDatosLinea(lrLinParteTMP, lrCab, lrLin, lrParteTMP, lrServicio, lwNumLinea, lwCliente, lwTTOO);

                  // A¤ade los suplementos
                  lwCodSupl := GetConv(4,lrLin."Codigo Suplemento",lwCliente,lwTTOO);
                  IF (lwCodSupl <> '') AND (lrLin."Cantidad Suplemento" <> 0) THEN
                    InsertaSuplLinea(lrLin, lrLinParteTMP, lrSuplParteTMP, lwCodSupl, lwCliente, lwTTOO);
                  InsertaVuelosLinea(lrCab, lrLin, lrLinParteTMP, lrVuelosParteTMP);

                  lrLinParteTMP.INSERT;

                  ActualizaTTOOParte(lrCab, lrParteTMP, lrLinParteTMP, lrToParteTMP, lwCliente, lwTTOO);

                  lrParteTMP."Adultos trans. soporte" += lrLinParteTMP."Adultos transportados";
                  lrParteTMP."Ni¤os trans. soporte"   += lrLinParteTMP."Ni¤os transportados";
                  lrParteTMP."Paxes Previstos"        :=  lrParteTMP."Adultos trans. soporte" + lrParteTMP."Ni¤os trans. soporte";
                END;
              UNTIL lrLin.NEXT=0;

              lrParteTMP.INSERT;

              IF lrCab."Servicio shuttle" THEN
                cGestionParte.CrearParte(lrParteTMP, lrLinParteTMP, cGestionParte.TipoParteImportacionShuttle, lrParte)
              ELSE
                cGestionParte.CrearParte(lrParteTMP, lrLinParteTMP, cGestionParte.TipoParteImportacionTRN, lrParte);

              PasarTempsParte(lrParte, lrVuelosParteTMP, lrSuplParteTMP, lrToParteTMP, lrExtrasTMP);

              // Si se ha modificado un parte se pasa la funci¢n para registrar cambios en las lineas
              IF lwModificaParte THEN
                cFunAdic.MantenCambiosImpresion(lrParte);
              lrParte.MODIFY;

              lrLinPar.actualizar_vuelos(lrLinParteTMP, lrLinParteTMP.Vuelo, lrLinParteTMP."Hora Vuelo", lrParte);
              lrLinPar.ultima_zona_fisica(lrParte,FALSE,FALSE); // Marcamos la zona fisica y de trabajo en el Parte
              //lrLinPar.actualizar_letras(lrLinPar, lrLinPar.Letra);  // Marcamos campo letras en Parte
              lrLinPar.MantenHoraInicio(FALSE); // Marca la hora inicio en Parte

              lrParte.FIND; // JPT 05/05/08 Recuperamos el puntero con los datos a¤adidos
            END;

            // JPT 26/08/04 Si tiene que imprimirse se guardan los numeros de parte primero y £ltimo
            IF pwImprimir THEN BEGIN
              IF lwNPartes[1]='' THEN
                lwNPartes[1] := lrParte."N§ Parte";
              lwNPartes[2] := lrParte."N§ Parte";

              // Buscamos la fecha desde y hasta
              IF (lwFechas[1] > lrParte.Fecha) OR (lwFechas[1]=0D) THEN
                lwFechas[1] := lrParte.Fecha;
              IF lwFechas[2] < lrParte.Fecha THEN
                lwFechas[2] := lrParte.Fecha;
            END;

            // JPT 03/07/06 Ahora TRN NO quieren que se automatice el garaje en la importaci¢n

            // AJS 05.07.2006
            // La automaticacion de garaje debe funcionar para los partes nuevos pero no para las modificaciones

            IF NOT lwModificaParte THEN BEGIN
              // JPT 23/04/08 En todo caso Si NO se ha automatizado hay que comprobar que no este cerrado
              IF cFunParAd.GarajeAutomatico(lrParte) THEN // Automatizamos Garaje
                lrParte.MODIFY
              ELSE
                lrGaraje.ControlCerrado(lrParte.Garaje);
              IF lrServicio.Garaje <> lrParte.Garaje THEN BEGIN // Si ha cambiado lo cambiamos tambien en servicio
                 lrServicio.Garaje := lrParte.Garaje;
                 lrServicio.MODIFY;
              END;
            END;

            // Muevo la busqueda de proveedor hasta despus de que se haga la automatizaci¢n de garaje.
            BuscaProveedor(lrParte);

            // Si se ha modificado un parte se pasa la funci¢n para registrar cambios en las lineas
            IF lwModificaParte THEN
              cFunAdic.MantenCambiosImpresion(lrParte);
            lrParte.MODIFY;

          END ELSE BEGIN    // +$001 Si es cancelaci¢n anulamos el parte
            BorraParte(lrParte."N§ Parte"); // +$001
          END;

          IF NOT lrCab.Cancelacion THEN  // +$001
            lrCab."No. Parte" := lrParte."N§ Parte";
          lrCab.Traspasada  := TRUE;                    // AJF 25/08/08
          lrCab.MODIFY;

          lwCont += 1;
          wVentana.UPDATE(4, ROUND(lwCont / lwTotal * 10000, 1));

          // AJS 05.07.2006
          // Cada 3 partes pongo un commit

          IF (lwCont MOD 3) = 0 THEN
            COMMIT;
        UNTIL lrCab.NEXT = 0;
        wVentana.CLOSE;

        // AJF 25/08/08
        // Muevo la marca de Traspasada al bucle interior, por si la importaci¢n se corta
        // no queden partes marcados sin traspasar a los que ya se haya hecho COMMIT.
        //lrCab.MODIFYALL(Traspasada, TRUE);

      END ELSE
        IF NOT pwAutomatica THEN
          ERROR(Text0039);

      // Comprueba si se ha terminado la importacion para marcarla como transferida

      lrCab.RESET;
      lrCab.SETRANGE(Importacion , pwImp);
      lrCab.SETRANGE(Traspasada  , FALSE);
      lrCab.SETRANGE(Anulada     , FALSE);
      lrCab.SETRANGE("Modificacion sin autorizar", FALSE);
      lwTraspasa := NOT lrCab.FINDFIRST;
      IF lwTraspasa THEN BEGIN
        lrCab.SETRANGE("Modificacion sin autorizar",TRUE);
        IF lrCab.FINDFIRST THEN
          lwTraspasa := CONFIRM(Text0052, FALSE, lrImp."No Importacion");
      END;

      IF lwTraspasa THEN BEGIN
        lrImp.VALIDATE(Transferida         , TRUE);
        lrImp.VALIDATE("Fecha Trasferencia", TODAY);
        lrImp.MODIFY(TRUE);
      END;

      // JPT 26/08/04 Si tiene que imprimirse

      IF pwImprimir THEN BEGIN
        COMMIT;
        lrParte.RESET;
        lrParte.SETRANGE("N§ Parte", lwNPartes[1], lwNPartes[2]);
        // Es necesario filtrar por fechas ya que si no el listado los pone a su bola
        lrParte.SETRANGE(Fecha  , lwFechas[1], lwFechas[2]);
        rPar.TESTFIELD("Informe partes trabajo");
        IF lrInf.GET(rPar."Informe partes trabajo") THEN
          lwIdInforme := lrInf."Id. Informe";
        IF lrParte.FINDFIRST THEN BEGIN
          REPORT.RUNMODAL(lwIdInforme,FALSE,FALSE,lrParte);
        END;
      END;
    END;

    PROCEDURE LimpiaTempsParte@1103355031(VAR prParteTMP@1103355000 : TEMPORARY Record 7010360;VAR prLinParteTMP@1103355005 : TEMPORARY Record 7010359;VAR prVuelosParteTMP@1103355004 : TEMPORARY Record 7035335;VAR prSuplParteTMP@1103355003 : TEMPORARY Record 7010363;VAR prToParteTMP@1103355002 : TEMPORARY Record 7010365;VAR prExtrasTMP@1103355001 : TEMPORARY Record 7010362);
    BEGIN
      // LimpiaTempsParte

      prParteTMP.RESET;
      prParteTMP.DELETEALL;

      prLinParteTMP.RESET;
      prLinParteTMP.DELETEALL;

      prVuelosParteTMP.RESET;
      prVuelosParteTMP.DELETEALL;

      prSuplParteTMP.RESET;
      prSuplParteTMP.DELETEALL;

      prToParteTMP.RESET;
      prToParteTMP.DELETEALL;

      prExtrasTMP.RESET;
      prExtrasTMP.DELETEALL;
    END;

    PROCEDURE A¤adeVuelo2@1103355036(VAR prLinParte@1100244000 : Record 7010359;prVuelo@1103355000 : Record 7035391;VAR prVueloParteTMP@1103355003 : Record 7035335);
    VAR
      lwCodigo@1103355001 : Code[10];
      lwTTOO@1103355002 : Code[10];
    BEGIN
      // A¤adeVuelo
      // a¤ade una linea de Vuelo x Parte, y en la linea de servicios-partes

      // Tratar la informacion de la nueva tabla de vuelos para pasarla a la tabla de vuelos x parte
      IF DELCHR(prVuelo."Num Vuelo", '<>') = '' THEN
        EXIT;

      IF STRPOS(prLinParte.Vuelo, prVuelo."Num Vuelo") = 0 THEN BEGIN
        IF (prLinParte.Vuelo <> '') THEN
          prLinParte.Vuelo := prLinParte.Vuelo + ',';

        IF STRLEN(prVuelo."Num Vuelo") + STRLEN(prLinParte.Vuelo) < MAXSTRLEN(prLinParte.Vuelo) THEN BEGIN
          prLinParte.Vuelo:= prLinParte.Vuelo + prVuelo."Num Vuelo";

          IF prVuelo.Hora <> 0T THEN
            IF (prVuelo.Hora < prLinParte."Hora Vuelo") OR (prLinParte."Hora Vuelo" = 0T) THEN
              prLinParte."Hora Vuelo":= prVuelo.Hora;

          IF (prVuelo.IATA <> '') AND (prLinParte.IATA = '') THEN
            prLinParte.IATA := prVuelo.IATA;

          prLinParte.formatea_lista_vuelos(prLinParte.Vuelo, prLinParte."Hora Vuelo", prLinParte.Fecha);
        END;
      END;

      prVueloParteTMP.RESET;

      // Si la l¡nea es de parte shuttle generamos un codigo especial y dejamos el TTOO en blanco.
      // Solo los vuelos de entrada se registran para shuttle.

      lwCodigo := prLinParte.GetCodigoVuelosParte;
      lwTTOO := '';
      IF (STRPOS(lwCodigo, Text50060) = 0) THEN BEGIN
        lwTTOO := prLinParte.Touroperador;
      END;

      IF ((lwTTOO = '') AND (prVuelo."Entrada/Salida" = prVuelo."Entrada/Salida"::Entrada)) OR (lwTTOO <> '') THEN BEGIN
        IF NOT prVueloParteTMP.GET(lwCodigo, prVuelo."Num Vuelo", lwTTOO) THEN BEGIN
          prVueloParteTMP.INIT;
          prVueloParteTMP."N§Parte"         := lwCodigo;
          prVueloParteTMP."Referencia Vuelo":= prVuelo."Num Vuelo";
          prVueloParteTMP.Hora              := prVuelo.Hora;

          prVueloParteTMP."E/S" := prVuelo."Entrada/Salida" + 1;

          prVueloParteTMP."Codigo Touroperador":= lwTTOO;

          IF prVuelo.Fecha <> 0D THEN
            prVueloParteTMP."Fecha Traslado":= prVuelo.Fecha
          ELSE
            prVueloParteTMP."Fecha Traslado":= prLinParte.Fecha;

          IF prVuelo."Fecha llegada vuelo" <> 0D THEN
            prVueloParteTMP."Fecha Llegada Vuelo":= prVuelo."Fecha llegada vuelo"
          ELSE
            prVueloParteTMP."Fecha Llegada Vuelo":= prLinParte.Fecha;

          // JPT 02/02/10 Datetime a Biginteger. Validamos para asignar el campo BI
          // prVueloParteTMP."FechaHora Vuelo"      := CREATEDATETIME (prVueloParteTMP."Fecha Llegada Vuelo", prVueloParteTMP.Hora);
          prVueloParteTMP.VALIDATE("FechaHora Vuelo" , CREATEDATETIME (prVueloParteTMP."Fecha Llegada Vuelo", prVueloParteTMP.Hora));

          IF prVuelo.IATA <> '' THEN
            prVueloParteTMP.IATA:= prVuelo.IATA
          ELSE
            prVueloParteTMP.IATA:= prLinParte.IATA;

          prVueloParteTMP.INSERT;
        END;
      END;
    END;

    PROCEDURE PasarTempsParte@1103355038(VAR prParte@1103355004 : Record 7010360;VAR prVuelosParteTMP@1103355003 : TEMPORARY Record 7035335;VAR prSuplParteTMP@1103355002 : TEMPORARY Record 7010363;VAR prToParteTMP@1103355001 : TEMPORARY Record 7010365;VAR prExtrasTMP@1103355000 : TEMPORARY Record 7010362);
    VAR
      lrExtra@1103355005 : Record 7010362;
      lwNumExtr@1103355006 : Integer;
      lrSuplParte@1103355007 : Record 7010363;
      lrVueloParte@1103355008 : Record 7035335;
      lrToParte@1103355009 : Record 7010365;
    BEGIN
      // PasarTempsParte

      prExtrasTMP.RESET;
      IF prExtrasTMP.FINDSET THEN BEGIN

        lwNumExtr := 0;

        REPEAT

          lwNumExtr += 1000;

          lrExtra.INIT;
          lrExtra."N§ Parte":= prParte."N§ Parte";
          lrExtra.VALIDATE(Extra, prExtrasTMP.Extra);
          lrExtra.Touroperador := prExtrasTMP.Touroperador;
          lrExtra."N§ Extra" := lwNumExtr;
          lrExtra.INSERT;  // No se valida

        UNTIL prExtrasTMP.NEXT = 0;
      END;

      prSuplParteTMP.RESET;
      IF prSuplParteTMP.FINDSET THEN BEGIN
        REPEAT

          lrSuplParte := prSuplParteTMP;
          lrSuplParte.INSERT;

        UNTIL prSuplParteTMP.NEXT = 0;
      END;

      prVuelosParteTMP.RESET;
      IF prVuelosParteTMP.FINDSET THEN BEGIN
        REPEAT

          IF NOT lrVueloParte.GET(prVuelosParteTMP."N§Parte",
                                  prVuelosParteTMP."Referencia Vuelo",
                                  prVuelosParteTMP."Codigo Touroperador") THEN BEGIN

            lrVueloParte := prVuelosParteTMP;
            lrVueloParte.INSERT;
          END;

        UNTIL prVuelosParteTMP.NEXT = 0;
      END;

      prToParteTMP.RESET;
      IF prToParteTMP.FINDSET THEN BEGIN
        REPEAT

          lrToParte.INIT;
          lrToParte."N§ Parte" := prParte."N§ Parte";
          lrToParte."Cliente operativo"      := prToParteTMP."Cliente operativo";
          lrToParte."Cliente estadistico"    := prToParteTMP."Cliente estadistico";
          lrToParte.VALIDATE(Touroperador, prToParteTMP.Touroperador);
          lrToParte.INSERT(TRUE);

          // AJF 20/08/08
          // Incluyo el Garaje ya que hay casos en que en la l¡nea de touroperador x parte el garaje se
          // puede quedar en blanco.
          lrToParte.Garaje                     := prToParteTMP.Garaje;

          lrToParte.Bono                       := prToParteTMP.Bono;
          lrToParte."Fecha Servicio Parte"     := prToParteTMP."Fecha Servicio Parte";
          lrToParte."Fecha Facturacion"        := prToParteTMP."Fecha Facturacion";
          lrToParte.Facturable                 := prToParteTMP.Facturable;
          lrToParte."Ingreso Precios Por"      := prToParteTMP."Ingreso Precios Por";
          lrToParte."Coste Precios Por"        := prToParteTMP."Coste Precios Por";
          lrToParte.Gestor                     := prToParteTMP.Gestor;
          lrToParte.Vehiculo                   := prToParteTMP.Vehiculo;
          lrToParte."Tipo Vehiculo"            := prToParteTMP."Tipo Vehiculo";
          lrToParte."Codigo Servicio"          := prToParteTMP."Codigo Servicio";
          lrToParte."Tipo Servicio"            := prToParteTMP."Tipo Servicio";
          lrToParte."Adultos transportados"    := prToParteTMP."Adultos transportados";
          lrToParte."Ni¤os transportados"      := prToParteTMP."Ni¤os transportados";
          lrToParte."Adultos invitados ingreso":= prToParteTMP."Adultos invitados ingreso";
          lrToParte."Ni¤os invitados ingreso"  := prToParteTMP."Ni¤os invitados ingreso";
          lrToParte."Adultos invitados coste"  := prToParteTMP."Adultos invitados coste";
          lrToParte."Ni¤os invitados coste"    := prToParteTMP."Ni¤os invitados coste";
          lrToParte."Pax Transportados"        := prToParteTMP."Pax Transportados";
          lrToParte.MODIFY;

        UNTIL prToParteTMP.NEXT = 0;
      END;
    END;

    PROCEDURE ImportaCSV@1000000000(pwNombreArchivo@1100244000 : Text[150]);
    VAR
      ldImp@1000000000 : Dataport 7010402;
      lrImp@1000000001 : Record 7035333;
    BEGIN
      // ImportaCSV
      // Importaci¢n de servicios de Sidetours
      // $001 INV-OC-14042

      IF NOT EXISTS(pwNombreArchivo) THEN
        ERROR(Text0001, pwNombreArchivo);

      //  Se crea Historico Importacion
      lrImp.INIT;
      lrImp.Archivo := Extractfilename(pwNombreArchivo);
      lrImp.Tipo    := lrImp.Tipo::Reserva;
      lrImp.INSERT(TRUE);

      CLEAR(ldImp);
      ldImp.SetParametros(pwNombreArchivo, lrImp."No Importacion");
      ldImp.RUNMODAL;

      MueveArchivo(lrImp."No Importacion", pwNombreArchivo);
    END;

    BEGIN
    {
      AJS 09.02.2005

      En la rutina "ImportaArchivoSurtidor2" si el codigo de conductor que viene en el fichero no existe en FinBus dejar
      el campo "Conductor" en blanco.

      ## AJS 29.06.2009

        .- En la funcion ImportaArchivoXML1 he incluido la lectura del nodo ZonaFisica

      JPT 02/02/10 Datetime a Biginteger

      $001 ARM 14112014 INV-OC-14042 Importaci¢n servicios desde csv

      $002 AJS 07052015 La hora de recogida de las lineas solo la queremos en las salidas

      $003 AJS 07052015 Cambio para que deje de crear un servicio por cada referencia

      $004 AJS 29052015 Eliminar espacios innecesarios en las observaciones

      $005 AJS 18062015 Modifico la funcion BuscaServicio para que no cree un servicio por Touroperador en los shuttle
    }
    END.
  }
}
