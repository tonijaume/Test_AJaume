OBJECT Codeunit 7010407 Calculo Partes
{
  OBJECT-PROPERTIES
  {
    Date=27/11/14;
    Time=17:39:43;
    Modified=Yes;
    Version List=TRANSFER;
  }
  PROPERTIES
  {
    SingleInstance=Yes;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      rPar@1100253001 : Record 7010311;
      rtmTOPar@1100253000 : TEMPORARY Record 7010365;
      rtmSerPar@1100253002 : TEMPORARY Record 7010359;
      Text000@1100253065 : TextConst 'ESP=VEHICULO';
      Text001@1100253006 : TextConst 'ESP=CARGANDO TEMPORALES';
      rtmZonPre@1100253005 : TEMPORARY Record 7010364;
      Text002@1100253050 : TextConst 'ESP=No se pueden calcular los partes confirmados.';
      Text003@1100253049 : TextConst 'ESP=Se ha dejado el conductor en blanco.';
      Text004@1100253048 : TextConst 'ESP=Se ha dejado el vehiculo en blanco.';
      Text005@1100253004 : TextConst 'ESP=Si "Tipo Calculo Ingresos" es "Mayor Precio", "Precio por" debe ser "Zona m s alejada"';
      Text006@1100253003 : TextConst 'ESP=Si "Tipo Calculo Ingresos" es "Mayor Precio", "Busca precio ingreso" debe ser "Pasaje Conjunto"';
      Text007@1100253047 : TextConst 'ESP=En los traslados no se puede dejar el Punto de Origen/Destino en blanco.';
      Text008@1100253009 : TextConst 'ESP=Calculando Touroperador Asociado';
      Text009@1100253045 : TextConst 'ESP=No se ha indicado proveedor en el parte de trabajo.';
      Text010@1100253044 : TextConst 'ESP=No existe el proveedor indicado en el parte de trabajo.';
      Text011@1100253043 : TextConst 'ESP=No existe el contrato %1 para el garaje %2.''';
      Text012@1100253042 : TextConst 'ESP=No existe el IVA %1-%2.';
      Text013@1100253041 : TextConst 'ESP=No se indicado cliente en el parte de trabajo.';
      Text014@1100253040 : TextConst 'ESP=No existe el cliente indicado en el parte de trabajo.';
      Text015@1100253039 : TextConst 'ESP=No existe el contrato %1 para el garaje %2.''';
      Text016@1100253038 : TextConst 'ESP=No se ha indicado touroperador en la linea del parte.';
      Text017@1100253037 : TextConst 'ESP=No existe el touroperador %1.';
      Text018@1100253036 : TextConst 'ESP=No existe la composicion %1-%2.';
      Text019@1100253035 : TextConst 'ESP=No existe el cliente de facturacion %1.';
      Text020@1100253034 : TextConst 'ESP=No se ha encontrado contrato para el cliente %1 Touroperador %2 para el dia %3.';
      Text021@1100253029 : TextConst 'ESP=No se ha encontrado precio en contrato venta %1 para %2 en la zona %3 para la fecha %4 para %5 %6.';
      Text022@1100253028 : TextConst 'ESP=No se ha encontrado precio en contrato venta %1 para %2 para la ruta %3-%4 para la fecha %5 para %6 %7.';
      Text023@1100253027 : TextConst 'ESP=No se ha indicado touroperador en el extra %1.';
      Text024@1100253025 : TextConst 'ESP=No se ha rellenado el campo Grupo Registro IVA Producto en el fichero de Parametros.';
      Text025@1100253023 : TextConst 'ESP=La zona fisica %1 no esta en ninguna zona de precios del contrato de compra %2.';
      Text026@1100253022 : TextConst 'ESP=La zona fisica %1 no esta en ninguna zona de precios del contrato de venta %2.';
      Text027@1100253021 : TextConst 'ESP=No se ha encontrado precio en contrato compra %1 para %2 en la zona %3 para la fecha %4 para %5 personas.';
      Text028@1100253020 : TextConst 'ESP=No se ha encontrado precio en contrato compra %1 para %2 para la ruta %3-%4 para la fecha %5 para %6 personas.';
      Text029@1100253017 : TextConst 'ESP=No se ha encontrado precio en contrato compra %1 para %2 en la zona %3 para la fecha %4 para %5 %6.';
      Text030@1100253016 : TextConst 'ESP=No se ha encontrado precio en contrato compra %1 para %2 para la ruta %3-%4 para la fecha %5 para %6 %7.';
      Text031@1100253015 : TextConst 'ESP=No se ha rellenado el campo Codigo Maletas en el fichero de Parametros.';
      Text032@1100253013 : TextConst 'ESP=No se ha rellenado el campo Grupo Registro IVA Maletas en el fichero de Parametros.';
      Text033@1100253008 : TextConst 'ESP=No se ha rellenado el campo Codigo entradas en el fichero de Parametros.';
      Text034@1100253007 : TextConst 'ESP=No se ha rellenado el campo Codigo salidas en el fichero de Parametros.';
      Text035@1100253051 : TextConst 'ESP=El proceso de calculo del parte %1 ha producido errores, tiene que corregirlos antes de realizar el calculo.';
      rtmExtra@1100253060 : TEMPORARY Record 7010362;
      rtmElePto@1100253061 : TEMPORARY Record 7010363;
      rtmConV@1100253053 : TEMPORARY Record 7010403;
      rtmPrecV@1100253054 : TEMPORARY Record 7010405;
      rtmZonaC@1100253055 : TEMPORARY Record 7010404;
      rtmMinC@1100253056 : TEMPORARY Record 7010407;
      rtmConC@1100253063 : TEMPORARY Record 7010408;
      rtmPrecC@1100253064 : TEMPORARY Record 7010409;
      rtmMar@1100253059 : ARRAY [5] OF TEMPORARY Record 7010412;
      rtmProdIng@1103355000 : ARRAY [5] OF TEMPORARY Record 7035392;
      rtmProdCoste@1103355001 : ARRAY [5] OF TEMPORARY Record 7035393;
      cCalcIng@1100253062 : Codeunit 7010408;
      cCalcCos@1100253068 : Codeunit 7010409;
      cCalcCosTRN@1103355003 : Codeunit 7010411;
      wVentana@1100253052 : Dialog;
      rErr@1100253057 : Record 7010413;
      wPrecisionIngreso@1100253066 : Decimal;
      wPrecisionCoste@1100253067 : Decimal;
      Text036@1100253069 : TextConst 'ESP=Comprobando errores';
      Text037@1100253070 : TextConst 'ESP=CALCULANDO EL PARTE';
      wNLCont@1100253072 : Integer;
      Text038@1103355002 : TextConst 'ESP="El cliente %1 touroperador %2 no tiene condiciones de facturacion para el tipo de servicio %3 "';
      Text039@1103355004 : TextConst 'ESP=El punto de recogida %1 no esta en ninguna zona de precios del contrato de compra %2.';
      wCosteTTOOSeparados@1103355005 : Boolean;
      Text040@1103355006 : TextConst 'ESP=Se ha dejado el conductor en blanco en el Parte de Recogida';
      Text041@1103355007 : TextConst 'ESP=Se ha dejado el vehiculo en blanco en el Parte de Recogida.';

    PROCEDURE CalculoParte@1100253001(VAR prParte@1100253004 : Record 7010360;pw_muestra@1100253003 : Boolean;pwCalculaCoste@1100253002 : Boolean;pwCalculaIngreso@1100253001 : Boolean;pwEsRecalculo@1100253000 : Boolean;pwPrimero@1100253007 : Boolean);
    VAR
      lrZonFis@1100253005 : Record 7010314;
      lrToPar@1100253008 : Record 7010365;
      lwError@1100253006 : Boolean;
      fTabMar@1100253009 : Form 7010495;
    BEGIN
      // CalculoParte

      // pwPrimero Indica si es el primero de una serie: Los contratos se cargan a temporal seg£n se necesitan, y no se borran del temp
      // a no ser que se indique en el booleano pwPrimero

      rPar.FINDFIRST;

      wCosteTTOOSeparados := FALSE;

      wVentana.OPEN(Text037 + '#1##########\#2##############################', prParte."N§ Parte");

      // JPT 08/04/08 Si falta alg£n TTOOxParte lo creamos
      RepasaTTOOs(prParte);
      // AJF 06/08/08 Repaso lo parametros de coste en TTOOxParte
      RepasaParametrosCoste(prParte);

      // Creamos los temporales de parte
      BorraTemps(pwPrimero);
      CreaTemporalesParte(prParte);

      // Vuelve a calcular los paxes en touroperador x parte para asegurar que no exista ning£n error
      RecalculaPaxes(prParte);

      // Comprobaciones de error previas al calculo. Antes de cargar temporales
      lwError := CompruebaErrores(prParte, pwEsRecalculo);
      IF lwError THEN BEGIN
        wVentana.CLOSE;
        MESSAGE(Text035, prParte."N§ Parte");
        EXIT;
      END;

      // Si la cuenta de touroperadores es 1 hay que indicar que el calculo es de pasaje conjunto
      IF rtmTOPar.COUNT = 1 THEN
        prParte."Busca precio ingreso" := prParte."Busca precio ingreso"::"Pasaje conjunto";

      prParte.FIND;

      IF (prParte."Tipo Calculo Ingresos" = prParte."Tipo Calculo Ingresos"::"Mayor Importe") AND
         (prParte."Ingreso Precios por" <> prParte."Ingreso Precios por"::"Zona mas alejada") THEN
         ERROR(Text005);

      IF (prParte."Tipo Calculo Ingresos" = prParte."Tipo Calculo Ingresos"::"Mayor Importe") AND
         (prParte."Busca precio ingreso"  <> prParte."Busca precio ingreso"::"Pasaje conjunto") THEN
         ERROR(Text006);

      // Asegurar que los campos que luego empleemos para campos calculados conserven el valor real

      prParte.CALCFIELDS("Adultos transportados", "Ni¤os transportados");
      prParte."Adultos trans. soporte" := prParte."Adultos transportados";
      prParte."Ni¤os trans. soporte"   := prParte."Ni¤os transportados";

      // Prevenir que se pueda confirmar un parte de trabajo sin Zona de trabajo

      IF prParte."Zona trabajo" = '' THEN BEGIN
        IF prParte."Zona parte" = '' THEN BEGIN
          rtmSerPar.RESET;
          IF rtmSerPar.FINDFIRST THEN
            prParte."Zona parte" := rtmSerPar."Zona fisica";
        END;

        prParte."Zona trabajo" := lrZonFis.GetZonaTrabajo(prParte."Zona parte",
                                                          prParte."Touroperador principal",
                                                          prParte."Tipo Servicio");
      END;
      prParte.MODIFY;

      // Eliminar los registros temporales creados por calculos anteriores

      EliminaRegistros(prParte, pwCalculaCoste, pwCalculaIngreso);

      IF pwCalculaIngreso THEN
        cCalcIng.LanzaCalculoIngresos(prParte,rtmTOPar,rtmSerPar,rtmZonPre,rtmExtra,rtmElePto, wVentana);

      // AJS 04.04.2006
      // Temporalmente Transunion no quiere lanzar el calculo de costes aunque tenga el proveedor rellenado

      IF pwCalculaCoste THEN
        // AJF 30/04/08 ** Costes
        // Llamo a la CU de TRANSUNION para TRN.
        IF (rPar."Empresa Real" <> rPar."Empresa Real"::TRN) AND
           (rPar."Empresa Real" <> rPar."Empresa Real"::CNT) THEN
          cCalcCos.LanzaCalculoCostes(prParte,rtmTOPar,rtmSerPar,rtmZonPre,rtmExtra,rtmElePto, wVentana)
        ELSE
          cCalcCosTRN.LanzaCalculoCostes(prParte,rtmTOPar,rtmSerPar,rtmZonPre,rtmExtra,rtmElePto, wVentana);

      // Para TRN cliente Universal

      CalculoTTOOAsociado(prParte);

      // Devuelve los temporales a valores reales

      DevuelveAReal(prParte);
      prParte.ProratearViajes; // AJF 03/11/10

      wVentana.CLOSE;

      // Visualizar los resultados del calculo

      IF pw_muestra THEN BEGIN
        COMMIT;
        lrToPar.RESET;
        lrToPar.SETRANGE("N§ Parte", prParte."N§ Parte");
        CLEAR(fTabMar);
        fTabMar.SETTABLEVIEW(lrToPar);
        fTabMar.pasa_parte(prParte."N§ Parte");
        // JPT 13/01/06 Cambio el Runmodal por Run: Resulta que si dentro de la ventana de calculo de margenes
        // volvemos a recalcular o confirmar, si dejamos el RUNMODAL el sistema saca de golpe a Finbus al salir de dicha ventana
        //fTabMar.RUNMODAL;
        fTabMar.RUN;
      END;
    END;

    PROCEDURE BorraTemps@1100253003(pwBorraContratos@1100253000 : Boolean);
    BEGIN
      // BorraTemps
      // Se asegura de eliminar los registro de las tablas temporales
      // pwBorraContratos Indica si queremos borrar tambin los contratos. Es util ya cuando se lanza la funci¢n de calculo
      // basta con que se borren en la primera reserva. As¡ los contratos se guardan y la funci¢n es m s rapida.

      CLEAR(rtmTOPar);     // Touroperador x parte
      rtmTOPar.DELETEALL;

      CLEAR(rtmSerPar); // Servicios Parte
      rtmSerPar.DELETEALL;

      CLEAR(rtmZonPre);  // Zonas Precio Parte
      rtmZonPre.DELETEALL;

      CLEAR(rtmExtra); // Extras Parte
      rtmExtra.DELETEALL;

      CLEAR(rtmElePto); // Elementos x punto
      rtmElePto.DELETEALL;

      CLEAR(rtmMar);    // Margenes
      rtmMar[1].DELETEALL;

      // AJS 08.09.2006
      // Cambiamos para trabajar sobre las nuevas tablas de produccion en lugar de la tabla de coste-ingreso

      //CLEAR(rtmCI);     // Coste-Ingreso
      //rtmCI[1].DELETEALL;

      CLEAR(rtmProdIng);  // Produccion de ingreso
      rtmProdIng[1].DELETEALL;

      CLEAR(rtmProdCoste);  // Produccion de coste
      rtmProdCoste[1].DELETEALL;

      IF pwBorraContratos THEN BEGIN
        // CONTRATO VENTA
        CLEAR(rtmConV); // Contrato Venta
        rtmConV.DELETEALL;

        CLEAR(rtmPrecV);    // Precios contrato venta
        rtmPrecV.DELETEALL;

        CLEAR(rtmZonaC);
        rtmZonaC.DELETEALL; // Zonas de precio contrato (compra y venta)

        CLEAR(rtmMinC);
        rtmMinC.DELETEALL; // Minimos por contrato (compra y venta)

        // CONTRATO COMPRA

        CLEAR(rtmConC); // Contrato Compra
        rtmConC.DELETEALL;

        CLEAR(rtmPrecC);    // Precios contrato Compra
        rtmPrecC.DELETEALL;

      END;
    END;

    PROCEDURE CreaTemporalesParte@1100253005(prParte@1100253001 : Record 7010360);
    VAR
      lrTTOOParte@1100253000 : Record 7010365;
      lrSerPar@1100253002 : Record 7010359;
      lrZonPre@1100253003 : Record 7010364;
      lrExtra@1100253004 : Record 7010362;
      lrElePto@1100253006 : Record 7010363;
    BEGIN
      // CreaTemporalesParte
      // Esta Funci¢n es la encargada de crear los registros temporales referentes al parte

      wVentana.UPDATE(2, Text001);

      BorraTemps(FALSE);

      // Touroperador x parte

      CLEAR(lrTTOOParte);
      lrTTOOParte.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF lrTTOOParte.FINDSET THEN BEGIN
        REPEAT
          rtmTOPar := lrTTOOParte;
          rtmTOPar.INSERT;
        UNTIL lrTTOOParte.NEXT = 0;
      END;

      // Servicios Parte

      CLEAR(lrSerPar);
      lrSerPar.SETCURRENTKEY("N§ Parte","N§ Linea");
      lrSerPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF lrSerPar.FINDSET THEN BEGIN
        REPEAT
          rtmSerPar := lrSerPar;
          rtmSerPar.INSERT;
        UNTIL lrSerPar.NEXT = 0;
      END;

      // Zonas Precio Parte

      CLEAR(rtmZonPre);
      lrZonPre.SETRANGE("N§ Parte", prParte."N§ Parte");
      // Solo vamos a insertar las lineas que estn marcados como Modificadas Manualmente
      lrZonPre.SETRANGE("Pasaje modificado manual", TRUE);
      IF lrZonPre.FINDSET THEN BEGIN
        REPEAT
          rtmZonPre := lrZonPre;
          rtmZonPre."Adultos Transportados zona":= 0;
          rtmZonPre."Ni¤os Transportados zona"  := 0;
          rtmZonPre.INSERT;
        UNTIL lrZonPre.NEXT = 0;
      END;

      lrZonPre.SETRANGE("Pasaje modificado manual", FALSE);
      lrZonPre.SETRANGE("Orden modificado manual" , TRUE);
      IF lrZonPre.FINDSET THEN BEGIN
        REPEAT
          rtmZonPre := lrZonPre;
          rtmZonPre."Adultos Transportados zona":= 0;
          rtmZonPre."Ni¤os Transportados zona"  := 0;
          rtmZonPre."Adultos facturados zona"   := 0;
          rtmZonPre."Ni¤os facturados zona"     := 0;
          rtmZonPre."Adultos Invitados Zona"    := 0;
          rtmZonPre."Ni¤os Invitados Zona"      := 0;
          rtmZonPre.INSERT;
        UNTIL lrZonPre.NEXT = 0;
      END;

      // Extras Parte

      CLEAR(rtmExtra);
      CLEAR(lrExtra);
      lrExtra.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF lrExtra.FINDSET THEN BEGIN
        REPEAT
          rtmExtra := lrExtra;
          rtmExtra.INSERT;
        UNTIL lrExtra.NEXT = 0;
      END;

      // Elementos x punto

      CLEAR(rtmElePto);
      CLEAR(lrElePto);
      lrElePto.SETCURRENTKEY("N§ Parte","N§ Linea");
      lrElePto.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF lrElePto.FINDSET THEN BEGIN
        REPEAT
          rtmElePto := lrElePto;
          rtmElePto.INSERT;
        UNTIL lrElePto.NEXT = 0;
      END;

      // Los contratos se buscan a medida que se necesitan
    END;

    PROCEDURE RecalculaPaxes@57(VAR prParte@1100244000 : Record 7010360);
    VAR
      lrVeh@1103350000 : Record 7010346;
      lrTTOOxParte2@1100244006 : Record 7010365;
      lwAdultos@1100244003 : ARRAY [3] OF Decimal;
      lwNi¤os@1100244004 : ARRAY [3] OF Decimal;
      lwTouroperadores@1100253000 : Text[90];
    BEGIN
      // RecalculaPaxes
      // Volvemos a calcular  los paxes en Touroperador x parte a partir de las l¡neas
      // Servicios-Partes para asegurarnos de que no existe ning£n error
      // Las variables lwAdultos y lwNi¤os tienes tres dimensiones: 1:Trasportados
      // 2: invitados ingreso y 3: invitados coste
      // Insertamos el campo Touroperadores en Parte

      // AJS 11.06.2008
      // La variable lwTouroperadores se ha ampliado a 90 caracteres

      CLEAR(lwTouroperadores);
      rtmTOPar.RESET;
      rtmTOPar.SETRANGE("N§ Parte",prParte."N§ Parte");

      rtmSerPar.RESET;

      // Realizamos el recorrido inverso para evitar problemas al eliminar registros
      IF rtmTOPar.FINDLAST THEN BEGIN
        REPEAT
          rtmSerPar.SETRANGE(Touroperador , rtmTOPar.Touroperador);
          CLEAR(lwAdultos);
          CLEAR(lwNi¤os);
          IF rtmSerPar.FINDSET THEN
            REPEAT
              lwAdultos[1] += rtmSerPar."Adultos transportados";
              lwAdultos[2] += rtmSerPar."Adultos invitados ingreso";
              lwAdultos[3] += rtmSerPar."Adultos invitados coste";

              lwNi¤os[1]   += rtmSerPar."Ni¤os transportados";
              lwNi¤os[2]   += rtmSerPar."Ni¤os invitados ingreso";
              lwNi¤os[3]   += rtmSerPar."Ni¤os invitados coste";
            UNTIL rtmSerPar.NEXT = 0;

          rtmTOPar.VALIDATE("Adultos transportados"      , lwAdultos[1]);
          rtmTOPar.VALIDATE("Adultos invitados ingreso"  , lwAdultos[2]);
          rtmTOPar.VALIDATE("Adultos invitados coste"    , lwAdultos[3]);

          rtmTOPar.VALIDATE("Ni¤os transportados"        , lwNi¤os[1]);
          rtmTOPar.VALIDATE("Ni¤os invitados ingreso"    , lwNi¤os[2]);
          rtmTOPar.VALIDATE("Ni¤os invitados coste"      , lwNi¤os[3]);

          // Actualizar tambien este campo que acumula adultos y ni¤os

          rtmTOPar.VALIDATE("Pax Transportados"          , lwAdultos[1] + lwNi¤os[1]);

          rtmTOPar."Adultos facturados" := 0;
          rtmTOPar."Ni¤os facturados"   := 0;

          // Si la referencia esta rellenada se pondra en el campo Bono, si este esta en blanco

          IF prParte.Referencia <> '' THEN BEGIN
            IF rtmTOPar.Bono = '' THEN
              rtmTOPar.Bono := COPYSTR(prParte.Referencia, 1, 10);
          END;

          // Modificado por la migracion de IBZ

          IF lrVeh.GET(prParte.Vehiculo) THEN BEGIN
            IF NOT lrVeh."Vehiculo propio" THEN
              rtmTOPar."Servicio arrendado" := TRUE;
          END;

          rtmTOPar.Vehiculo := prParte.Vehiculo;
          rtmTOPar.MODIFY;

          IF (rtmTOPar."Adultos transportados" + rtmTOPar."Ni¤os transportados" ) = 0 THEN BEGIN
            // Borramos tanto el temporal como el real
            lrTTOOxParte2 := rtmTOPar;
            lrTTOOxParte2.DELETE;
            rtmTOPar.DELETE;
          END
          ELSE BEGIN
            IF lwTouroperadores <> '' THEN
              lwTouroperadores := lwTouroperadores + '|';
            lwTouroperadores := lwTouroperadores + rtmTOPar.Touroperador;
          END;
        UNTIL rtmTOPar.NEXT(-1) = 0;
      END;

      // Aprovechamos el recorrido para volver a indicar el campo Touroperadores en Parte

      prParte.VALIDATE(Touroperadores , lwTouroperadores);

      // AJS 19.06.2008
      // Incluyo el MODIFY para que no se pierda el campo Touroperadores

      prParte.MODIFY;
    END;

    PROCEDURE EliminaRegistros@3(prParte@1100244000 : Record 7010360;pwCoste@1103350000 : Boolean;pwIngreso@1103350001 : Boolean);
    VAR
      lrZonPre@1100244001 : Record 7010364;
      lrMar@1100244003 : Record 7010412;
      lrProdIng@1100244004 : Record 7035392;
      lrProdCoste@1103355000 : Record 7035393;
    BEGIN
      // EliminaRegistros
      //
      //  Elimina los archivos temporales del calculo tales como los mensajes de error los margenes y las zonas de precios.

      CLEAR(rErr);
      rErr.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF rErr.FINDSET THEN
        rErr.DELETEALL;

      // El proceso anterior de copiar a temporal ya se ha encargado de guardar las lineas manuales

      CLEAR(lrZonPre);
      lrZonPre.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF lrZonPre.FINDSET THEN
        lrZonPre.DELETEALL;

      // Solo eliminaremos aquellas lineas que no esten facturadas y no
      // sean de abono para los casos en que se ha retrocedido el parte de trabajo

      IF prParte."Tipo Calculo" = prParte."Tipo Calculo"::Confirmacion  THEN BEGIN

        // AJS 08.09.2006
        // Borramos las lineas de produccion que no sean de abono

        //CLEAR(lrCI);
        //lrCI.SETCURRENTKEY("N§ Parte",Concepto);
        //lrCI.SETRANGE("N§ Parte"   , prParte."N§ Parte");
        //lrCI.SETRANGE("N§ Factura" , '');
        //lrCI.SETRANGE("Linea abono", FALSE);
        //IF pwCoste THEN BEGIN
        //  lrCI.SETRANGE(Concepto, lrCI.Concepto::Coste);
        //  IF lrCI.FINDFIRST THEN
        //    lrCI.DELETEALL;
        //END;

        //IF pwIngreso THEN BEGIN
        //  lrCI.SETRANGE(Concepto, lrCI.Concepto::Ingreso);
        //  IF lrCI.FINDFIRST THEN
        //    lrCI.DELETEALL;
        //END;

        // Produccion de ingresos

        // AJS 19.06.2008
        // Las lineas de produccion de ingreso solo se borran si estamos calculando ingresos

        IF pwIngreso THEN BEGIN
          lrProdIng.RESET;
          lrProdIng.SETCURRENTKEY("Linea abono");
          lrProdIng.SETRANGE("N§ Parte"   , prParte."N§ Parte");
          lrProdIng.SETRANGE("Linea abono", FALSE);
          IF lrProdIng.FINDSET THEN
            lrProdIng.DELETEALL;
        END;

        // Produccion de costes

        // AJS 19.06.2008
        // Las lineas de produccion de coste solo se borran si estamos calculando costes

        IF pwCoste THEN BEGIN
          lrProdCoste.RESET;
          lrProdCoste.SETCURRENTKEY("Linea abono");
          lrProdCoste.SETRANGE("N§ Parte"   , prParte."N§ Parte");
          lrProdCoste.SETRANGE("Linea abono", FALSE);
          IF lrProdCoste.FINDSET THEN
            lrProdCoste.DELETEALL;
        END;
      END;

      CLEAR(lrMar);
      IF prParte."Tipo Calculo" = prParte."Tipo Calculo"::Margen THEN
        lrMar.SETRANGE(Usuario, USERID);

      lrMar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF lrMar.FINDSET THEN
        lrMar.DELETEALL;
    END;

    PROCEDURE DevuelveAReal@1100253016(prParte@1100253000 : Record 7010360);
    VAR
      lrToPar@1100253001 : Record 7010365;
      lrZonPre@1100253002 : Record 7010364;
      lrMargen@1100253003 : Record 7010412;
      lrProdIng@1103355000 : Record 7035392;
      lrProdIng2@1103355002 : Record 7035392;
      lrProdCoste@1103355003 : Record 7035393;
      lrProdCoste2@1103355004 : Record 7035393;
      lwNoLin@1103355001 : Integer;
    BEGIN
      // DevuelveAReal
      // Devuelve los datos contenidos en temporales a las variable reales

      // Touroperador x Parte
      CLEAR(rtmTOPar);
      CLEAR(lrToPar);

      // AJS 26.07.2006
      // Bloqueamos las tablas explicitamente para evitar problemas de bloqueo

      lrToPar.LOCKTABLE;

      rtmTOPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF rtmTOPar.FINDSET THEN BEGIN
        REPEAT
          lrToPar := rtmTOPar;
          lrToPar.MODIFY;
        UNTIL rtmTOPar.NEXT=0;
      END;

      // Zona Precio Parte

      CLEAR(rtmZonPre);
      CLEAR(lrZonPre);

      // AJS 26.07.2006
      // Bloqueamos las tablas explicitamente para evitar problemas de bloqueo

      lrZonPre.LOCKTABLE;

      rtmZonPre.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF rtmZonPre.FINDSET THEN BEGIN
        REPEAT
          lrZonPre := rtmZonPre;
          IF lrZonPre.FIND THEN BEGIN
            lrZonPre := rtmZonPre;
            lrZonPre.MODIFY;
          END
          ELSE
            lrZonPre.INSERT;
        UNTIL rtmZonPre.NEXT=0;
      END;

      CASE prParte."Tipo Calculo" OF
        prParte."Tipo Calculo"::Margen: BEGIN  // Margenes
          CLEAR(rtmMar);
          IF rtmMar[1].FINDSET THEN BEGIN
            REPEAT
              lrMargen := rtmMar[1];
              lrMargen.INSERT(TRUE);
            UNTIL rtmMar[1].NEXT=0;
          END;
        END;

        prParte."Tipo Calculo"::Confirmacion: BEGIN // Coste-Ingreso

          // AJS 08.09.2006
          // Traspasamos las tablas de produccion de ingresos y de produccion de costes

          //CLEAR(rtmCI);
          //IF rtmCI[1].FIND('-') THEN BEGIN

            // AJS 26.07.2006
            // Buscamos el numero de linea una unica vez para incrementar el rendimiento

          //  lrCI2.RESET;
          //  lrCI2.ASCENDING(FALSE);
          //  lrCI2.SETRANGE ("N§ Parte", prParte."N§ Parte");
          //  lrCI2.SETFILTER("N§ Linea", '<=%1', 99000000);
          //  IF lrCI2.FIND('-') THEN
          //    lwNoLin := lrCI2."N§ Linea"
          //  ELSE
          //    lwNoLin := 100;

          //  REPEAT
          //    lwNoLin += 100;

          //    lrCI := rtmCI[1];
          //    lrCI."N§ Linea" := lwNoLin;
          //    lrCI.INSERT;
          //  UNTIL rtmCI[1].NEXT=0;
          //END;

          // Produccion de ingreso

          CLEAR(rtmProdIng);
          IF rtmProdIng[1].FINDSET THEN BEGIN

            // Buscar el numero de linea una vez y luego incrementamos manualmente

            lrProdIng.RESET;
            lrProdIng.ASCENDING(FALSE);
            lrProdIng.SETRANGE("N§ Parte", prParte."N§ Parte");
            IF lrProdIng.FINDFIRST THEN
              lwNoLin := lrProdIng."N§ Linea"
            ELSE
              lwNoLin := 0;

            REPEAT
              lwNoLin += 10;

              lrProdIng := rtmProdIng[1];
              lrProdIng."N§ Linea" := lwNoLin;
              lrProdIng.INSERT;
            UNTIL rtmProdIng[1].NEXT = 0;
          END;

          // Produccion de coste

          CLEAR(rtmProdCoste);
          IF rtmProdCoste[1].FINDSET THEN BEGIN

            // Buscar el numero de linea una vez y luego incrementamos manualmente

            lrProdCoste.RESET;
            lrProdCoste.ASCENDING(FALSE);
            lrProdCoste.SETRANGE("N§ Parte", prParte."N§ Parte");
            IF lrProdCoste.FINDFIRST THEN
              lwNoLin := lrProdCoste."N§ Linea"
            ELSE
              lwNoLin := 0;

            REPEAT
              lwNoLin += 10;

              lrProdCoste := rtmProdCoste[1];
              lrProdCoste."N§ Linea" := lwNoLin;
              lrProdCoste.INSERT;
            UNTIL rtmProdCoste[1].NEXT = 0;
          END;
        END;
      END;
    END;

    PROCEDURE CompruebaErrores@15(prParte@1100244000 : Record 7010360;pwEsRecalculo@1103350000 : Boolean) : Boolean;
    VAR
      rPro@1100244001 : Record 23;
      rCli@1100244002 : Record 18;
      lrTipoSer@1100244003 : Record 7010319;
      rTo@1100244004 : Record 7010312;
      lrExtra@1100244005 : Record 7010362;
      lrTTOOxP@1100244006 : Record 7010365;
      rComp@1100244007 : Record 7010313;
      lrCondFra@1103355000 : Record 7010416;
      lrParte2@1103355001 : Record 7010360;
      lwError@1100244008 : Boolean;
    BEGIN
      // CompruebaErrores

      wVentana.UPDATE(2, Text036);
      lwError := FALSE;

      // Comprobar si el parte esta confirmado

      IF (NOT pwEsRecalculo) AND prParte.Confirmado THEN  // Si recalculamos no interesa este error
        InsertaErrorE(prParte, Text002, rErr.Tipo::Error, lwError);

      // Comprobar si el parte tiene conductor asociado solo en caso de confirmacion del parte.

      IF prParte."Tipo Calculo" = prParte."Tipo Calculo"::Confirmacion THEN BEGIN
        IF prParte."Cod Conductor" = '' THEN
          InsertaErrorE(prParte, Text003, rErr.Tipo::Error,lwError);

        // Comprobar si el parte tiene vehiculo asociado solo en caso de confirmacion del parte.

        IF prParte.Vehiculo = '' THEN
          InsertaErrorE(prParte, Text004, rErr.Tipo::Error,lwError);

        // JPT 22/06/09 DRF IBZ 09001 - Valoraci¢n de partes de recogida
        // Si tiene parte de recogida asociado nos aseguramos que este tambien tenga rellenado vehiculo y conductor
        IF prParte."Recogida Generada" <> '' THEN BEGIN
          CLEAR(lrParte2);
          lrParte2.GET(prParte."Recogida Generada");
          IF lrParte2."Cod Conductor" = '' THEN
            InsertaErrorE(prParte, Text040, rErr.Tipo::Error,lwError);
          IF lrParte2.Vehiculo = '' THEN
            InsertaErrorE(prParte, Text041, rErr.Tipo::Error,lwError);
        END;

      END;

      // Comprobar en caso de que sea un traslado que el punto de Origen/Destino no este en blanco
      // Para comprobar que un servicio es de traslado hay que ir al tipo de servicio

      lrTipoSer.RESET;
      lrTipoSer.GET(prParte."Tipo Servicio");
      IF (lrTipoSer."Tipo fijo" = lrTipoSer."Tipo fijo"::Traslado) AND
         (prParte."Origen/Destino" = '') THEN
        InsertaErrorE(prParte, Text007, rErr.Tipo::Error, lwError);

      // AJS 25.07.2007
      // Controlar que existe un registro de condiciones de facturacion para todos los touroperador en
      // el tipo de servicio del parte

      rtmTOPar.RESET;
      rtmTOPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF rtmTOPar.FINDSET THEN BEGIN
        REPEAT
          lrCondFra.RESET;
          lrCondFra.SETRANGE(Cliente             , prParte.Cliente);
          lrCondFra.SETRANGE(TTOO                , rtmTOPar.Touroperador);
          lrCondFra.SETRANGE("Tipo Servicio Fijo", lrTipoSer."Tipo fijo");
          IF NOT lrCondFra.FINDFIRST THEN
            InsertaErrorE(prParte, STRSUBSTNO(Text038, prParte.Cliente, rtmTOPar.Touroperador, lrTipoSer."Tipo fijo"),
                          rErr.Tipo::Error, lwError);
        UNTIL rtmTOPar.NEXT = 0;
      END;

      // Comprobar que en el fichero de parametros se ha indicado el codigo de maletas
      IF rPar."Codigo Maletas" = '' THEN
        InsertaErrorE(prParte, Text031, rErr.Tipo::Error, lwError);

      // Comprobar que en el fichero de parametros se ha indicado el codigo de entradas
      IF rPar."Codigo Entradas" = '' THEN
        InsertaErrorE(prParte, Text033, rErr.Tipo::Error,lwError);

      // Comprobar que en el fichero de parametros se ha indicado el codigo de salidas
      IF rPar."Codigo Salidas" = '' THEN
        InsertaErrorE(prParte, Text034, rErr.Tipo::Error,lwError);

      // Comprobar que si hay extras que van a generar ingresos tengan un touroperador asignado
      CLEAR(lrExtra);
      lrExtra.SETRANGE ("N§ Parte"  , prParte."N§ Parte");
      lrExtra.SETFILTER("Tipo Extra", '<>%1', lrExtra."Tipo Extra"::Coste);
      IF lrExtra.FINDSET THEN BEGIN
        REPEAT
          IF lrExtra.Touroperador = '' THEN
            InsertaErrorE(prParte, STRSUBSTNO(Text023, lrExtra.Extra), rErr.Tipo::Error,lwError);
        UNTIL lrExtra.NEXT=0;
      END;

      // Comprobar que en el fichero de parametros se ha indicado el Grupo registro IVA producto para los precios manuales
      IF rPar."Grupo Registro IVA Producto" = '' THEN
        InsertaErrorE(prParte, Text024, rErr.Tipo::Error,lwError);

      // Comprobar que en el fichero de parametros se ha indicado el codigo de IVA para las maletas
      IF rPar."Grupo Registro IVA Maletas" = '' THEN
        InsertaErrorE(prParte, Text032, rErr.Tipo::Error,lwError);

      EXIT(lwError);
    END;

    PROCEDURE InsertaErrorE@1100253019(prParte@1100253003 : Record 7010360;pwTexto@1100253002 : Text[250];pwTipo@1100253001 : 'Error,Mensaje';VAR pwError@1100253000 : Boolean);
    BEGIN
      // InsertaErrorE
      // Inserta el error pero adem s devuelve un booleano de Error

      pwError:= pwError OR (pwTipo = pwTipo::Error);

      InsertaError(prParte,pwTexto,pwTipo);
    END;

    PROCEDURE InsertaError@2(prParte@1100244000 : Record 7010360;pwTexto@1100244001 : Text[250];pwTipo@1100244002 : 'Error,Mensaje');
    VAR
      lrErr@1100253000 : Record 7010413;
    BEGIN
      // InsertaError
      // Se encarga de insertar mensaje de error e informacion provinientes del calculo

      CLEAR(lrErr);
      lrErr."N§ Parte" := prParte."N§ Parte";
      lrErr.Texto   := pwTexto;
      lrErr.Fecha   := TODAY;
      lrErr.Usuario := USERID;
      lrErr.Tipo    := pwTipo;
      lrErr.INSERT(TRUE);
    END;

    PROCEDURE ChequeoTransportadosFacturados@1100244002(prParte@1100244001 : Record 7010360;VAR prToPar@1100244000 : TEMPORARY Record 7010365);
    BEGIN
      // ChequeoTransportadosFacturados

      CASE prParte."Tipo Calculo" OF
        prParte."Tipo Calculo"::Margen: BEGIN
          CLEAR(rtmMar);
          rtmMar[1].SETCURRENTKEY(Usuario, "N§ Parte", Touroperador,Concepto, "Tipo linea");
          rtmMar[1].SETRANGE(Usuario     , USERID);
          rtmMar[1].SETRANGE("N§ Parte"  , prParte."N§ Parte");
          rtmMar[1].SETRANGE(Touroperador, prToPar.Touroperador);
          rtmMar[1].SETRANGE(Concepto    , rtmMar[1].Concepto::Ingreso);
          rtmMar[1].SETRANGE("Tipo linea", rtmMar[1]."Tipo linea"::Base);
          IF rtmMar[1].FINDLAST THEN BEGIN
            rtmMar[2] := rtmMar[1];
            rtmMar[1].CALCSUMS("Pax Transportados");
            IF rtmMar[1]."Pax Transportados" <> prToPar."Pax Transportados" THEN BEGIN
              rtmMar[2]."Pax Transportados" += (prToPar."Pax Transportados" - rtmMar[1]."Pax Transportados");
              rtmMar[2].MODIFY;
            END;
          END;
        END;

        prParte."Tipo Calculo"::Confirmacion:
        BEGIN

          // AJS 08.09.2006
          // La comprobacion de paxes transportados la tenemos que hacer tanto para coste como para ingreso

          {* #######

          CLEAR(rtmCI);
          rtmCI[1].SETCURRENTKEY("N§ Parte", Touroperador, Concepto, "Tipo linea", "Tipo elemento", "Generada prevision");
          rtmCI[1].SETRANGE ("N§ Parte"   , prParte."N§ Parte");
          rtmCI[1].SETRANGE (Touroperador , prToPar.Touroperador);
          rtmCI[1].SETRANGE (Concepto     , rtmCI[1].Concepto::Ingreso);
          rtmCI[1].SETRANGE ("Tipo linea" , rtmCI[1]."Tipo linea"::Base);
          rtmCI[1].SETRANGE ("N§ Factura" , '');
          rtmCI[1].SETRANGE ("Linea abono", FALSE);
          IF rtmCI[1].FIND('+') THEN BEGIN
            rtmCI[2] := rtmCI[1];
            rtmCI[1].CALCSUMS("Pax Transportados");
            IF rtmCI[1]."Pax Transportados" <> prToPar."Pax Transportados" THEN BEGIN
              rtmCI[2]."Pax Transportados" += (prToPar."Pax Transportados" - rtmCI[1]."Pax Transportados");
              rtmCI[2].MODIFY;
            END;
          END;

          // Para que los campos Adultos y Ni¤os facturados queden correctos en Touroperador x parte revisamos
          // los costes ingresos

          rtmCI[1].SETRANGE("Tipo elemento", rPar."Codigo Adulto");
          IF rtmCI[1].FIND('-') THEN BEGIN
            rtmCI[1].CALCSUMS("Pax Facturados");
            prToPar."Adultos facturados" := rtmCI[1]."Pax Facturados";
            prToPar.MODIFY;
          END;

          rtmCI[1].SETRANGE("Tipo elemento", rPar."Codigo Ni¤o");
          IF rtmCI[1].FIND('-') THEN BEGIN
            rtmCI[1].CALCSUMS("Pax Facturados");
            prToPar."Ni¤os facturados" := rtmCI[1]."Pax Facturados";
            prToPar.MODIFY;
          END;

          rtmCI[1].SETRANGE ("Tipo linea" , rtmCI[1]."Tipo linea"::Manual);
          IF rtmCI[1].FIND('-') THEN BEGIN
            rtmCI[1].CALCSUMS("Pax Facturados");
            prToPar."Adultos facturados" := rtmCI[1]."Pax Facturados";
            prToPar."Ni¤os facturados" := 0;
            prToPar.MODIFY;
          END;

          ####### }

          // Comprobacion de paxes transportados en las lineas de produccion de ingreso

          rtmProdIng[1].RESET;
          rtmProdIng[1].SETRANGE("N§ Parte"   , prParte."N§ Parte");
          rtmProdIng[1].SETRANGE(Touroperador , prToPar.Touroperador);
          rtmProdIng[1].SETRANGE("Tipo linea" , rtmProdIng[1]."Tipo linea"::Base);
          rtmProdIng[1].SETRANGE("Linea abono", FALSE);
          rtmProdIng[1].ASCENDING(FALSE);
          IF rtmProdIng[1].FINDFIRST THEN BEGIN
            rtmProdIng[2] := rtmProdIng[1];
            rtmProdIng[1].CALCSUMS("Pax Transportados");
            IF rtmProdIng[1]."Pax Transportados" <> prToPar."Pax Transportados" THEN BEGIN
              rtmProdIng[2]."Pax Transportados" += (prToPar."Pax Transportados" - rtmProdIng[1]."Pax Transportados");
              rtmProdIng[2].MODIFY;
            END;
          END;

          // Comprobacion de Adultos, Ni¤os facturados para el touroperador

          rtmProdIng[1].SETRANGE("Tipo elemento", rPar."Codigo Adulto");
          IF rtmProdIng[1].FINDFIRST THEN BEGIN
            rtmProdIng[1].CALCSUMS("Pax Facturados");
            prToPar."Adultos facturados" := rtmProdIng[1]."Pax Facturados";
            prToPar.MODIFY;
          END;

          rtmProdIng[1].SETRANGE("Tipo elemento", rPar."Codigo Ni¤o");
          IF rtmProdIng[1].FINDFIRST THEN BEGIN
            rtmProdIng[1].CALCSUMS("Pax Facturados");
            prToPar."Ni¤os facturados" := rtmProdIng[1]."Pax Facturados";
            prToPar.MODIFY;
          END;

          rtmProdIng[1].SETRANGE("Tipo linea" , rtmProdIng[1]."Tipo linea"::Manual);
          rtmProdIng[1].SETRANGE("Tipo elemento");
          IF rtmProdIng[1].FINDFIRST THEN BEGIN
            rtmProdIng[1].CALCSUMS("Pax Facturados");
            prToPar."Adultos facturados" := rtmProdIng[1]."Pax Facturados";
            prToPar."Ni¤os facturados" := 0;
            prToPar.MODIFY;
          END;
        END;
      END;
    END;

    PROCEDURE BuscaContratoVenta@11(VAR prtmConV@1100253001 : TEMPORARY Record 7010403;pwCliente@1100244001 : Code[20];pwTTOO@1100244002 : Code[10];pwFecha@1100244003 : Date;pwGaraje@1100244004 : Code[10]) : Boolean;
    VAR
      lwEnc@1100253000 : Boolean;
    BEGIN
      // BuscaContratoVenta
      // Busca el contrato de venta a aplicar en funcion de la composicion y de la fecha del servicio.

      CLEAR(rtmConV);
      CLEAR(prtmConV);
      rtmConV.SETCURRENTKEY(Cliente,Touroperador,"Fecha inicio contrato","Fecha final contrato");
      // Al buscar los precios habra que chequear que exista para el garaje del servicio o para el garaje TODOS

      rtmConV.SETFILTER(Garaje                 , '%1|%2', pwGaraje, rPar."Todos los garajes");
      rtmConV.SETRANGE (Cliente                , pwCliente);
      rtmConV.SETRANGE (Touroperador           , pwTTOO);
      rtmConV.SETFILTER("Fecha inicio contrato", '<=%1', pwFecha);
      rtmConV.SETFILTER("Fecha final contrato" , '>=%1', pwFecha);
      rtmConV.SETRANGE (Confirmado             , TRUE);

      lwEnc := rtmConV.FINDFIRST;
      IF lwEnc THEN
        prtmConV:= rtmConV;

      // Si no lo encuentra en el temporal lo busca e inserta en el real
      IF NOT lwEnc THEN
        lwEnc := InsertaContratoVenta(prtmConV,pwCliente,pwTTOO,pwFecha,pwGaraje);

      IF lwEnc THEN
        BuscaPrecisionVenta(prtmConV);

      EXIT(lwEnc);
    END;

    PROCEDURE InsertaContratoVenta@1100253046(VAR prtmConV@1100253009 : TEMPORARY Record 7010403;pwCliente@1100253005 : Code[20];pwTTOO@1100253004 : Code[10];pwFecha@1100253003 : Date;pwGaraje@1100253002 : Code[10]) : Boolean;
    VAR
      lrConV@1100253000 : Record 7010403;
      lrPrecV@1100253006 : Record 7010405;
      lrZonC@1100253007 : Record 7010404;
      lrMinC@1100253008 : Record 7010407;
      lwEnc@1100253001 : Boolean;
    BEGIN
      // InsertaContratoVenta

      // Busca y copia al temporal el contrato de venta a aplicar en funcion de la composicion y de la fecha del servicio.
      // Se supone que el contrato No debe de existir aun en el temporal

      lwEnc := BuscaContratoVentaReal(lrConV,pwCliente,pwTTOO,pwFecha,pwGaraje);

      IF lwEnc THEN BEGIN
        rtmConV:= lrConV;
        rtmConV.INSERT;
        prtmConV := rtmConV;

        // Si est  basado en otro contrato, insertamos tambien este otro contrato
        IF lrConV."Basado en contrato n§" <> '' THEN BEGIN
          CLEAR(rtmConV);
          IF rtmConV.GET(lrConV.Garaje,lrConV."Basado en contrato n§") THEN
            EXIT(lwEnc)
          ELSE BEGIN
            lrConV.GET(lrConV.Garaje,lrConV."Basado en contrato n§");
            rtmConV:= lrConV;
            rtmConV.INSERT;
          END
        END;

        CLEAR(lrPrecV); // Precios
        lrPrecV.SETRANGE(Garaje       , lrConV.Garaje);
        lrPrecV.SETRANGE("N§ Contrato", lrConV."N§ Contrato");
        IF lrPrecV.FINDSET THEN BEGIN
          REPEAT
            rtmPrecV := lrPrecV;
            rtmPrecV.INSERT;
          UNTIL lrPrecV.NEXT=0;
        END;

        CLEAR(lrZonC); // Zonas de precio
        lrZonC.SETRANGE(Garaje       , lrConV.Garaje);
        lrZonC.SETRANGE("N§ Contrato", lrConV."N§ Contrato");
        lrZonC.SETRANGE("Tipo contrato", lrZonC."Tipo contrato"::Venta);
        IF lrZonC.FINDSET THEN BEGIN
          REPEAT
            rtmZonaC := lrZonC;
            rtmZonaC.INSERT;
          UNTIL lrZonC.NEXT=0;
        END;

        CLEAR(lrMinC); // Minimos Vehiculo
        lrMinC.SETRANGE(Garaje         , lrConV.Garaje);
        lrMinC.SETRANGE("N§ Contrato"  , lrConV."N§ Contrato");
        lrMinC.SETRANGE("Tipo Contrato", lrMinC."Tipo Contrato"::Venta);
        IF lrMinC.FINDSET THEN BEGIN
          REPEAT
            rtmMinC := lrMinC;
            rtmMinC.INSERT;
          UNTIL lrMinC.NEXT=0;
        END;
      END
      ELSE
        CLEAR(rtmConV);

      EXIT(lwEnc)
    END;

    PROCEDURE BuscaContratoVentaReal@1100253002(VAR prConv@1100244000 : Record 7010403;pwCliente@1100244001 : Code[20];pwTTOO@1100244002 : Code[10];pwFecha@1100244003 : Date;pwGaraje@1100244004 : Code[10]) : Boolean;
    VAR
      lwEnc@1100253000 : Boolean;
    BEGIN
      // BuscaContratoVentaReal
      //
      // Busca el contrato de venta a aplicar en funcion de la composicion y de la fecha del servicio.
      // Se utiliza tambien para funciones externas

      rPar.FINDFIRST;

      CLEAR(prConv);
      prConv.SETCURRENTKEY(Cliente,Touroperador,"Fecha inicio contrato","Fecha final contrato");
      // Al buscar los precios habra que chequear que exista para el garaje del servicio o para el garaje TODOS

      prConv.SETFILTER(Garaje                 , '%1|%2', pwGaraje, rPar."Todos los garajes");
      prConv.SETRANGE (Cliente                , pwCliente);
      prConv.SETRANGE (Touroperador           , pwTTOO);
      prConv.SETFILTER("Fecha inicio contrato", '<=%1', pwFecha);
      prConv.SETFILTER("Fecha final contrato" , '>=%1', pwFecha);
      prConv.SETRANGE (Confirmado             , TRUE);

      lwEnc := prConv.FINDFIRST;

      IF NOT lwEnc THEN
        CLEAR(prConv);

      EXIT(lwEnc);
    END;

    PROCEDURE BuscaPrecisionVenta@51(prCon@1100244000 : TEMPORARY Record 7010403) : Decimal;
    VAR
      rConf@1100244001 : Record 98;
      rDiv@1100244002 : Record 4;
      lwPrecIngreso@1100253000 : Decimal;
    BEGIN
      // BuscaPrecisionVenta

      //  Determina cual va a ser la precision a aplicar en los ROUND de venta,
      //  puede ser la de la divisa del contrato la de Configuracion contabilidad.

      CLEAR(lwPrecIngreso);
      IF prCon."Cod. Divisa" <> '' THEN BEGIN
        rDiv.GET(prCon."Cod. Divisa");
        lwPrecIngreso := rDiv."Amount Rounding Precision";
      END
      ELSE BEGIN
        rConf.FINDFIRST;
        lwPrecIngreso := rConf."Amount Rounding Precision";
      END;
      wPrecisionIngreso := lwPrecIngreso;
      EXIT(lwPrecIngreso);
    END;

    PROCEDURE TraduceZonaVenta@14(prParte@1100244000 : Record 7010360;VAR prTOParte@1100253000 : TEMPORARY Record 7010365;prCon@1100244001 : TEMPORARY Record 7010403;VAR pwPasajeIngreso@1100244007 : ARRAY [3] OF Integer;VAR prtmZonPre2@1100253002 : TEMPORARY Record 7010364);
    VAR
      lrTipoSer@1103355000 : Record 7010319;
      lrCliTo@1103355001 : Record 7010313;
    BEGIN
      // TraduceZonaVenta
      //
      // A partir del contrato obtenido y todos los puntos de recogida buscamos la zona de precios a la que corresponde.
      // prtmZonPre2 indica cual es la zona parte m s alejada
      // pwPasajeIngreso tiene tres dimesiones: 1-Todos, 2=Adultos, 3= Ni¤os


      CLEAR(lrCliTo);
      lrCliTo.GET(prCon.Cliente, prCon.Touroperador);

      rtmSerPar.RESET;
      rtmSerPar.SETCURRENTKEY("N§ Parte");
      rtmSerPar.SETRANGE("N§ Parte"  , prParte."N§ Parte");
      rtmSerPar.SETRANGE(Touroperador, prCon.Touroperador);
      IF rtmSerPar.FINDSET THEN BEGIN
        REPEAT
          CLEAR(rtmZonaC);

          // Al buscar las zonas habra que chequear que exista para el garaje del servicio o para el garaje TODOS

          rtmZonaC.SETFILTER(Garaje        , '%1|%2', prParte.Garaje, rPar."Todos los garajes");
          rtmZonaC.SETRANGE("N§ Contrato"  , NumeroContratoVentFacturacion(prCon));
          rtmZonaC.SETRANGE("Tipo contrato", rtmZonaC."Tipo contrato"::Venta);
          rtmZonaC.SETRANGE("Codigo Origen", rtmSerPar."Zona fisica");

          // AJS 30.06.2008, TNU08002
          // Incluimos el filtro por el tipo de servicio del parte de trabajo

          lrTipoSer.GET(prParte."Tipo Servicio");
          rtmZonaC.SETRANGE("Tipo Servicio fijo", lrTipoSer."Tipo fijo");

          IF rtmZonaC.FINDFIRST THEN BEGIN
            rtmSerPar."Zona Venta" := rtmZonaC."Zona Precio";
            rtmSerPar.MODIFY;

            CLEAR(rtmZonPre);
            rtmZonPre.SETRANGE("N§ Parte"     , prParte."N§ Parte");
            rtmZonPre.SETRANGE("Tipo contrato", rtmZonPre."Tipo contrato"::Venta);
            rtmZonPre.SETRANGE("N§ Contrato"  , prCon."N§ Contrato");
            rtmZonPre.SETRANGE("Zona Precio"  , rtmZonaC."Zona Precio");
            IF NOT rtmZonPre.FINDFIRST THEN BEGIN
              rtmZonPre."N§ Parte"        := prParte."N§ Parte";
              rtmZonPre."Tipo contrato"   := rtmZonPre."Tipo contrato"::Venta;
              rtmZonPre."N§ Contrato"     := prCon."N§ Contrato";
              rtmZonPre."Zona Precio"     := rtmZonaC."Zona Precio";
              rtmZonPre."N§ viajes"       := prParte."N§ viajes";
              rtmZonPre.Cliente           := prParte.GetClienteEstadistico(prCon.Touroperador); // AJF 24/08/10;
              rtmZonPre.TTOO              := prCon.Touroperador;
              rtmZonPre.Fecha             := prParte."Fecha facturacion";
              rtmZonPre."Tipo servicio"   := prParte."Tipo Servicio";
              rtmZonPre."Codigo servicio" := prParte."Codigo Servicio";
              rtmZonPre.Garaje            := prParte.Garaje;

              // Marcar el servicio como no propio si tiene proveedor  ----

              rtmZonPre."Servicio propio" := (prParte.Proveedor = '');
              // JPT 22/07/08 DRF 08004
              rtmZonPre."Grupo Precio" := lrCliTo."Agrupa para precio con";
              IF rtmZonPre."Grupo Precio" = '' THEN
                rtmZonPre."Grupo Precio" := prCon.Touroperador;

              rtmZonPre.INSERT;

              // Buscamos la zona precio parte m s alejada
              IF rtmZonPre.Orden > prtmZonPre2.Orden THEN
                prtmZonPre2 := rtmZonPre;
            END;

            // El orden solo se actualiza si el orden la zona no se modifico manualmente

            IF NOT rtmZonPre."Orden modificado manual" THEN
              rtmZonPre.Orden := rtmZonaC.Orden;

            IF NOT rtmZonPre."Pasaje modificado manual" THEN BEGIN
              rtmZonPre."Adultos facturados zona" += rtmSerPar."Adultos transportados" - rtmSerPar."Adultos invitados ingreso";
              rtmZonPre."Ni¤os facturados zona"   += rtmSerPar."Ni¤os transportados" - rtmSerPar."Ni¤os invitados ingreso";
              rtmZonPre."Adultos Invitados Zona"  += rtmSerPar."Adultos invitados ingreso";
              rtmZonPre."Ni¤os Invitados Zona"    += rtmSerPar."Ni¤os invitados ingreso";
            END;

            rtmZonPre."Adultos Transportados zona" := rtmZonPre."Adultos Transportados zona" + rtmSerPar."Adultos transportados";
            rtmZonPre."Ni¤os Transportados zona"   := rtmZonPre."Ni¤os Transportados zona" + rtmSerPar."Ni¤os transportados";
            rtmZonPre.MODIFY;

          END
          ELSE BEGIN
            // Si el parte es gratuito no se inserta el error. Solo se insertan errores si el parte es facturable

            IF prParte.Facturable THEN
              InsertaError(prParte, STRSUBSTNO(Text026, rtmSerPar."Zona fisica", prCon."N§ Contrato"), rErr.Tipo::Error);
          END;
        UNTIL rtmSerPar.NEXT = 0;
      END;

      // Almacenar en Touroperador x parte la suma de adultos facturados y los ni¤os facturados

      rtmZonPre.RESET;
      rtmZonPre.SETRANGE("N§ Parte"     , prParte."N§ Parte");
      rtmZonPre.SETRANGE("Tipo contrato", rtmZonPre."Tipo contrato"::Venta);
      rtmZonPre.SETRANGE("N§ Contrato"  , prCon."N§ Contrato");
      IF rtmZonPre.FINDSET THEN BEGIN
        REPEAT
          prTOParte."Adultos facturados" += rtmZonPre."Adultos facturados zona";
          prTOParte."Ni¤os facturados"   += rtmZonPre."Ni¤os facturados zona";
          prTOParte.MODIFY;

          pwPasajeIngreso[1] += rtmZonPre."Adultos facturados zona" + rtmZonPre."Ni¤os facturados zona";
          pwPasajeIngreso[2] += rtmZonPre."Adultos facturados zona" ;
          pwPasajeIngreso[3] += rtmZonPre."Ni¤os facturados zona" ;
        UNTIL rtmZonPre.NEXT = 0;
      END;
    END;

    PROCEDURE BuscaPrecioVenta@8(prParte@1100244000 : Record 7010360;prCon@1100244001 : TEMPORARY Record 7010403;VAR prPre@1100244002 : TEMPORARY Record 7010405;pwZonPre@1100244003 : Code[10];pwElem@1100244005 : Code[10];pwCant@1100244006 : Decimal;pwOrigenDestino@1100244007 : Code[10];pwCantZona@1100244009 : Decimal;pwCantTTOO@1100244010 : Decimal;pwGrupoPrec@1103355000 : Code[10]) : Boolean;
    VAR
      lrTipoSer@1100244011 : Record 7010319;
      lwEsExcursion@1100244012 : Boolean;
      lwCodContV@1100253000 : Code[10];
      lwCantCalculo@1100253002 : Decimal;
      lwEnc@1100253003 : Boolean;
      lwTextoErr@1100253004 : Text[250];
    BEGIN
      // BuscaPrecioVenta

      //  Buscamos el precio a aplicar en funcion de servicio, zona, fechas , tipo de vehiculo y rango de personas.
      //  Solo se insertan errores si el parte es facturable


      lwCodContV:= NumeroContratoVentFacturacion(prCon);

      CLEAR(rtmPrecV);
      rtmPrecV.SETCURRENTKEY(Garaje,
                            "N§ Contrato",
                            "Tipo precio",
                            "Codigo servicio",
                            "Zona desde",
                            "Zona hasta",
                            "Fecha desde",
                            "Fecha hasta",
                            "Tipo Vehiculo",
                            "Rango desde",
                            "Rango hasta");
      rtmPrecV.SETRANGE(Garaje             , prCon.Garaje);
      rtmPrecV.SETRANGE("N§ Contrato"      , lwCodContV);
      IF pwElem = '' THEN
        rtmPrecV.SETRANGE("Tipo precio"    , rtmPrecV."Tipo precio"::"Precio Base")
      ELSE
        rtmPrecV.SETRANGE("Tipo precio"    , rtmPrecV."Tipo precio"::"Suplemento elemento");
      rtmPrecV.SETRANGE("Codigo servicio"  , prParte."Codigo Servicio");


      // Para saber si un servicio es una excursion hay que consultar el tipo servicio

      lrTipoSer.RESET;
      lrTipoSer.GET(prParte."Tipo Servicio");
      lwEsExcursion := lrTipoSer."Tipo fijo" = lrTipoSer."Tipo fijo"::Excursion;

      IF lwEsExcursion THEN BEGIN
        rtmPrecV.SETRANGE("Zona desde"     , pwZonPre);
        rtmPrecV.SETRANGE("Zona hasta"     , '');
      END
      ELSE BEGIN
        rtmPrecV.SETRANGE("Zona desde"     , pwOrigenDestino);
        rtmPrecV.SETRANGE("Zona hasta"     , pwZonPre);
      END;
      rtmPrecV.SETFILTER("Fecha desde"      , '<=%1', prParte."Fecha facturacion");
      rtmPrecV.SETFILTER("Fecha hasta"      , '>=%1', prParte."Fecha facturacion");
      rtmPrecV.SETRANGE ("Tipo Vehiculo"    , prParte."Tipo Vehiculo facturacion");

      // Buscaremos los paxes por cada zona de precio si se ha indicado asi para calcular los precios de cada zona
      // o si hemos indicado que queremos buscar el precio de cada touroperador independientemente
      // A la hora de buscar precio, seguiremos el siguiente criterio, si se ha indicado precio x zona, se buscan
      // solo los paxes de la zona que estamos tratando, sino, cuando indiquemos pasaje independiente buscaremos
      // los del touroperador que estamos tratando pero si se ha indicado pasaje conjunto buscaremos para todo el
      // pasaje del parte de trabajo

      { JPT 22/07/08 DRF 08004
        Introducimos nueva formula determinar el pax para buscar precio
        Si pwElem <>'' suponemos que se trata de maletas o suplementos
        por lo que el calculo ser  igual que antes}

      IF pwElem <> '' THEN BEGIN
        IF prParte."Busca precio pasaje x zona ing" THEN
          lwCantCalculo := ROUND(pwCantZona, 1)
        ELSE BEGIN
          IF prParte."Busca precio ingreso" = prParte."Busca precio ingreso"::"Pasaje independiente" THEN
            lwCantCalculo := ROUND(pwCantTTOO, 1)
          ELSE
            lwCantCalculo := ROUND(pwCant, 1);
        END;
      END ELSE
        lwCantCalculo := SumaPaxPrecioVenta(prParte, pwZonPre, pwGrupoPrec);

      rtmPrecV.SETFILTER("Rango desde"      , '<=%1', lwCantCalculo);
      rtmPrecV.SETFILTER("Rango hasta"      , '>=%1', lwCantCalculo);

      IF pwElem <> '' THEN
        rtmPrecV.SETRANGE ("Codigo suplemento", pwElem);
      rtmPrecV.SETRANGE (Activo             , TRUE);
      lwEnc := rtmPrecV.FINDFIRST;
      IF NOT lwEnc THEN BEGIN
        rtmPrecV.SETRANGE ("Tipo Vehiculo");
        lwEnc := rtmPrecV.FINDFIRST;
        IF (NOT lwEnc) AND (pwElem <> '') THEN BEGIN
          rtmPrecV.SETFILTER("Zona desde", '=%1','');
          rtmPrecV.SETFILTER("Zona hasta", '=%1','');
          lwEnc := rtmPrecV.FINDFIRST;
        END;
      END;

      IF NOT lwEnc THEN BEGIN
        IF lwEsExcursion THEN
          lwTextoErr := STRSUBSTNO(Text021, prCon."N§ Contrato", prParte."Codigo Servicio", pwZonPre,
                            prParte."Fecha facturacion", lwCantCalculo, pwElem)
        ELSE
          lwTextoErr := STRSUBSTNO(Text022, prCon."N§ Contrato", prParte."Codigo Servicio", pwOrigenDestino, pwZonPre,
                          prParte."Fecha facturacion", lwCantCalculo, pwElem);
      END;

      IF lwEnc THEN
        prPre := rtmPrecV;

      IF pwElem = rPar."Codigo Maletas" THEN BEGIN
        CLEAR(lwTextoErr); // Si es codigo maletas no generaremos el error ahora ya que puede encontrarse precio generico
      END;

      // Solo se insertan errores si el parte es facturable
      // JPT 30/07/08 No se inserta error si la cantidad a buscar es 0
      IF (NOT lwEnc) AND prParte.Facturable AND (lwTextoErr <> '') AND (lwCantCalculo <> 0) THEN
        InsertaError(prParte, lwTextoErr, rErr.Tipo::Error);

      EXIT(lwEnc);
    END;

    PROCEDURE BuscaPrecioMaletas@28(VAR prPreMal@1100244000 : Record 7010322;prParte@1100244001 : Record 7010360) : Boolean;
    BEGIN
      // BuscaPrecioMaletas
      //
      // Buscar en el fichero de precios genericos maletas el que corresponda a la fecha del servicio.

      CLEAR(prPreMal);
      prPreMal.SETFILTER("Fecha desde", '<=%1', prParte."Fecha facturacion");
      prPreMal.SETFILTER("Fecha hasta", '>=%1', prParte."Fecha facturacion");
      EXIT(prPreMal.FINDFIRST);
    END;

    PROCEDURE BuscaPrecioSuplementoVenta@47(prCon@1100244000 : Record 7010403;prParte@1100244001 : Record 7010360;pw_desde@1100244002 : Code[10];pw_hasta@1100244003 : Code[10];VAR prPre@1100244004 : TEMPORARY Record 7010405) : Boolean;
    VAR
      lwOk@1100253000 : Boolean;
    BEGIN
      // BuscaPrecioSuplementoVenta

      //   Devuelve false o true en funcion de si ha encontrado el precio o no y devuelve el
      //   precio en el registro que se le pasa por parametro.

      CLEAR(rtmPrecV);
      rtmPrecV.SETCURRENTKEY(Garaje,
                          "N§ Contrato",
                          "Tipo precio",
                          "Codigo servicio",
                          "Zona desde",
                          "Zona hasta",
                          "Fecha desde",
                          "Fecha hasta",
                          "Tipo Vehiculo",
                          "Rango desde",
                          "Rango hasta");
      rtmPrecV.SETRANGE (Garaje           , prCon.Garaje);
      rtmPrecV.SETRANGE ("N§ Contrato"    , NumeroContratoVentFacturacion(prCon));
      rtmPrecV.SETRANGE ("Tipo precio"    , rtmPrecV."Tipo precio"::"Suplemento zona");
      rtmPrecV.SETRANGE ("Codigo servicio", prParte."Codigo Servicio");
      rtmPrecV.SETRANGE ("Zona desde"     , pw_desde);
      rtmPrecV.SETRANGE ("Zona hasta"     , pw_hasta);
      rtmPrecV.SETFILTER("Fecha desde"    , '<=%1', prParte."Fecha facturacion");
      rtmPrecV.SETFILTER("Fecha hasta"    , '>=%1', prParte."Fecha facturacion");
      rtmPrecV.SETRANGE ("Tipo Vehiculo"  , prParte."Tipo Vehiculo facturacion");
      rtmPrecV.SETRANGE ("Tipo Servicio"  , prParte."Tipo Servicio");
      rtmPrecV.SETRANGE (Activo           , TRUE);
      lwOk := rtmPrecV.FINDFIRST;
      IF NOT lwOk THEN BEGIN
        rtmPrecV.SETRANGE("Codigo servicio", '');
        lwOk := rtmPrecV.FINDFIRST;
      END;
      IF NOT lwOk THEN BEGIN
        rtmPrecV.SETRANGE("Tipo Vehiculo", '');
        lwOk := rtmPrecV.FINDFIRST;
      END;
      IF NOT lwOk THEN BEGIN
        rtmPrecV.SETRANGE("Tipo Servicio", '');
        lwOk := rtmPrecV.FINDFIRST;
      END;

      IF lwOk THEN
        prPre := rtmPrecV;

      EXIT(lwOk);
    END;

    PROCEDURE NumeroContratoVentFacturacion@53(prCon@1100244000 : TEMPORARY Record 7010403) : Code[10];
    BEGIN
      // NumeroContratoVentFacturacion
      // Devuelve el numero de contrato de Venta a facturar, es decir si esta asociado a otro contrato
      // ser  el n£mero de este £ltimo, si no, ser  su propio numero

      IF prCon."Basado en contrato n§"<>'' THEN
        EXIT (prCon."Basado en contrato n§")
      ELSE
        EXIT (prCon."N§ Contrato");
    END;

    PROCEDURE NumeroContratoCompFacturacion@1100253027(prConC@1100244000 : TEMPORARY Record 7010408) : Code[10];
    BEGIN
      // NumeroContratoCompFacturacion
      // Devuelve el numero de contrato de Compra a facturar, es decir si esta asociado a otro contrato
      // ser  el n£mero de este £ltimo, si no, ser  su propio numero

      IF prConC."Basado en contrato n§" <>'' THEN
        EXIT (prConC."Basado en contrato n§")
      ELSE
        EXIT (prConC."N§ Contrato");
    END;

    PROCEDURE TraduceOrigenVenta@39(prParte@1100244000 : Record 7010360;prCon@1100244001 : Record 7010403) : Code[10];
    VAR
      lrTipoSer@1100244004 : Record 7010319;
      lrPto@1100253000 : Record 7010315;
    BEGIN
      // TraduceOrigenVenta
      // Para saber si es una excursion hay que consultar el tipo de servicio  ----

      lrTipoSer.RESET;
      lrTipoSer.GET(prParte."Tipo Servicio");
      IF (prParte."Origen/Destino" <> '') AND
         (lrTipoSer."Tipo fijo" <> lrTipoSer."Tipo fijo"::Excursion) THEN BEGIN

        lrPto.RESET;
        lrPto.GET(prParte."Origen/Destino");

        CLEAR(rtmZonaC);

        // Al buscar los precios habra que chequear que exista para el garaje del servicio o para el garaje TODOS

        rtmZonaC.SETFILTER(Garaje        , '%1|%2', prParte.Garaje, rPar."Todos los garajes");
        rtmZonaC.SETRANGE("N§ Contrato"  , NumeroContratoVentFacturacion(prCon));
        rtmZonaC.SETRANGE("Tipo contrato", rtmZonaC."Tipo contrato"::Venta);
        rtmZonaC.SETRANGE("Codigo Origen" , lrPto."Zona fisica");

        // AJS 30.06.2008, TNU08002
        // Filtramos por el tipo de servicio fijo del parte de trabajo

        rtmZonaC.SETRANGE("Tipo Servicio fijo", lrTipoSer."Tipo fijo");

        IF rtmZonaC.FINDFIRST THEN
          EXIT(rtmZonaC."Zona Precio")
        ELSE BEGIN
          //  Si el parte es gratuito no se inserta el error
          //  Solo se insertan errores si el parte es facturable
          IF prParte.Facturable THEN
            InsertaError(prParte, STRSUBSTNO(Text026, lrPto."Zona fisica", prCon."N§ Contrato"), rErr.Tipo::Error);
        END;
      END;
    END;

    PROCEDURE ChequeaPrecios@1100244003(VAR prParte@1100244000 : Record 7010360;VAR prToPar@1100244001 : TEMPORARY Record 7010365;pwPasajeIngreso@1100253000 : Decimal);
    VAR
      rToPar@1100244005 : Record 7010365;
      lrCon@1100244003 : TEMPORARY Record 7010403;
      lrPre@1100244006 : TEMPORARY Record 7010405;
      lwOrigenDestino@1100244002 : Code[10];
      lwPreciosIguales@1100244008 : Boolean;
      lwPrecioAnt@1100244011 : ARRAY [2] OF Decimal;
      lwCantidadParte@1100244010 : Decimal;
      lwCantidadZona@1100244012 : Decimal;
      lwCantidadTO@1100244013 : Decimal;
    BEGIN
      // ChequeaPrecios
      // Funcion previa a calculo, TRN
      // Se pretende que una vez comprobado cada uno de los precios, si el campo "Ingreso Precios por" del parte
      // es "Zona Combinada" y todos los precios para el 1 TTOO son iguales se cambiara ese campo a "Zona mas alejada"
      // lwPrecioAnt tiene 2 dimensiones 1:Adultos 2: Ni¤os

      IF prParte."Ingreso Precios por" <> prParte."Ingreso Precios por"::"Zonas combinadas" THEN
        EXIT;

      IF prToPar."Precio manual venta" <> 0 THEN
        EXIT;

      lwPreciosIguales:= FALSE;
      BuscaContratoVenta(lrCon, prParte.Cliente, prToPar.Touroperador, prParte."Fecha facturacion",prParte.Garaje);

      lwOrigenDestino := TraduceOrigenVenta(prParte, lrCon);

      CLEAR(rtmZonPre);
      rtmZonPre.SETCURRENTKEY("N§ Parte","Tipo contrato","N§ Contrato",Orden);
      rtmZonPre.SETRANGE("N§ Parte"     , prParte."N§ Parte");
      rtmZonPre.SETRANGE("Tipo contrato", rtmZonPre."Tipo contrato"::Venta);
      rtmZonPre.SETRANGE("N§ Contrato"  , lrCon."N§ Contrato");
      IF rtmZonPre.FINDSET THEN BEGIN
        IF rtmZonPre.COUNT =1 THEN // Solo para cuando tengamos m s de una zona
          EXIT;

        lwPreciosIguales := TRUE;
        CLEAR(lwPrecioAnt);
        REPEAT
          IF rtmZonPre."Pasaje modificado manual" THEN
            lwCantidadParte := pwPasajeIngreso
          ELSE
            lwCantidadParte := prParte."Adultos trans. soporte" + prParte."Ni¤os trans. soporte";

          IF rtmZonPre."Pasaje modificado manual" THEN
            lwCantidadZona := rtmZonPre."Adultos facturados zona" + rtmZonPre."Ni¤os facturados zona"
          ELSE
            lwCantidadZona := rtmZonPre."Adultos Transportados zona" + rtmZonPre."Ni¤os Transportados zona";

          lwCantidadTO   := prToPar."Adultos transportados" + prToPar."Ni¤os transportados";

          IF BuscaPrecioVenta(prParte, lrCon, lrPre, rtmZonPre."Zona Precio", '', lwCantidadParte,
                                lwOrigenDestino, lwCantidadZona, lwCantidadTO, rtmZonPre."Grupo Precio") THEN BEGIN
             CASE lrPre."Tipo aplicacion" OF
               lrPre."Tipo aplicacion"::Pax:
               BEGIN
                 IF rtmZonPre."Adultos facturados zona" <> 0 THEN BEGIN
                   lwPreciosIguales := lwPreciosIguales AND
                                       (lrPre."Precio Adulto" <> 0) AND
                                       ((lrPre."Precio Adulto" = lwPrecioAnt[1]) OR (lwPrecioAnt[1]=0));
                   lwPrecioAnt[1] := lrPre."Precio Adulto";
                 END;
                 IF rtmZonPre."Ni¤os facturados zona" <> 0 THEN BEGIN
                   lwPreciosIguales := lwPreciosIguales    AND
                                       (lrPre."Precio Ni¤o" <> 0) AND
                                       ((lrPre."Precio Ni¤o" = lwPrecioAnt[2]) OR (lwPrecioAnt[2]=0));
                   lwPrecioAnt[2] := lrPre."Precio Ni¤o";
                 END;
               END;
               ELSE
                 lwPreciosIguales    := FALSE; // Por vehiculo
             END;
          END
          ELSE
            lwPreciosIguales := FALSE;
        UNTIL (rtmZonPre.NEXT=0) OR NOT lwPreciosIguales;
      END;

      IF lwPreciosIguales THEN BEGIN
        prParte."Ingreso Precios por" := prParte."Ingreso Precios por"::"Zona mas alejada";
        prParte.MODIFY;
        prToPar.MODIFYALL("Ingreso Precios Por", prToPar."Ingreso Precios Por"::"Zona mas alejada");
        prToPar."Ingreso Precios Por":= prToPar."Ingreso Precios Por"::"Zona mas alejada";
        prToPar.MODIFY;
        // Nota : Ya se que un modifyall puede parecer suficiente, pero creedme, no lo es
      END;
    END;

    PROCEDURE BuscaContratoCompra@19(VAR prTmConC@1100244000 : TEMPORARY Record 7010408;pwProveedor@1100244001 : Code[20];pwTTOO@1100244002 : Code[10];pwCliente@1100244003 : Code[20];pwFecha@1100244004 : Date;pwGaraje@1100244005 : Code[10]) : Boolean;
    VAR
      lwEnc@1100253000 : Boolean;
    BEGIN
      // BuscaContratoCompra

      // Buscar el contrato de compra a utilizar en el parte en funcion del proveedor, cliente-Touroperador y fecha de facturacion.

      CLEAR(prTmConC);
      CLEAR(rtmConC);
      rtmConC.SETCURRENTKEY(Proveedor,Cliente,Touroperador,"Fecha inicio contrato","Fecha final contrato");

      rtmConC.SETFILTER(Garaje                 , '%1|%2', rPar."Todos los garajes", pwGaraje);
      rtmConC.SETRANGE (Proveedor              , pwProveedor);
      rtmConC.SETRANGE (Cliente                , pwCliente);
      rtmConC.SETRANGE (Touroperador           , pwTTOO);
      rtmConC.SETFILTER("Fecha inicio contrato", '<=%1', pwFecha);
      rtmConC.SETFILTER("Fecha final contrato" , '>=%1', pwFecha);
      rtmConC.SETRANGE (Confirmado             , TRUE);
      lwEnc := rtmConC.FINDFIRST;

      // Los contratos de compra en transunion seran genericos por proveedor, sin distincion cliente-touroperador
      // A no ser que calculemos los TTOOs por separado en cuyo caso tendremos un error.

      IF NOT lwEnc THEN BEGIN
        IF (rPar."Empresa Real" IN [rPar."Empresa Real"::TRN, rPar."Empresa Real"::CNT]) AND NOT wCosteTTOOSeparados THEN BEGIN
          rtmConC.SETRANGE (Cliente);
          rtmConC.SETRANGE (Touroperador);
          lwEnc := rtmConC.FINDFIRST;
        END;
      END;

      IF lwEnc THEN
        prTmConC := rtmConC
      ELSE
        lwEnc := InsertaContratoCompra(prTmConC,pwProveedor,pwTTOO,pwCliente,pwFecha,pwGaraje);

      IF lwEnc THEN
        BuscaPrecisionCompra(prTmConC);

      EXIT(lwEnc);
    END;

    PROCEDURE InsertaContratoCompra@1100253004(VAR prTmConC@1100244000 : TEMPORARY Record 7010408;pwProveedor@1100244001 : Code[20];pwTTOO@1100244002 : Code[10];pwCliente@1100244003 : Code[20];pwFecha@1100244004 : Date;pwGaraje@1100244005 : Code[10]) : Boolean;
    VAR
      lwEnc@1100253000 : Boolean;
      lrConC@1100253001 : Record 7010408;
      lrPrecC@1100253002 : Record 7010409;
      lrZonC@1100253003 : Record 7010404;
      lrMinC@1100253004 : Record 7010407;
    BEGIN
      // InsertaContratoCompra

      // Busca y copia al temporal el contrato de compra a aplicar en funcion de la composicion y de la fecha del servicio.
      // Se supone que el contrato No debe de existir aun en el temporal

      CLEAR(prTmConC);
      CLEAR(rtmConC);

      lwEnc := BuscaContratoCompraReal(lrConC, pwProveedor ,pwTTOO ,pwCliente ,pwFecha ,pwGaraje);

      IF lwEnc THEN BEGIN
        rtmConC := lrConC;
        rtmConC.INSERT;
        prTmConC := rtmConC;

        // Si est  basado en otro contrato, insertamos tambien este otro contrato
        IF lrConC."Basado en contrato n§" <> '' THEN BEGIN
          CLEAR(rtmConC);
          IF rtmConC.GET(lrConC.Garaje,lrConC."Basado en contrato n§") THEN
            EXIT(TRUE)
          ELSE BEGIN
            lrConC.GET(lrConC.Garaje,lrConC."Basado en contrato n§");
            rtmConC:= lrConC;
            rtmConC.INSERT;
          END
        END;

        CLEAR(lrPrecC); // Precios
        CLEAR(rtmPrecC);
        lrPrecC.SETRANGE(Garaje       , lrConC.Garaje);
        lrPrecC.SETRANGE("N§ Contrato", lrConC."N§ Contrato");
        IF lrPrecC.FINDSET THEN BEGIN
          REPEAT
            rtmPrecC := lrPrecC;
            rtmPrecC.INSERT;
          UNTIL lrPrecC.NEXT=0;
        END;

        CLEAR(lrZonC); // Zonas de precio
        lrZonC.SETRANGE(Garaje       , lrConC.Garaje);
        lrZonC.SETRANGE("N§ Contrato", lrConC."N§ Contrato");
        lrZonC.SETRANGE("Tipo contrato", lrZonC."Tipo contrato"::Compra);
        IF lrZonC.FINDSET THEN BEGIN
          REPEAT
            rtmZonaC := lrZonC;
            rtmZonaC.INSERT;
          UNTIL lrZonC.NEXT=0;
        END;

        CLEAR(lrMinC); // Minimos Vehiculo
        lrMinC.SETRANGE(Garaje         , lrConC.Garaje);
        lrMinC.SETRANGE("N§ Contrato"  , lrConC."N§ Contrato");
        lrMinC.SETRANGE("Tipo Contrato", lrMinC."Tipo Contrato"::Compra);
        IF lrMinC.FINDSET THEN BEGIN
          REPEAT
            rtmMinC := lrMinC;
            rtmMinC.INSERT;
          UNTIL lrMinC.NEXT=0;
        END;
      END
      ELSE
        CLEAR(prTmConC);

      EXIT(lwEnc)
    END;

    PROCEDURE BuscaContratoCompraReal@1100253018(VAR prConC@1100244000 : Record 7010408;pwProveedor@1100244001 : Code[20];pwTTOO@1100244002 : Code[10];pwCliente@1100244003 : Code[20];pwFecha@1100244004 : Date;pwGaraje@1100244005 : Code[10]) : Boolean;
    VAR
      lwEnc@1100253000 : Boolean;
    BEGIN
      // BuscaContratoCompraReal
      //
      // Buscar el contrato de compra a utilizar en el parte en funcion del proveedor, cliente-Touroperador y fecha de facturacion.

      rPar.FINDFIRST;

      CLEAR(prConC);

      prConC.SETCURRENTKEY(Proveedor, Cliente, Touroperador, "Fecha inicio contrato", "Fecha final contrato");

      prConC.SETFILTER(Garaje                 , '%1|%2', rPar."Todos los garajes", pwGaraje);
      prConC.SETRANGE (Proveedor              , pwProveedor);
      prConC.SETRANGE (Cliente                , pwCliente);
      prConC.SETRANGE (Touroperador           , pwTTOO);
      prConC.SETFILTER("Fecha inicio contrato", '<=%1', pwFecha);
      prConC.SETFILTER("Fecha final contrato" , '>=%1', pwFecha);
      prConC.SETRANGE (Confirmado             , TRUE);
      lwEnc := prConC.FINDFIRST;

      // Los contratos de compra en transunion seran genericos por proveedor, sin distincion cliente-touroperador
      IF NOT lwEnc THEN BEGIN
        IF (rPar."Empresa Real" IN [rPar."Empresa Real"::TRN, rPar."Empresa Real"::CNT]) AND NOT wCosteTTOOSeparados THEN BEGIN
          prConC.SETRANGE (Cliente);
          prConC.SETRANGE (Touroperador);
          lwEnc := prConC.FINDFIRST;
        END;
      END;

      IF NOT lwEnc THEN
        CLEAR(prConC);

      EXIT(lwEnc);
    END;

    PROCEDURE TraduceZonaCompra@1100253026(prParte@1100244000 : Record 7010360;prConC@1100244001 : TEMPORARY Record 7010408);
    BEGIN
      // TraduceZonaCompra

      // AJF 30/04/08 ** Costes

      rPar.FINDFIRST;

      //  A partir del contrato obtenido y todos los puntos de recogida buscamos la zona de precios a la que corresponde.

      rtmSerPar.RESET;
      rtmSerPar.SETCURRENTKEY("N§ Parte");
      rtmSerPar.SETRANGE("N§ Parte"  , prParte."N§ Parte");

      // AJF 30/04/08 ** Costes
      // No filtro por TTOO en TRANSUNION, van todos con el proveedor.
      // AJF 30/07/08
      // Separamos por TTOO si se indica en el contrato de compra.

      IF (rPar."Empresa Real" <> rPar."Empresa Real"::TRN) AND
         (rPar."Empresa Real" <> rPar."Empresa Real"::CNT) THEN
        rtmSerPar.SETRANGE(Touroperador, prConC.Touroperador)
      ELSE
        IF prConC."Calcular ttoos por separado" THEN
          rtmSerPar.SETRANGE(Touroperador, prConC.Touroperador);

      IF rtmSerPar.FINDSET THEN BEGIN
        REPEAT
          CLEAR(rtmZonaC);
          // Al buscar las zonas habra que chequear que exista para el garaje del servicio o para el garaje TODOS
          rtmZonaC.SETFILTER(Garaje         , '%1|%2', prParte.Garaje, rPar."Todos los garajes");
          rtmZonaC.SETRANGE("N§ Contrato"  , NumeroContratoCompFacturacion(prConC));
          rtmZonaC.SETRANGE("Tipo contrato", rtmZonaC."Tipo contrato"::Compra);

          // AJS 11.06.2008
          // En funcion del contrato la conversion se har  sobre las zonas fisica o sobre los puntos de recogida

          IF prConC."Base para zonas precio" = prConC."Base para zonas precio"::"Zona fisica" THEN
            rtmZonaC.SETRANGE("Codigo Origen"  , rtmSerPar."Zona fisica")
          ELSE
            rtmZonaC.SETRANGE("Codigo Origen"  , rtmSerPar."Punto recogida");

          IF rtmZonaC.FINDFIRST THEN BEGIN
            rtmSerPar."Zona Compra" := rtmZonaC."Zona Precio";
            rtmSerPar.MODIFY;

            CLEAR(rtmZonPre);
            rtmZonPre.SETRANGE("N§ Parte"     , prParte."N§ Parte");
            rtmZonPre.SETRANGE("Tipo contrato", rtmZonPre."Tipo contrato"::Compra);
            rtmZonPre.SETRANGE("N§ Contrato"  , prConC."N§ Contrato");
            rtmZonPre.SETRANGE("Zona Precio"  , rtmZonaC."Zona Precio");
            IF NOT rtmZonPre.FINDFIRST THEN BEGIN
              rtmZonPre."N§ Parte"        := prParte."N§ Parte";
              rtmZonPre."Tipo contrato"   := rtmZonPre."Tipo contrato"::Compra;
              rtmZonPre."N§ Contrato"     := prConC."N§ Contrato";
              rtmZonPre."Zona Precio"     := rtmZonaC."Zona Precio";
              rtmZonPre."N§ viajes"       := prParte."N§ viajes";
              rtmZonPre.Cliente           := prParte.GetClienteEstadistico(prConC.Touroperador); // AJF 24/08/10
              rtmZonPre.TTOO              := prConC.Touroperador;
              rtmZonPre.Fecha             := prParte."Fecha facturacion";
              rtmZonPre."Tipo servicio"   := prParte."Tipo Servicio";
              rtmZonPre."Codigo servicio" := prParte."Codigo Servicio";
              rtmZonPre.Garaje            := prParte.Garaje;
              rtmZonPre.INSERT;
            END;

            // El orden solo se actualiza si el orden la zona no se modifico manualmente
            IF NOT rtmZonPre."Orden modificado manual" THEN
              rtmZonPre.Orden := rtmZonaC.Orden;

            IF NOT rtmZonPre."Pasaje modificado manual" THEN BEGIN
              rtmZonPre."Adultos facturados zona" += rtmSerPar."Adultos transportados" - rtmSerPar."Adultos invitados coste";
              rtmZonPre."Ni¤os facturados zona"   += rtmSerPar."Ni¤os transportados" - rtmSerPar."Ni¤os invitados coste";
              rtmZonPre."Adultos Invitados Zona"  += rtmSerPar."Adultos invitados coste";
              rtmZonPre."Ni¤os Invitados Zona"    += rtmSerPar."Ni¤os invitados coste";
            END;

            rtmZonPre."Adultos Transportados zona" := rtmZonPre."Adultos Transportados zona" + rtmSerPar."Adultos transportados";
            rtmZonPre."Ni¤os Transportados zona"   := rtmZonPre."Ni¤os Transportados zona" + rtmSerPar."Ni¤os transportados";
            rtmZonPre.MODIFY;

          END
          ELSE BEGIN
            // Si el parte es gratuito no se inserta el error. Solo se insertan errores si el parte es facturable

            IF prParte.Facturable THEN BEGIN

              // AJS 11.06.2008
              // El mensaje de error variara en funcion de que el contrato utilice las zonas fisicas como base
              // o utilice los hoteles

              IF prConC."Base para zonas precio" = prConC."Base para zonas precio"::"Zona fisica" THEN
                InsertaError(prParte, STRSUBSTNO(Text025, rtmSerPar."Zona fisica", prConC."N§ Contrato"),
                              rErr.Tipo::Error)
              ELSE
                InsertaError(prParte, STRSUBSTNO(Text039, rtmSerPar."Punto recogida", prConC."N§ Contrato"),
                              rErr.Tipo::Error);

            END;
          END;
        UNTIL rtmSerPar.NEXT = 0;
      END;
    END;

    PROCEDURE DeterminaMinVeh@1103350002(prParte@1103350003 : Record 7010360;pwCon@1103350002 : Code[10];VAR pwPasajeIngreso@1103350006 : Integer);
    VAR
      lrTipSer@1103350001 : Record 7010319;
      lwOK@1103350004 : Boolean;
    BEGIN
      // DeterminaMinVeh
      // Busca si encuentra un minimo por vehiculo/Tipo Servicio

      CLEAR(lrTipSer);
      CLEAR(rtmZonPre);
      rtmZonPre.SETCURRENTKEY("N§ Parte", "Tipo contrato", "N§ Contrato", Orden);

      rtmZonPre.SETRANGE("N§ Parte"     , prParte."N§ Parte");
      rtmZonPre.SETRANGE("Tipo contrato", rtmZonPre."Tipo contrato"::Venta);
      rtmZonPre.SETRANGE("N§ Contrato"  , pwCon);

      lrTipSer.GET(prParte."Tipo Servicio");
      // Buscamos primero si hay alg£n minimo por vehiculo o tipo servicio fijo
      CLEAR(rtmMinC);
      rtmMinC.SETRANGE("N§ Contrato"            , pwCon);
      rtmMinC.SETRANGE("Tipo Contrato"          , rtmMinC."Tipo Contrato"::Venta);
      rtmMinC.SETRANGE("Tipo Servicio Fijo"     , lrTipSer."Tipo fijo");
      rtmMinC.SETRANGE("Tipo Vehiculo"          , prParte."Tipo Vehiculo facturacion");
      IF NOT rtmMinC.FINDFIRST THEN    // Si no lo encontramos para un tipo vehiculo lo buscamos con el tipo vehiculo en blanco
        rtmMinC.SETFILTER("Tipo Vehiculo",'=%1','');
      IF rtmMinC.FINDFIRST AND (rtmMinC.Minimo <> 0) THEN BEGIN
        // Si hubiese dos TTOO y entre los dos no llegan al minimo se le cobra el mismo minimo a los dos

        IF rtmZonPre.FINDSET THEN BEGIN
          lwOK := FALSE;
          REPEAT
            IF NOT rtmZonPre."Pasaje modificado manual" THEN BEGIN
              IF pwPasajeIngreso < rtmMinC.Minimo THEN BEGIN
                rtmZonPre."Adultos facturados zona" += rtmMinC.Minimo - pwPasajeIngreso ;
                rtmZonPre.MODIFY;
                pwPasajeIngreso += rtmMinC.Minimo - pwPasajeIngreso;
                lwOK := TRUE;
              END;
            END;
          UNTIL (rtmZonPre.NEXT=0) OR lwOK;
        END;
      END;
    END;

    PROCEDURE InsertaLinea@10(pwZona@1100244000 : Code[10];pwTipo@1100244001 : 'Base,Suplemento,Manual';pwDivisa@1100244003 : Code[10];pwImporte@1100244004 : Decimal;pwTouroperador@1100244005 : Code[10];pwManual@1100244006 : Boolean;pwConcepto@1100244007 : 'Ingreso,Coste';pwPrecio@1100244008 : Decimal;pwTipoPrecio@1100244009 : 'Pax,Vehiculo';pwContrato@1100244010 : Code[10];pwTipoelemento@1100244011 : Code[10];prParte@1100244012 : Record 7010360;pwPaxesFacturados@1100244013 : Decimal;pwPaxesTransportados@1100244015 : Decimal;pwConceptoFacturacion@1100244026 : Text[30];pwTarifaHoraria@1103355000 : Code[10]);
    VAR
      rPreMal@1100244018 : Record 7010322;
      lrVeh@1103350000 : Record 7010346;
      lwHora@1100244022 : Time;
      lwEsSalidaPrecioCero@1100244024 : Boolean;
      lwNumParteAuxiliar@1100244025 : Code[10];
      lwTipoPrecio@1100253001 : 'Contrato,Maletas';
    BEGIN
      // InsertaLinea
      //
      //  A partir de los parametros insertar una linea en los ficheros de calculo.
      //  Zona precio
      //  Tipo Precio (Base, Suplemento, Manual)
      //  Divisa precio
      //  Importe Linea
      //  Touroperador linea
      //  Linea manual?
      //  pwConcepto
      //  Precio x Pax
      //  Precio x Vehiculo
      //  Contrato
      //  Tipo elemento
      //  Registro de Parte
      //  Pax Facturados
      //  Paxes Transportados
      //  Concepto facturacion

      // AJS 19.05.2008, TNU08003
      //  Tarifa horaria

      // En caso de linea de maletas el campo pwManual indica si el precio es generico o de contrato

      CLEAR(lwTipoPrecio);
      IF pwTipoelemento = rPar."Codigo Maletas" THEN BEGIN
        IF pwManual THEN
          lwTipoPrecio := lwTipoPrecio::Maletas;
        pwManual       := FALSE;
      END;

      CASE prParte."Tipo Calculo" OF
        prParte."Tipo Calculo"::Margen:
        BEGIN
          CLEAR(rtmMar[1]);
          rtmMar[1].Usuario                := USERID;
          rtmMar[1]."N§ Parte"             := prParte."N§ Parte";
          wNLCont +=1; // Contador de numero de linea, No podemos utilizar el Insert(TRUE) al ser un temporal
          rtmMar[1]."N§ Linea" := wNLCont;
          rtmMar[1].INSERT;
          rtmMar[1].Garaje                 := prParte.Garaje;
          rtmMar[1].Fecha                  := prParte."Fecha facturacion";
          rtmMar[1].Cliente                := prParte.Cliente;
          rtmMar[1].Concepto               := pwConcepto;
          rtmMar[1]."Codigo servicio"      := prParte."Codigo Servicio";

          rtmMar[1].VALIDATE("Tipo servicio", prParte."Tipo Servicio");

          IF rtmMar[1].Concepto = rtmMar[1].Concepto::Coste THEN
            rtmMar[1].Proveedor            := prParte.Proveedor;
          rtmMar[1]."Zona Precios"         := pwZona;
          rtmMar[1]."Tipo elemento"        := pwTipoelemento;
          rtmMar[1]."Tipo Vehiculo"        := prParte."Tipo Vehiculo facturacion";
          rtmMar[1].Pax                    := pwPaxesFacturados;
          rtmMar[1]."Pax Real"             := pwPaxesTransportados;
          rtmMar[1].Importe                := pwImporte;
          rtmMar[1]."N§ Contrato"          := pwContrato;
          rtmMar[1].Touroperador           := pwTouroperador;
          rtmMar[1]."Precio manual"        := pwManual;

          // Extraer los importes con y sin impuesto a partir del importe y dependiendo de si en
          // el contrato se ha especificado que los precios son impuestos incluidos o no.
          // En caso de que sea una linea de maletas hacemos la comprobacion de si es un precio
          // generico o de contrato para pasarle esa informacion al calculo de IVA

          IF rtmMar[1].Concepto = rtmMar[1].Concepto::Ingreso THEN
            CalcularIvaIngreso(rtmMar[1], rtmProdIng[1], prParte, lwTipoPrecio)
          ELSE
            CalcularIvaCoste(rtmMar[1], rtmProdCoste[1], prParte, lwTipoPrecio);

          rtmMar[1]."Origen/Destino"       := prParte."Origen/Destino";
          CASE pwTipoPrecio OF
            pwTipoPrecio::Pax       : rtmMar[1]."Precio Pax"      := pwPrecio;
            pwTipoPrecio::Vehiculo  : rtmMar[1]."Precio Vehiculo" := pwPrecio;
          END;

          rtmMar[1]."Tipo linea"           := pwTipo;
          rtmMar[1]."Pax Facturados"       := pwPaxesFacturados;
          rtmMar[1]."Pax Transportados"    := pwPaxesTransportados;

          // AJS 19.05.2008, TNU08003
          // Rellenar los campos de tarifa horaria y dia festivo

          rtmMar[1]."Tarifa horaria" := pwTarifaHoraria;
          rtmMar[1]."Dia festivo"    := CompruebaDiaFestivo(rtmMar[1]."N§ Contrato", rtmMar[1].Fecha);

          //  Si el parte es gratuito no se borran las lineas de precio 0

          IF prParte.Gratuito OR (NOT prParte.Facturable) THEN BEGIN
            rtmMar[1]."Pax Facturados"       := 0;
          END;
          // **
          rtmMar[1].VALIDATE("Cod. Divisa" , pwDivisa);
          IF  (rtmMar[1].Importe <> 0) OR (rtmMar[1]."Pax Transportados" <> 0) OR prParte.Gratuito OR (NOT prParte.Facturable) THEN
            rtmMar[1].MODIFY
          ELSE
            rtmMar[1].DELETE;
        END;

        prParte."Tipo Calculo"::Confirmacion:
        BEGIN

          IF pwConcepto = pwConcepto::Ingreso THEN
            InsertaProduccionIngreso(pwZona, pwTipo, pwDivisa, pwImporte, pwTouroperador, pwManual, pwPrecio,
                                     pwTipoPrecio, pwContrato, pwTipoelemento, prParte, pwPaxesFacturados, pwPaxesTransportados,
                                     pwConceptoFacturacion)
          ELSE
            InsertaProduccionCoste(pwZona, pwTipo, pwDivisa, pwImporte, pwTouroperador, pwManual, pwPrecio,
                                   pwTipoPrecio, pwContrato, pwTipoelemento, prParte, pwPaxesFacturados, pwPaxesTransportados,
                                   pwConceptoFacturacion, pwTarifaHoraria);
        END;
      END;
    END;

    PROCEDURE InsertaProduccionIngreso@1103355000(pwZona@1103355014 : Code[10];pwTipo@1103355013 : 'Base,Suplemento,Manual';pwDivisa@1103355012 : Code[10];pwImporte@1103355011 : Decimal;pwTouroperador@1103355010 : Code[10];pwManual@1103355009 : Boolean;pwPrecio@1103355007 : Decimal;pwTipoPrecio@1103355006 : 'Pax,Vehiculo';pwContrato@1103355005 : Code[10];pwTipoelemento@1103355004 : Code[10];prParte@1103355003 : Record 7010360;pwPaxesFacturados@1103355002 : Decimal;pwPaxesTransportados@1103355001 : Decimal;pwConceptoFacturacion@1103355000 : Text[30]);
    VAR
      lrVeh@1103355016 : Record 7010346;
      lwHora@1103355015 : Time;
      lwTipoPrecio@1103355008 : 'Contrato,Maletas';
    BEGIN
      // InsertaProduccionIngreso
      //

      // En caso de linea de maletas el campo pwManual indica si el precio es generico o de contrato

      CLEAR(lwTipoPrecio);
      IF pwTipoelemento = rPar."Codigo Maletas" THEN BEGIN
        IF pwManual THEN
          lwTipoPrecio := lwTipoPrecio::Maletas;
        pwManual       := FALSE;
      END;

      wNLCont +=1; // Contador de numero de linea, No podemos utilizar el Insert(TRUE) al ser un temporal

      rtmProdIng[1].RESET;
      rtmProdIng[1]."N§ Parte" := prParte."N§ Parte";
      rtmProdIng[1]."N§ Linea" := wNLCont;
      rtmProdIng[1].INSERT;

      rtmProdIng[1].Garaje                := prParte.Garaje;
      rtmProdIng[1].Fecha                 := prParte."Fecha facturacion";
      rtmProdIng[1]."Cliente Operativo"   := prParte.Cliente;
      rtmProdIng[1]."Cliente estadistico" := prParte.GetClienteEstadistico(pwTouroperador);
      rtmProdIng[1].Touroperador          := pwTouroperador;
      rtmProdIng[1]."Codigo servicio"     := prParte."Codigo Servicio";

      rtmProdIng[1].VALIDATE("Tipo servicio", prParte."Tipo Servicio");

      rtmProdIng[1].Vuelos  := VuelosParteTouroperador(prParte."N§ Parte", pwTouroperador, lwHora);
      rtmProdIng[1]."Hora vuelo" := lwHora;

      //  Si se ha indicado un proveedor en el parte de trabajo se marca el servicio como no propio

      rtmProdIng[1]."Servicio propio" := (prParte.Proveedor = '');

      // Modificado por la migracion de IBZ para marcar como servicio no propio si el vehiculo no es propio
      // aunque no tengan proveedor

      IF lrVeh.GET(prParte.Vehiculo) THEN
        rtmProdIng[1]."Servicio propio" := lrVeh."Vehiculo propio";

      rtmProdIng[1]."Zona Precios"         := pwZona;

      // AJS 23.06.2008, TNU08002
      // La zona de facturacion se rellena en funcion del contrato
      //rtmProdIng[1]."Zona facturacion"     := prParte."Zona trabajo";

      rtmProdIng[1]."Zona facturacion"     := BuscaZonaFacturacion(pwContrato, pwZona, rtmProdIng[1]."Tipo Servicio Fijo");

      rtmProdIng[1]."Concepto facturacion" := pwConceptoFacturacion;
      rtmProdIng[1]."Tipo elemento"        := pwTipoelemento;
      rtmProdIng[1]."Tipo Vehiculo"        := prParte."Tipo Vehiculo facturacion";
      rtmProdIng[1].Vehiculo               := prParte.Vehiculo;
      rtmProdIng[1].Pax                    := pwPaxesFacturados;
      rtmProdIng[1]."Pax Real"             := pwPaxesTransportados;
      rtmProdIng[1].Importe                := pwImporte;
      rtmProdIng[1]."N§ Contrato"          := pwContrato;
      rtmProdIng[1].Facturable             := prParte.Facturable;
      // **
      CASE pwTipoPrecio OF
        pwTipoPrecio::Pax       : rtmProdIng[1]."Precio Pax"      := pwPrecio;
        pwTipoPrecio::Vehiculo  : rtmProdIng[1]."Precio Vehiculo" := pwPrecio;
      END;

      rtmProdIng[1].Referencia           := prParte.Referencia;
      rtmProdIng[1].Gratuito             := prParte.Gratuito;
      rtmProdIng[1]."Fecha Confirmacion" := prParte."Fecha Confirmacion";

      // Codigos de servicio regular o grupo

      rtmProdIng[1]."Cod Grupo"         := prParte."Cod Grupo";
      rtmProdIng[1]."Servicio Regular"  := prParte."No Servicio Regular";
      rtmProdIng[1]."Precio manual"     := pwManual;

      // Extraer los importes con y sin impuesto a partir del importe y dependiendo de si en
      // el contrato se ha especificado que los precios son impuestos incluidos o no.

      CalcularIvaIngreso(rtmMar[1], rtmProdIng[1], prParte, lwTipoPrecio);

      rtmProdIng[1]."Origen/Destino"       := prParte."Origen/Destino";
      rtmProdIng[1]."Tipo linea"           := pwTipo;
      rtmProdIng[1]."Pax Facturados"       := pwPaxesFacturados;
      rtmProdIng[1]."Pax Transportados"    := pwPaxesTransportados;

      //prParte.CALCFIELDS("Adultos transportados","Ni¤os transportados");

      rtmProdIng[1]."Paxes Servicio" := prParte."Adultos trans. soporte" + prParte."Ni¤os trans. soporte";

      // Los partes no facturables que no sean gratuitos no tienen que calcular importes para no desbaratar las estadisticas

      IF NOT prParte.Facturable THEN BEGIN
        IF NOT prParte.Gratuito THEN BEGIN
          rtmProdIng[1].Importe                         := 0;
          rtmProdIng[1]."Importe sin impuesto"          := 0;
          rtmProdIng[1]."Importe con impuesto"          := 0;
          rtmProdIng[1]."Precio Pax"                    := 0;
          rtmProdIng[1]."Precio Vehiculo"               := 0;
          rtmProdIng[1]."Precio Pax sin impuestos"      := 0;
          rtmProdIng[1]."Precio Vehiculo sin impuestos" := 0;
        END;
        rtmProdIng[1]."Pax Facturados" := 0;
      END;

      rtmProdIng[1].VALIDATE("Cod. Divisa", pwDivisa);

      IF (rtmProdIng[1].Importe <> 0) OR (rtmProdIng[1]."Pax Transportados" <> 0) OR (NOT prParte.Facturable) THEN
        rtmProdIng[1].MODIFY
      ELSE
        rtmProdIng[1].DELETE;
    END;

    PROCEDURE InsertaProduccionCoste@1103355001(pwZona@1103355014 : Code[10];pwTipo@1103355013 : 'Base,Suplemento,Manual';pwDivisa@1103355012 : Code[10];pwImporte@1103355011 : Decimal;pwTouroperador@1103355010 : Code[10];pwManual@1103355009 : Boolean;pwPrecio@1103355007 : Decimal;pwTipoPrecio@1103355006 : 'Pax,Vehiculo';pwContrato@1103355005 : Code[10];pwTipoelemento@1103355004 : Code[10];prParte@1103355003 : Record 7010360;pwPaxesFacturados@1103355002 : Decimal;pwPaxesTransportados@1103355001 : Decimal;pwConceptoFacturacion@1103355000 : Text[30];pwTarifaHoraria@1103355017 : Code[10]);
    VAR
      lrVeh@1103355016 : Record 7010346;
      lwHora@1103355015 : Time;
      lwTipoPrecio@1103355008 : 'Contrato,Maletas';
    BEGIN
      // InsertaProduccionCoste

      // AJS 19.05.2008, TNU08003
      // Tarifa horaria

      // AJF 12/05/08
      rPar.FINDFIRST;

      // En caso de linea de maletas el campo pwManual indica si el precio es generico o de contrato

      CLEAR(lwTipoPrecio);
      IF pwTipoelemento = rPar."Codigo Maletas" THEN BEGIN
        IF pwManual THEN
          lwTipoPrecio := lwTipoPrecio::Maletas;
        pwManual       := FALSE;
      END;

      wNLCont +=1; // Contador de numero de linea, No podemos utilizar el Insert(TRUE) al ser un temporal

      rtmProdCoste[1].RESET;
      rtmProdCoste[1]."N§ Parte" := prParte."N§ Parte";
      rtmProdCoste[1]."N§ Linea" := wNLCont;
      rtmProdCoste[1].INSERT;

      rtmProdCoste[1].Garaje            := prParte.Garaje;
      rtmProdCoste[1].Fecha             := prParte."Fecha facturacion";
      rtmProdCoste[1].Cliente           := prParte.Cliente;
      rtmProdCoste[1].Touroperador      := pwTouroperador;
      rtmProdCoste[1]."Codigo servicio" := prParte."Codigo Servicio";

      rtmProdCoste[1].VALIDATE("Tipo servicio", prParte."Tipo Servicio");

      rtmProdCoste[1].Vuelos       := VuelosParteTouroperador(prParte."N§ Parte", pwTouroperador,lwHora);
      rtmProdCoste[1]."Hora vuelo" := lwHora;
      rtmProdCoste[1].Proveedor    := prParte.Proveedor;

      //  Si se ha indicado un proveedor en el parte de trabajo se marca el servicio como no propio

      rtmProdCoste[1]."Servicio propio" := (prParte.Proveedor = '');

      // Modificado por la migracion de IBZ para marcar como servicio no propio si el vehiculo no es propio aunque no tengan proveedor

      IF lrVeh.GET(prParte.Vehiculo) THEN
        rtmProdCoste[1]."Servicio propio" := lrVeh."Vehiculo propio";

      rtmProdCoste[1]."Zona Precios"         := pwZona;
      rtmProdCoste[1]."Zona facturacion"     := prParte."Zona trabajo";
      rtmProdCoste[1]."Concepto facturacion" := pwConceptoFacturacion;
      rtmProdCoste[1]."Tipo elemento"        := pwTipoelemento;
      rtmProdCoste[1]."Tipo Vehiculo"        := prParte."Tipo Vehiculo facturacion";
      rtmProdCoste[1].Vehiculo               := prParte.Vehiculo;
      rtmProdCoste[1].Pax                    := pwPaxesFacturados;
      rtmProdCoste[1]."Pax Real"             := pwPaxesTransportados;
      rtmProdCoste[1].Importe                := pwImporte;
      rtmProdCoste[1]."N§ Contrato"          := pwContrato;
      rtmProdCoste[1].Facturable             := prParte.Facturable;

      CASE pwTipoPrecio OF
        pwTipoPrecio::Pax       : rtmProdCoste[1]."Precio Pax"      := pwPrecio;
        pwTipoPrecio::Vehiculo  : rtmProdCoste[1]."Precio Vehiculo" := pwPrecio;
      END;

      rtmProdCoste[1].Referencia           := prParte.Referencia;
      rtmProdCoste[1].Gratuito             := prParte.Gratuito;
      rtmProdCoste[1]."Fecha Confirmacion" := prParte."Fecha Confirmacion";

      // Codigos de servicio regular o grupo

      rtmProdCoste[1]."Cod Grupo"        := prParte."Cod Grupo";
      rtmProdCoste[1]."Servicio Regular" := prParte."No Servicio Regular";
      rtmProdCoste[1]."Precio manual"    := pwManual;

      // Extraer los importes con y sin impuesto a partir del importe y dependiendo de si en
      // el contrato se ha especificado que los precios son impuestos incluidos o no.

      CalcularIvaCoste(rtmMar[1], rtmProdCoste[1], prParte, lwTipoPrecio);

      rtmProdCoste[1]."Origen/Destino"    := prParte."Origen/Destino";
      rtmProdCoste[1]."Tipo linea"        := pwTipo;
      rtmProdCoste[1]."Pax Facturados"    := pwPaxesFacturados;
      rtmProdCoste[1]."Pax Transportados" := pwPaxesTransportados;

      //prParte.CALCFIELDS("Adultos transportados","Ni¤os transportados");

      rtmProdCoste[1]."Paxes Servicio" := prParte."Adultos trans. soporte" + prParte."Ni¤os trans. soporte";

      // Si el parte es gratuito no se borran las lineas de precio 0

      // AJF 12/05/08

      IF rPar."Empresa Real" <> rPar."Empresa Real"::TRN THEN
        IF NOT prParte.Facturable THEN
        BEGIN
          IF NOT prParte.Gratuito THEN
          BEGIN
            rtmProdCoste[1].Importe                         := 0;
            rtmProdCoste[1]."Importe sin impuesto"          := 0;
            rtmProdCoste[1]."Importe con impuesto"          := 0;
            rtmProdCoste[1]."Precio Pax"                    := 0;
            rtmProdCoste[1]."Precio Vehiculo"               := 0;
            rtmProdCoste[1]."Precio Pax sin impuestos"      := 0;
            rtmProdCoste[1]."Precio Vehiculo sin impuestos" := 0;
          END;
          rtmProdCoste[1]."Pax Facturados" := 0;
        END;

      rtmProdCoste[1].VALIDATE("Cod. Divisa" , pwDivisa);

      // AJS 19.05.2008, TNU08003

      rtmProdCoste[1]."Tarifa horaria" := pwTarifaHoraria;
      rtmProdCoste[1]."Dia festivo"    := CompruebaDiaFestivo(rtmProdCoste[1]."N§ Contrato", rtmProdCoste[1].Fecha);

      IF (rtmProdCoste[1].Importe <> 0) OR (rtmProdCoste[1]."Pax Transportados" <> 0) OR (NOT prParte.Facturable) THEN
        rtmProdCoste[1].MODIFY
      ELSE
        rtmProdCoste[1].DELETE;
    END;

    PROCEDURE CalcularIvaIngreso@1100253012(VAR prMar@1100244000 : TEMPORARY Record 7010412;VAR prProdIng@1100244001 : TEMPORARY Record 7035392;prParte@1100244002 : Record 7010360;pwTipoPrecio@1100253002 : 'Contrato,Maletas');
    VAR
      rPro@1100244004 : Record 23;
      rCli@1100244005 : Record 18;
      rCliFact@1100244006 : Record 18;
      lrConfIVA@1100244009 : Record 325;
      rTo@1100244010 : Record 7010312;
      rComp@1100244011 : Record 7010313;
      lrPreMal@1100244012 : Record 7010322;
      lwGrRgIvaNEG@1100253003 : Code[10];
      lwGrRgIvaPRO@1100253004 : Code[10];
      lwImporte@1100253005 : ARRAY [3] OF Decimal;
      lwPrecio@1100253006 : ARRAY [3] OF Decimal;
      lwPorcenIVA@1100253007 : Decimal;
      lwConcepto@1100253000 : 'Ingreso,Coste';
      lwCodClient@1100253008 : Code[20];
      lwTTOO@1100253016 : Code[10];
      lwCodProv@1100253009 : Code[20];
      lwContrato@1100253011 : Code[10];
      lwTipoElem@1100253012 : Code[10];
      lwGaraje@1100253014 : Code[10];
      lwCalcular@1100253013 : Boolean;
      lwMaletasExentas@1100253015 : Boolean;
      lwEnc@1100253017 : Boolean;
      lwPrecioPor@1100253018 : 'Pax,Vehiculo';
      lwImpuestoIncluidos@1100253020 : Boolean;
      lwPrecioManual@1100253019 : Boolean;
      lwMaletasInc@1100253021 : Boolean;
      lwPrecision@1100253022 : Decimal;
    BEGIN
      // CalcularIvaIngreso

      // Los campos lwImporte y lwPrecio tienen 3  dimensiones 1= Normal, 2= Sin Impuesto, 3= Con impuesto

      CLEAR(lwImporte);
      CLEAR(lwPrecio);
      CLEAR(lwGrRgIvaNEG);
      CLEAR(lwGrRgIvaPRO);
      CLEAR(lwPorcenIVA);
      CLEAR(lwPrecioPor);

      lwCalcular := TRUE;
      CASE prParte."Tipo Calculo" OF
        prParte."Tipo Calculo"::Margen: BEGIN
          lwImporte[1]   := prMar.Importe;
          lwConcepto     := prMar.Concepto;
          lwCodClient    := prMar.Cliente;
          lwTTOO         := prMar.Touroperador;
          lwCodProv      := prMar.Proveedor;
          lwContrato     := prMar."N§ Contrato";
          lwTipoElem     := prMar."Tipo elemento";
          lwGaraje       := prMar.Garaje;
          lwPrecioManual := prMar."Precio manual";
          IF prMar."Precio Pax" = 0 THEN
            lwPrecioPor := lwPrecioPor::Vehiculo;
          CASE lwPrecioPor OF
            lwPrecioPor::Pax     : lwPrecio[1] := prMar."Precio Pax";
            lwPrecioPor::Vehiculo: lwPrecio[1] := prMar."Precio Vehiculo";
          END;
        END;

        prParte."Tipo Calculo"::Confirmacion: BEGIN
          lwImporte[1]   := prProdIng.Importe;
          lwCodClient    := prProdIng."Cliente Operativo";
          lwTTOO         := prProdIng.Touroperador;
          lwContrato     := prProdIng."N§ Contrato";
          lwTipoElem     := prProdIng."Tipo elemento";
          lwGaraje       := prProdIng.Garaje;
          lwPrecioManual := prProdIng."Precio manual";

          IF prProdIng."Precio Pax" = 0 THEN
            lwPrecioPor := lwPrecioPor::Vehiculo;

          CASE lwPrecioPor OF
            lwPrecioPor::Pax     : lwPrecio[1] := prProdIng."Precio Pax";
            lwPrecioPor::Vehiculo: lwPrecio[1] := prProdIng."Precio Vehiculo";
          END;
        END;
      END;

      CASE lwConcepto OF
        lwConcepto::Coste : BEGIN
          IF lwCodProv = '' THEN
            InsertaError(prParte, Text009, rErr.Tipo::Error)
          ELSE BEGIN
            IF NOT rPro.GET(lwCodProv) THEN
              InsertaError(prParte, Text010, rErr.Tipo::Error);
          END;
          lwGrRgIvaNEG := rPro."VAT Bus. Posting Group";

          IF lwContrato <> '' THEN BEGIN
            CLEAR(rtmConC);
            rtmConC.SETFILTER(Garaje       , '%1|%2', lwGaraje, rPar."Todos los garajes");
            rtmConC.SETRANGE ("N§ Contrato", lwContrato);
            IF NOT rtmConC.FINDFIRST THEN
              InsertaError(prParte, STRSUBSTNO(Text011, prMar."N§ Contrato", lwGaraje), rErr.Tipo::Error);
            lwPrecision         := wPrecisionCoste;
            lwGrRgIvaPRO        := rtmConC."Grupo Registro IVA Producto";
            lwMaletasExentas    := rtmConC."Maletas exentas";
            lwImpuestoIncluidos := rtmConC."Impuestos incluidos";
            lwMaletasInc        := rtmConC."Maletas incluidas";
          END;
        END;
        lwConcepto::Ingreso : BEGIN
          IF lwCodClient = '' THEN
            InsertaError(prParte, Text013, rErr.Tipo::Error)
          ELSE
            IF NOT rCli.GET(lwCodClient) THEN
              InsertaError(prParte, Text014, rErr.Tipo::Error);
          IF lwTTOO = '' THEN
            InsertaError(prParte, Text016, rErr.Tipo::Error)
          ELSE BEGIN
            IF NOT rTo.GET(lwTTOO) THEN
              InsertaError(prParte, STRSUBSTNO(Text017, lwTTOO), rErr.Tipo::Error);
            IF NOT rComp.GET(lwCodClient, lwTTOO) THEN
              InsertaError(prParte, STRSUBSTNO(Text018, lwCodClient, lwTTOO),rErr.Tipo::Error)
            ELSE
              IF NOT rCliFact.GET(rComp."Cliente facturacion") THEN
                InsertaError(prParte, STRSUBSTNO(Text019, rComp."Cliente facturacion"), rErr.Tipo::Error);
          END;
          lwGrRgIvaNEG := rCliFact."VAT Bus. Posting Group";

          IF lwContrato <> '' THEN BEGIN
            CLEAR(rtmConV);
            rtmConV.SETFILTER(Garaje       , '%1|%2', lwGaraje, rPar."Todos los garajes");
            rtmConV.SETRANGE ("N§ Contrato", lwContrato);
            IF NOT rtmConV.FINDFIRST THEN
              InsertaError(prParte, STRSUBSTNO(Text015, lwContrato, lwGaraje), rErr.Tipo::Error);
            lwPrecision         := wPrecisionIngreso;
            lwGrRgIvaPRO        := rtmConV."Grupo Registro IVA Producto";
            lwMaletasExentas    := rtmConV."Maletas exentas";
            lwImpuestoIncluidos := rtmConV."Impuestos incluidos";
            lwMaletasInc        := rtmConV."Maletas incluidas";
          END;
        END;
      END;

      IF lwPrecioManual AND (lwGrRgIvaPRO='') THEN  // precios manuales
        lwGrRgIvaPRO := rPar."Grupo Registro IVA Producto";

      // En caso de Maletas con precio generico
      IF lwTipoElem = rPar."Codigo Maletas" THEN BEGIN
        lwCalcular   := NOT lwMaletasExentas;
        lwGrRgIvaPRO := rPar."Grupo Registro IVA Maletas";
        IF (pwTipoPrecio = pwTipoPrecio::Maletas) THEN BEGIN  // Precio Generico Maletas
          IF NOT lwMaletasInc THEN BEGIN // Si la maleta no est  incluida en el precio
            BuscaPrecioMaletas(lrPreMal, prParte);
            lwImpuestoIncluidos := lrPreMal."Impuestos incluidos";
          END;
        END;
      END;

      IF lwCalcular THEN BEGIN
        lwEnc:= lrConfIVA.GET (lwGrRgIvaNEG, lwGrRgIvaPRO);

        IF NOT lwEnc THEN BEGIN
          InsertaError(prParte, STRSUBSTNO(Text012, lwGrRgIvaNEG, lwGrRgIvaPRO), rErr.Tipo::Error);
          CLEAR(lrConfIVA);
        END;

        IF lwEnc THEN BEGIN
          IF lwImpuestoIncluidos THEN BEGIN
            lwImporte[2]  := ROUND(lwImporte[1] / (1 + (lrConfIVA."VAT+EC %" / 100)), lwPrecision);
            lwPrecio[2]   := ROUND(lwPrecio[1] / (1 + (lrConfIVA."VAT+EC %" / 100)) , lwPrecision);
            lwPrecio[3]   := lwPrecio[1];
            lwImporte[3]  := lwImporte[1];
          END
          ELSE BEGIN
            lwImporte[3]  := ROUND(lwImporte[1] * (1 + (lrConfIVA."VAT+EC %" / 100)), lwPrecision);
            lwPrecio[3]   := ROUND(lwPrecio[1] * (1 + (lrConfIVA."VAT+EC %" / 100)) , lwPrecision);
            lwImporte[2]  := lwImporte[1];
            lwPrecio[2]   := lwPrecio[1];
          END;
          lwPorcenIVA := lrConfIVA."VAT+EC %";
        END;
      END
      ELSE BEGIN  // Si no calculamos
        lwImporte[2] := lwImporte[1];
        lwImporte[3] := lwImporte[1];
        lwPrecio[2]  := lwPrecio[1];
        lwPrecio[3]  := lwPrecio[1];
      END;

      CASE prParte."Tipo Calculo" OF
        prParte."Tipo Calculo"::Margen: BEGIN
          prMar."Importe sin impuesto" := lwImporte[2];
          prMar."Importe con impuesto" := lwImporte[3];
          prMar."% IVA"                := lwPorcenIVA;
        END;
        prParte."Tipo Calculo"::Confirmacion: BEGIN
          prProdIng."Importe sin impuesto" := lwImporte[2];
          prProdIng."Importe con impuesto" := lwImporte[3];
          prProdIng."Impuestos Incluidos"  := lwImpuestoIncluidos;
          CASE lwPrecioPor OF
            lwPrecioPor::Pax : BEGIN
              prProdIng."Precio Pax"              := lwPrecio[3];
              prProdIng."Precio Pax sin impuestos":= lwPrecio[2];
            END;
            lwPrecioPor::Vehiculo: BEGIN
              prProdIng."Precio Vehiculo"               := lwPrecio[3];
              prProdIng."Precio Vehiculo sin impuestos" := lwPrecio[2];
            END;
          END;
          prProdIng."% IVA"                       := lwPorcenIVA;
          prProdIng."Grupo registro IVA Producto" := lwGrRgIvaPRO;
        END;
      END;
    END;

    PROCEDURE CalcularIvaCoste@1103355020(VAR prMar@1100244000 : TEMPORARY Record 7010412;VAR prProdCoste@1100244001 : TEMPORARY Record 7035393;prParte@1100244002 : Record 7010360;pwTipoPrecio@1100253002 : 'Contrato,Maletas');
    VAR
      rPro@1100244004 : Record 23;
      rCli@1100244005 : Record 18;
      rCliFact@1100244006 : Record 18;
      lrConfIVA@1100244009 : Record 325;
      rTo@1100244010 : Record 7010312;
      rComp@1100244011 : Record 7010313;
      lrPreMal@1100244012 : Record 7010322;
      lwGrRgIvaNEG@1100253003 : Code[10];
      lwGrRgIvaPRO@1100253004 : Code[10];
      lwImporte@1100253005 : ARRAY [3] OF Decimal;
      lwPrecio@1100253006 : ARRAY [3] OF Decimal;
      lwPorcenIVA@1100253007 : Decimal;
      lwConcepto@1100253000 : 'Ingreso,Coste';
      lwCodClient@1100253008 : Code[20];
      lwTTOO@1100253016 : Code[10];
      lwCodProv@1100253009 : Code[20];
      lwContrato@1100253011 : Code[10];
      lwTipoElem@1100253012 : Code[10];
      lwGaraje@1100253014 : Code[10];
      lwCalcular@1100253013 : Boolean;
      lwMaletasExentas@1100253015 : Boolean;
      lwEnc@1100253017 : Boolean;
      lwPrecioPor@1100253018 : 'Pax,Vehiculo';
      lwImpuestoIncluidos@1100253020 : Boolean;
      lwPrecioManual@1100253019 : Boolean;
      lwMaletasInc@1100253021 : Boolean;
      lwPrecision@1100253022 : Decimal;
    BEGIN
      // CalcularIvaCoste

      // Los campos lwImporte y lwPrecio tienen 3  dimensiones 1= Normal, 2= Sin Impuesto, 3= Con impuesto

      CLEAR(lwImporte);
      CLEAR(lwPrecio);
      CLEAR(lwGrRgIvaNEG);
      CLEAR(lwGrRgIvaPRO);
      CLEAR(lwPorcenIVA);
      CLEAR(lwPrecioPor);

      lwCalcular := TRUE;
      CASE prParte."Tipo Calculo" OF
        prParte."Tipo Calculo"::Margen: BEGIN
          lwImporte[1]   := prMar.Importe;
          lwConcepto     := prMar.Concepto;
          lwCodClient    := prMar.Cliente;
          lwTTOO         := prMar.Touroperador;
          lwCodProv      := prMar.Proveedor;
          lwContrato     := prMar."N§ Contrato";
          lwTipoElem     := prMar."Tipo elemento";
          lwGaraje       := prMar.Garaje;
          lwPrecioManual := prMar."Precio manual";
          IF prMar."Precio Pax" = 0 THEN
            lwPrecioPor := lwPrecioPor::Vehiculo;
          CASE lwPrecioPor OF
            lwPrecioPor::Pax     : lwPrecio[1] := prMar."Precio Pax";
            lwPrecioPor::Vehiculo: lwPrecio[1] := prMar."Precio Vehiculo";
          END;
        END;

        prParte."Tipo Calculo"::Confirmacion: BEGIN
          lwImporte[1]   := prProdCoste.Importe;
          lwCodClient    := prProdCoste.Cliente;
          lwTTOO         := prProdCoste.Touroperador;
          lwCodProv      := prProdCoste.Proveedor;
          lwContrato     := prProdCoste."N§ Contrato";
          lwTipoElem     := prProdCoste."Tipo elemento";
          lwGaraje       := prProdCoste.Garaje;
          lwPrecioManual := prProdCoste."Precio manual";

          lwConcepto     := lwConcepto::Coste;

          IF prProdCoste."Precio Pax" = 0 THEN
            lwPrecioPor := lwPrecioPor::Vehiculo;

          CASE lwPrecioPor OF
            lwPrecioPor::Pax     : lwPrecio[1] := prProdCoste."Precio Pax";
            lwPrecioPor::Vehiculo: lwPrecio[1] := prProdCoste."Precio Vehiculo";
          END;
        END;
      END;

      CASE lwConcepto OF
        lwConcepto::Coste : BEGIN
          IF lwCodProv = '' THEN
            InsertaError(prParte, Text009, rErr.Tipo::Error)
          ELSE BEGIN
            IF NOT rPro.GET(lwCodProv) THEN
              InsertaError(prParte, Text010, rErr.Tipo::Error);
          END;
          lwGrRgIvaNEG := rPro."VAT Bus. Posting Group";

          IF lwContrato <> '' THEN BEGIN
            CLEAR(rtmConC);
            rtmConC.SETFILTER(Garaje       , '%1|%2', lwGaraje, rPar."Todos los garajes");
            rtmConC.SETRANGE ("N§ Contrato", lwContrato);
            IF NOT rtmConC.FINDFIRST THEN
              InsertaError(prParte, STRSUBSTNO(Text011, prMar."N§ Contrato", lwGaraje), rErr.Tipo::Error);
            lwPrecision         := wPrecisionCoste;
            lwGrRgIvaPRO        := rtmConC."Grupo Registro IVA Producto";
            lwMaletasExentas    := rtmConC."Maletas exentas";
            lwImpuestoIncluidos := rtmConC."Impuestos incluidos";
            lwMaletasInc        := rtmConC."Maletas incluidas";
          END;
        END;
        lwConcepto::Ingreso : BEGIN
          IF lwCodClient = '' THEN
            InsertaError(prParte, Text013, rErr.Tipo::Error)
          ELSE
            IF NOT rCli.GET(lwCodClient) THEN
              InsertaError(prParte, Text014, rErr.Tipo::Error);
          IF lwTTOO = '' THEN
            InsertaError(prParte, Text016, rErr.Tipo::Error)
          ELSE BEGIN
            IF NOT rTo.GET(lwTTOO) THEN
              InsertaError(prParte, STRSUBSTNO(Text017, lwTTOO), rErr.Tipo::Error);
            IF NOT rComp.GET(lwCodClient, lwTTOO) THEN
              InsertaError(prParte, STRSUBSTNO(Text018, lwCodClient, lwTTOO),rErr.Tipo::Error)
            ELSE
              IF NOT rCliFact.GET(rComp."Cliente facturacion") THEN
                InsertaError(prParte, STRSUBSTNO(Text019, rComp."Cliente facturacion"), rErr.Tipo::Error);
          END;
          lwGrRgIvaNEG := rCliFact."VAT Bus. Posting Group";

          IF lwContrato <> '' THEN BEGIN
            CLEAR(rtmConV);
            rtmConV.SETFILTER(Garaje       , '%1|%2', lwGaraje, rPar."Todos los garajes");
            rtmConV.SETRANGE ("N§ Contrato", lwContrato);
            IF NOT rtmConV.FINDFIRST THEN
              InsertaError(prParte, STRSUBSTNO(Text015, lwContrato, lwGaraje), rErr.Tipo::Error);
            lwPrecision         := wPrecisionIngreso;
            lwGrRgIvaPRO        := rtmConV."Grupo Registro IVA Producto";
            lwMaletasExentas    := rtmConV."Maletas exentas";
            lwImpuestoIncluidos := rtmConV."Impuestos incluidos";
            lwMaletasInc        := rtmConV."Maletas incluidas";
          END;
        END;
      END;

      IF lwPrecioManual THEN  // precios manuales
        lwGrRgIvaPRO := rPar."Grupo Registro IVA Producto";

      // En caso de Maletas con precio generico

      IF lwTipoElem = rPar."Codigo Maletas" THEN BEGIN
        lwCalcular   := NOT lwMaletasExentas;
        lwGrRgIvaPRO := rPar."Grupo Registro IVA Maletas";
        IF (pwTipoPrecio=pwTipoPrecio::Maletas) THEN BEGIN  // Precio Generico Maletas
          IF NOT lwMaletasInc THEN BEGIN // Si la maleta no est  incluida en el precio
            BuscaPrecioMaletas(lrPreMal, prParte);
            lwImpuestoIncluidos := lrPreMal."Impuestos incluidos";
          END;
        END;
      END;

      IF lwCalcular THEN BEGIN
        lwEnc:= lrConfIVA.GET (lwGrRgIvaNEG, lwGrRgIvaPRO);

        IF NOT lwEnc THEN BEGIN
          InsertaError(prParte, STRSUBSTNO(Text012, lwGrRgIvaNEG, lwGrRgIvaPRO), rErr.Tipo::Error);
          CLEAR(lrConfIVA);
        END;

        IF lwEnc THEN BEGIN
          IF lwImpuestoIncluidos THEN BEGIN
            lwImporte[2]  := ROUND(lwImporte[1] / (1 + (lrConfIVA."VAT+EC %" / 100)), lwPrecision);
            lwPrecio[2]   := ROUND(lwPrecio[1] / (1 + (lrConfIVA."VAT+EC %" / 100)) , lwPrecision);
            lwPrecio[3]   := lwPrecio[1];
            lwImporte[3]  := lwImporte[1];
          END
          ELSE BEGIN
            lwImporte[3]  := ROUND(lwImporte[1] * (1 + (lrConfIVA."VAT+EC %" / 100)), lwPrecision);
            lwPrecio[3]   := ROUND(lwPrecio[1] * (1 + (lrConfIVA."VAT+EC %" / 100)) , lwPrecision);
            lwImporte[2]  := lwImporte[1];
            lwPrecio[2]   := lwPrecio[1];
          END;
          lwPorcenIVA := lrConfIVA."VAT+EC %";
        END;
      END
      ELSE BEGIN  // Si no calculamos
        lwImporte[2] := lwImporte[1];
        lwImporte[3] := lwImporte[1];
        lwPrecio[2]  := lwPrecio[1];
        lwPrecio[3]  := lwPrecio[1];
      END;

      CASE prParte."Tipo Calculo" OF
        prParte."Tipo Calculo"::Margen: BEGIN
          prMar."Importe sin impuesto" := lwImporte[2];
          prMar."Importe con impuesto" := lwImporte[3];
          prMar."% IVA"                := lwPorcenIVA;
        END;
        prParte."Tipo Calculo"::Confirmacion: BEGIN
          prProdCoste."Importe sin impuesto" := lwImporte[2];
          prProdCoste."Importe con impuesto" := lwImporte[3];
          prProdCoste."Impuestos Incluidos"  := lwImpuestoIncluidos;
          CASE lwPrecioPor OF
            lwPrecioPor::Pax : BEGIN
              prProdCoste."Precio Pax"              := lwPrecio[3];
              prProdCoste."Precio Pax sin impuestos":= lwPrecio[2];
            END;
            lwPrecioPor::Vehiculo: BEGIN
              prProdCoste."Precio Vehiculo"               := lwPrecio[3];
              prProdCoste."Precio Vehiculo sin impuestos" := lwPrecio[2];
            END;
          END;
          prProdCoste."% IVA" := lwPorcenIVA;
          prProdCoste."Grupo registro IVA Producto" := lwGrRgIvaPRO;
        END;
      END;
    END;

    PROCEDURE DescontarMaletas@37(pwConcepto@1100244000 : 'Ingreso,Coste';prParte@1100244001 : Record 7010360;prToPar@1100244002 : Record 7010365;lwZonaPrecio@1100244003 : Code[10];pwContrato@1100244004 : Code[10]);
    VAR
      wPrecioMaleta@1100244009 : Decimal;
      wPrecioMaletaCon@1100244010 : Decimal;
      wImporteMaleta@1100244011 : Decimal;
      wImporteMaletaCon@1100244012 : Decimal;
      lwImpuestosIncluidos@1100244013 : Boolean;
    BEGIN
      // DescontarMaletas

      //  Para los casos en que por contrato se indique que los precios llevan las maletas
      //  incluidas hay que descontar el precio de las maletas del importe normal. Supondremos que el precio de las maletas
      //  es por Pax.

      CASE pwConcepto OF
        pwConcepto::Coste : BEGIN
          // Al buscar los precios habra que chequear que exista para el garaje del servicio o para el garaje TODOS
          CLEAR(rtmConC);
          rtmConC.SETFILTER(Garaje       , '%1|%2', prParte.Garaje, rPar."Todos los garajes");
          rtmConC.SETRANGE ("N§ Contrato", pwContrato);
          rtmConC.FINDFIRST;
        END;
        pwConcepto::Ingreso : BEGIN
          // Al buscar los precios habra que chequear que exista para el garaje del servicio o para el garaje TODOS
          CLEAR(rtmConV);
          rtmConV.SETFILTER(Garaje       , '%1|%2', prParte.Garaje, rPar."Todos los garajes");
          rtmConV.SETRANGE ("N§ Contrato", pwContrato);
          rtmConV.FINDFIRST;
        END;
      END;

      IF prParte."Tipo Calculo" = prParte."Tipo Calculo"::Margen THEN BEGIN
        CLEAR(rtmMar[1]);
        rtmMar[1].SETRANGE(Usuario        , USERID);
        rtmMar[1].SETRANGE("N§ Parte"     , prParte."N§ Parte");
        rtmMar[1].SETRANGE(Concepto       , pwConcepto);

        rtmMar[1].SETRANGE(Touroperador   , prToPar.Touroperador);
        rtmMar[1].SETRANGE("Zona Precios" , lwZonaPrecio);
        rtmMar[1].SETRANGE("Tipo linea"   , rtmMar[1]."Tipo linea"::Suplemento);
        rtmMar[1].SETRANGE("Tipo elemento", rPar."Codigo Maletas");
        IF rtmMar[1].FINDSET(TRUE) THEN BEGIN
          wPrecioMaleta    := rtmMar[1]."Precio Pax";
          wImporteMaleta   := rtmMar[1].Importe;

          rtmMar[1].SETRANGE("Tipo linea"   , rtmMar[1]."Tipo linea"::Base);
          rtmMar[1].SETRANGE("Tipo elemento");

          // Si la zona sobre la que hay que descontar no tiene paxes a facturar descontaremos sobre la primera linea
          // que tenga paxes a facturar (esto puede ocurrir cuando se utiliza el calculo Zona combinada)

          rtmMar[1].SETFILTER(Importe, '<>%1', 0);
          IF NOT rtmMar[1].FINDFIRST THEN
            rtmMar[1].SETRANGE("Zona Precios");

          IF rtmMar[1].FINDSET(TRUE) THEN BEGIN
            REPEAT
              IF rtmMar[1]."Precio Pax" <> 0 THEN BEGIN
                rtmMar[1]."Precio Pax" := rtmMar[1]."Precio Pax" - wPrecioMaleta;
                rtmMar[1].Importe      := rtmMar[1]."Precio Pax" * rtmMar[1]."Pax Facturados";
              END
              ELSE BEGIN
                rtmMar[1]."Precio Vehiculo" := rtmMar[1]."Precio Vehiculo" - wImporteMaleta;
                rtmMar[1].Importe           := rtmMar[1]."Precio Vehiculo";
              END;

              IF rtmMar[1].Concepto = rtmMar[1].Concepto::Ingreso THEN
                CalcularIvaIngreso(rtmMar[1], rtmProdIng[1], prParte, 0)
              ELSE
                CalcularIvaCoste(rtmMar[1], rtmProdCoste[1], prParte, 0);

              rtmMar[1].VALIDATE("Cod. Divisa", rtmMar[1]."Cod. Divisa");
              rtmMar[1].MODIFY;
            UNTIL rtmMar[1].NEXT=0;
          END;
        END;
      END
      ELSE BEGIN
        IF pwConcepto = pwConcepto::Ingreso THEN BEGIN

          CLEAR(rtmProdIng[1]);
          rtmProdIng[1].SETRANGE("N§ Parte"     , prParte."N§ Parte");
          rtmProdIng[1].SETRANGE("Linea abono"  , FALSE);
          rtmProdIng[1].SETRANGE(Touroperador   , prToPar.Touroperador);
          rtmProdIng[1].SETRANGE("Zona Precios" , lwZonaPrecio);
          rtmProdIng[1].SETRANGE("Tipo linea"   , rtmProdIng[1]."Tipo linea"::Suplemento);
          rtmProdIng[1].SETRANGE("Tipo elemento", rPar."Codigo Maletas");
          IF rtmProdIng[1].FINDFIRST THEN BEGIN

            // Hay que tener en cuenta si hemos indicado que las maletas tienen el IVA includo
            // para saberlo hay que consultar el contrato

            wPrecioMaleta        := rtmProdIng[1]."Precio Pax sin impuestos";
            wPrecioMaletaCon     := rtmProdIng[1]."Precio Pax";
            wImporteMaleta       := rtmProdIng[1]."Importe sin impuesto";
            wImporteMaletaCon    := rtmProdIng[1]."Importe con impuesto";

            lwImpuestosIncluidos := rtmConV."Impuestos incluidos";

            rtmProdIng[1].SETRANGE("Tipo linea", rtmProdIng[1]."Tipo linea"::Base);
            rtmProdIng[1].SETRANGE("Tipo elemento");

            // Si la zona sobre la que hay que descontar no tiene paxes a facturar descontaremos sobre la primera linea
            // que tenga paxes a facturar (esto puede ocurrir cuando se utiliza el calculo Zona combinada)

            rtmProdIng[1].SETFILTER(Importe, '<>%1', 0);
            IF NOT rtmProdIng[1].FINDFIRST THEN
              rtmProdIng[1].SETRANGE("Zona Precios");

            IF rtmProdIng[1].FINDSET(TRUE) THEN BEGIN
              REPEAT
                IF rtmProdIng[1]."Precio Pax" <> 0 THEN BEGIN
                  IF lwImpuestosIncluidos THEN
                    rtmProdIng[1]."Precio Pax" := rtmProdIng[1]."Precio Pax" - wPrecioMaletaCon
                  ELSE
                    rtmProdIng[1]."Precio Pax" := rtmProdIng[1]."Precio Pax sin impuestos" - wPrecioMaleta;

                  rtmProdIng[1].Importe := rtmProdIng[1]."Precio Pax" * rtmProdIng[1]."Pax Facturados";
                END
                ELSE BEGIN
                  IF lwImpuestosIncluidos THEN
                    rtmProdIng[1]."Precio Vehiculo" := rtmProdIng[1]."Precio Vehiculo" - wImporteMaletaCon
                  ELSE
                    rtmProdIng[1]."Precio Vehiculo" := rtmProdIng[1]."Precio Vehiculo sin impuestos" - wImporteMaleta;
                  rtmProdIng[1].Importe := rtmProdIng[1]."Precio Vehiculo";
                END;

                CalcularIvaIngreso(rtmMar[1], rtmProdIng[1], prParte, 0);

                rtmProdIng[1].VALIDATE("Cod. Divisa", rtmProdIng[1]."Cod. Divisa");
                rtmProdIng[1].MODIFY;
              UNTIL rtmProdIng[1].NEXT=0;
            END;
          END;
        END

        // ## Descontar maletas de la produccion de coste
        ELSE BEGIN

          CLEAR(rtmProdCoste[1]);
          rtmProdCoste[1].SETRANGE("N§ Parte"     , prParte."N§ Parte");
          rtmProdCoste[1].SETRANGE("Linea abono"  , FALSE);
          rtmProdCoste[1].SETRANGE(Touroperador   , prToPar.Touroperador);
          rtmProdCoste[1].SETRANGE("Zona Precios" , lwZonaPrecio);
          rtmProdCoste[1].SETRANGE("Tipo linea"   , rtmProdCoste[1]."Tipo linea"::Suplemento);
          rtmProdCoste[1].SETRANGE("Tipo elemento", rPar."Codigo Maletas");
          IF rtmProdCoste[1].FINDFIRST THEN BEGIN
            // Hay que tener en cuenta si hemos indicado que las maletas tienen el IVA includo
            // para saberlo hay que consultar el contrato

            wPrecioMaleta        := rtmProdCoste[1]."Precio Pax sin impuestos";
            wPrecioMaletaCon     := rtmProdCoste[1]."Precio Pax";
            wImporteMaleta       := rtmProdCoste[1]."Importe sin impuesto";
            wImporteMaletaCon    := rtmProdCoste[1]."Importe con impuesto";

            lwImpuestosIncluidos := rtmConC."Impuestos incluidos";

            rtmProdCoste[1].SETRANGE("Tipo linea"   , rtmProdCoste[1]."Tipo linea"::Base);
            rtmProdCoste[1].SETRANGE("Tipo elemento");

            // Si la zona sobre la que hay que descontar no tiene paxes a facturar descontaremos sobre la primera linea
            // que tenga paxes a facturar (esto puede ocurrir cuando se utiliza el calculo Zona combinada)

            rtmProdCoste[1].SETFILTER(Importe, '<>%1', 0);
            IF NOT rtmProdCoste[1].FINDFIRST THEN
              rtmProdCoste[1].SETRANGE("Zona Precios");

            IF rtmProdCoste[1].FINDSET(TRUE) THEN BEGIN
              REPEAT
                IF rtmProdCoste[1]."Precio Pax" <> 0 THEN BEGIN
                  IF lwImpuestosIncluidos THEN
                    rtmProdCoste[1]."Precio Pax" := rtmProdCoste[1]."Precio Pax" - wPrecioMaletaCon
                  ELSE
                    rtmProdCoste[1]."Precio Pax" := rtmProdCoste[1]."Precio Pax sin impuestos" - wPrecioMaleta;

                  rtmProdCoste[1].Importe := rtmProdCoste[1]."Precio Pax" * rtmProdCoste[1]."Pax Facturados";
                END
                ELSE BEGIN
                  IF lwImpuestosIncluidos THEN
                    rtmProdCoste[1]."Precio Vehiculo" := rtmProdCoste[1]."Precio Vehiculo" - wImporteMaletaCon
                  ELSE
                    rtmProdCoste[1]."Precio Vehiculo" := rtmProdCoste[1]."Precio Vehiculo sin impuestos" - wImporteMaleta;

                  rtmProdCoste[1].Importe := rtmProdCoste[1]."Precio Vehiculo";
                END;

                CalcularIvaCoste(rtmMar[1], rtmProdCoste[1], prParte, 0);

                rtmProdCoste[1].VALIDATE("Cod. Divisa", rtmProdCoste[1]."Cod. Divisa");
                rtmProdCoste[1].MODIFY;
              UNTIL rtmProdCoste[1].NEXT = 0;
            END;
          END;
        END;
      END;
    END;

    PROCEDURE SumarIngresoBase@40(prToPar@1100244000 : Record 7010365;prParte@1100244001 : Record 7010360;pwSoloBase@1100244002 : Boolean;pwImpuestosIncluidos@1100244003 : Boolean) : Decimal;
    VAR
      lwTotal@1100253000 : Decimal;
    BEGIN
      // SumarIngresoBase

      //  Simplemente suma las lineas de ingreso base de margen o de coste/ingreso
      //  para en caso de que sea 0 no calcular las maletas. Se aprovecha para los
      //  suplementos varios y para los extras de porcentaje.

      CLEAR(lwTotal);
      IF prParte."Tipo Calculo" = prParte."Tipo Calculo"::Margen THEN BEGIN
        CLEAR(rtmMar[1]);
        rtmMar[1].SETCURRENTKEY(Usuario,"N§ Parte",Touroperador,Concepto,"Tipo linea");
        rtmMar[1].SETRANGE(Usuario     , USERID);
        rtmMar[1].SETRANGE("N§ Parte"  , prToPar."N§ Parte");
        rtmMar[1].SETRANGE(Touroperador, prToPar.Touroperador);
        rtmMar[1].SETRANGE(Concepto    , rtmMar[1].Concepto::Ingreso);
        IF pwSoloBase THEN
          rtmMar[1].SETRANGE("Tipo linea", rtmMar[1]."Tipo linea"::Base);
        IF rtmMar[1].FINDFIRST THEN BEGIN
          IF pwImpuestosIncluidos THEN BEGIN
            rtmMar[1].CALCSUMS("Importe con impuesto");
            lwTotal := rtmMar[1]."Importe con impuesto"
          END
          ELSE BEGIN
            rtmMar[1].CALCSUMS("Importe sin impuesto");
            lwTotal := rtmMar[1]."Importe sin impuesto";
          END;
        END;
      END
      ELSE BEGIN
        CLEAR(rtmProdIng[1]);
        rtmProdIng[1].SETRANGE("N§ Parte"  , prToPar."N§ Parte");
        rtmProdIng[1].SETRANGE(Touroperador, prToPar.Touroperador);
        IF pwSoloBase THEN
          rtmProdIng[1].SETRANGE("Tipo linea", rtmProdIng[1]."Tipo linea"::Base);
        IF rtmProdIng[1].FINDFIRST THEN BEGIN
          IF pwImpuestosIncluidos THEN BEGIN
            rtmProdIng[1].CALCSUMS("Importe con impuesto");
            lwTotal := rtmProdIng[1]."Importe con impuesto"
          END
          ELSE BEGIN
            rtmProdIng[1].CALCSUMS("Importe sin impuesto");
            lwTotal := rtmProdIng[1]."Importe sin impuesto";
          END;
        END;
      END;
      EXIT(lwTotal);
    END;

    PROCEDURE SumarCosteBase@42(prToPar@1100244000 : TEMPORARY Record 7010365;prParte@1100244001 : Record 7010360;pwSoloBase@1100244002 : Boolean;pwImpuestosIncluidos@1100244003 : Boolean) : Decimal;
    VAR
      lwTotal@1100253000 : Decimal;
    BEGIN
      // SumarCosteBase

      // Simplemente suma las lineas de coste base de margen o de coste/ingreso para en caso de que sea 0 no calcular las maletas.
      // Las sumas de coste se hacen sobre los importes en divisa.

      CLEAR(lwTotal);
      IF prParte."Tipo Calculo" = prParte."Tipo Calculo"::Margen THEN BEGIN
        CLEAR(rtmMar);
        rtmMar[1].SETCURRENTKEY(Usuario, "N§ Parte", Touroperador, Concepto, "Tipo linea");
        rtmMar[1].SETRANGE(Usuario     , USERID);
        rtmMar[1].SETRANGE("N§ Parte"  , prToPar."N§ Parte");
        rtmMar[1].SETRANGE(Touroperador, prToPar.Touroperador);
        rtmMar[1].SETRANGE(Concepto    , rtmMar[1].Concepto::Coste);
        IF pwSoloBase THEN
          rtmMar[1].SETRANGE("Tipo linea", rtmMar[1]."Tipo linea"::Base);
        IF rtmMar[1].FINDFIRST THEN BEGIN
          rtmMar[1].CALCSUMS("Importe con impuesto", "Importe sin impuesto");
          IF pwImpuestosIncluidos THEN
            lwTotal:= rtmMar[1]."Importe con impuesto"
          ELSE
            lwTotal:= rtmMar[1]."Importe sin impuesto";
        END;
      END
      ELSE BEGIN
        CLEAR(rtmProdCoste);
        rtmProdCoste[1].SETCURRENTKEY("N§ Parte",
                                      Touroperador,
                                      "Tipo linea");
        rtmProdCoste[1].SETRANGE("N§ Parte"  , prToPar."N§ Parte");
        rtmProdCoste[1].SETRANGE(Touroperador, prToPar.Touroperador);
        IF pwSoloBase THEN
          rtmProdCoste[1].SETRANGE("Tipo linea", rtmProdCoste[1]."Tipo linea"::Base);
        IF rtmProdCoste[1].FINDFIRST THEN BEGIN
          rtmProdCoste[1].CALCSUMS("Importe con impuesto", "Importe sin impuesto");
          IF pwImpuestosIncluidos THEN
            lwTotal:= rtmProdCoste[1]."Importe con impuesto"
          ELSE
            lwTotal:= rtmProdCoste[1]."Importe sin impuesto";
        END;
      END;

      EXIT(lwTotal);
    END;

    PROCEDURE CompruebaAplicacionIngreso@54(prPre@1100244000 : Record 7010405;prParte@1100244001 : Record 7010360;pwZona1@1100244002 : Code[10];pwZona2@1100244003 : Code[10];pwZona3@1100244004 : Code[10]) : Boolean;
    VAR
      lwOk@1100253000 : Boolean;
    BEGIN
      // CompruebaAplicacionIngreso
      //
      // Comprobar que se cumplen las condiciones de aplicacion para un suplemento automatico.

      // Comprobar Tipo Servicio
      lwOk := TRUE;
      IF lwOk AND (prPre."Tipo Servicio" <> '') THEN
        lwOk := prPre."Tipo Servicio" = prParte."Tipo Servicio";

      // Comprobar Codigo Servicio
      IF lwOk AND (prPre."Codigo servicio" <> '') THEN
        lwOk := prPre."Codigo servicio" = prParte."Codigo Servicio";

      // Comprobar Tipo Vehiculo
      IF lwOk AND (prPre."Tipo Vehiculo" <> '') THEN
        lwOk := prPre."Tipo Vehiculo" = prParte."Tipo Vehiculo facturacion";

      // Comprobar la zona desde
      IF lwOk AND (prPre."Zona desde" <> '') THEN
        lwOk := prPre."Zona desde" IN  [pwZona1, pwZona2, pwZona3];

      // Comprobar la zona hasta
      IF lwOk AND (prPre."Zona hasta" <> '') THEN
        lwOk := prPre."Zona hasta" IN  [pwZona1, pwZona2, pwZona3];

      // Comprobar la tercera zona
      IF lwOk AND (prPre."Tercera Zona" <> '') THEN
        lwOk := prPre."Tercera Zona" IN  [pwZona1, pwZona2, pwZona3];

      // Comprobar si se han juntado 3 zonas que no se puedan aplicar los suplementos por juntar 2
      IF lwOk AND (prPre."Tercera Zona" = '') THEN
        lwOk := pwZona3 = '';

      EXIT(lwOk);
    END;

    PROCEDURE PrecioSuplementoAutomaticoIng@46(prParte@1100244000 : Record 7010360;prCon@1100244002 : TEMPORARY Record 7010403;pwPasajeIngreso@1100244003 : Integer;ptzonas@1100253002 : ARRAY [8] OF Code[10];VAR prPre@1100253001 : Record 7010405) : Boolean;
    VAR
      lwOkprecio@1100244009 : Boolean;
      lwVuelta@1100253003 : Integer;
    BEGIN
      // PrecioSuplementoAutomaticoIng
      //
      //  Buscaremos para el contrato del touroperador si se han indicado que existen
      //  suplementos automaticos para los casos en que se junten 2 zonas.
      //  Se van a utilizar los filtros para establecer la prioridad de aplicacion, primero
      //  los mas restrictivos, y despues bajando eliminando campos.
      //
      // Hay que buscar las zonas de precios implicadas en este parte

      CLEAR(prPre);

      lwOkprecio := FALSE;
      CLEAR(rtmPrecV);
      rtmPrecV.SETCURRENTKEY(Garaje,
                         "N§ Contrato",
                         "Tipo precio",
                         "Codigo servicio",
                         "Zona desde",
                         "Zona hasta",
                         "Fecha desde",
                         "Fecha hasta",
                         "Tipo Vehiculo",
                         "Rango desde",
                         "Rango hasta");
      rtmPrecV.SETRANGE (Garaje                , prCon.Garaje);
      rtmPrecV.SETRANGE ("N§ Contrato"         , NumeroContratoVentFacturacion(prCon));
      rtmPrecV.SETRANGE ("Tipo precio"         , rtmPrecV."Tipo precio"::"Suplemento vario");
      rtmPrecV.SETFILTER("Fecha desde"         , '<=%1', prParte."Fecha facturacion");
      rtmPrecV.SETFILTER("Fecha hasta"         , '>=%1', prParte."Fecha facturacion");
      rtmPrecV.SETFILTER("Rango desde"         , '<=%1', pwPasajeIngreso);
      rtmPrecV.SETFILTER("Rango hasta"         , '>=%1', pwPasajeIngreso);
      rtmPrecV.SETRANGE ("Tipo Servicio"       , prParte."Tipo Servicio");   // Primero se prueba con todos
      rtmPrecV.SETRANGE ("Codigo servicio"     , prParte."Codigo Servicio"); // los campos de seleccion
      rtmPrecV.SETRANGE ("Tipo Vehiculo"       , prParte."Tipo Vehiculo facturacion");   // filtrados.
      rtmPrecV.SETRANGE (Activo                , TRUE);

      // A¤adido control para que los partes con solo dos zonas, no tomen por error un suplemento definido para tres zonas  un
      IF ptzonas[3] = '' THEN
        rtmPrecV.SETFILTER("Tercera Zona",'=%1','');

      CLEAR(lwVuelta);
      REPEAT
        lwVuelta +=1;
        CASE lwVuelta OF
         1 :; // Filtrado por Tipo servicio, codigo servicio y Tipo vehiculo
         2 : rtmPrecV.SETRANGE("Tipo Vehiculo", ''); // Filtrado por Tipo servicio y Codigo Servicio
         3 : BEGIN // Filtrado por Tipo servicio y Tipo vehiculo
              rtmPrecV.SETRANGE("Codigo servicio", ''); // Probar con el codigo de servicio en blanco
              rtmPrecV.SETRANGE ("Tipo Vehiculo" , prParte."Tipo Vehiculo facturacion");   // y filtrando por vehiculo
             END;
         4 : rtmPrecV.SETRANGE("Tipo Vehiculo", ''); // Filtrado por Tipo servicio
        END;

        IF rtmPrecV.FINDSET THEN BEGIN
          REPEAT
            lwOkprecio := CompruebaAplicacionIngreso(rtmPrecV, prParte, ptzonas[1], ptzonas[2], ptzonas[3]);
          UNTIL (rtmPrecV.NEXT = 0) OR lwOkprecio;
        END;
      UNTIL lwOkprecio OR (lwVuelta>=4);

      IF lwOkprecio THEN
        prPre := rtmPrecV;

      EXIT(lwOkprecio);
    END;

    PROCEDURE PrecioSuplementoAutomaticoCos@71(prParte@1100244000 : Record 7010360;prCon@1100253003 : TEMPORARY Record 7010408;ptzonas@1100253002 : ARRAY [8] OF Code[10];pwPasajeCoste@1100244003 : Integer;VAR prPre@1100253001 : TEMPORARY Record 7010409) : Boolean;
    VAR
      lwOkPrecio@1100244009 : Boolean;
      lwVuelta@1100253000 : Integer;
    BEGIN
      // PrecioSuplementoAutomaticoCos
      //
      // Buscaremos para el contrato del touroperador si se han indicado que existen
      // suplementos automaticos para los casos en que se junten 2 zonas.
      // Se van a utilizar los filtros para establecer la prioridad de aplicacion, primero
      // los mas restrictivos, y despues bajando eliminando campos.

      // Hay que buscar las zonas de precios implicadas en este parte

      CLEAR(lwOkPrecio);

      CLEAR(rtmPrecC);
      rtmPrecC.SETCURRENTKEY(Garaje,
                         "N§ Contrato",
                         "Tipo precio",
                         "Codigo servicio",
                         "Zona desde",
                         "Zona hasta",
                         "Fecha desde",
                         "Fecha hasta",
                         "Tipo Vehiculo",
                         "Rango desde",
                         "Rango hasta");
      rtmPrecC.SETRANGE (Garaje                , prCon.Garaje);
      rtmPrecC.SETRANGE ("N§ Contrato"         , NumeroContratoCompFacturacion(prCon));
      rtmPrecC.SETRANGE ("Tipo precio"         , rtmPrecC."Tipo precio"::"Suplemento vario");
      rtmPrecC.SETFILTER("Fecha desde"         , '<=%1', prParte."Fecha facturacion");
      rtmPrecC.SETFILTER("Fecha hasta"         , '>=%1', prParte."Fecha facturacion");
      rtmPrecC.SETFILTER("Rango desde"         , '<=%1', pwPasajeCoste);
      rtmPrecC.SETFILTER("Rango hasta"         , '>=%1', pwPasajeCoste);
      rtmPrecC.SETRANGE ("Tipo Servicio"       , prParte."Tipo Servicio");   // Primero se prueba con todos
      rtmPrecC.SETRANGE ("Codigo servicio"     , prParte."Codigo Servicio"); // los campos de seleccion
      rtmPrecC.SETRANGE ("Tipo Vehiculo"       , prParte."Tipo Vehiculo facturacion");   // filtrados.
      rtmPrecC.SETRANGE (Activo                , TRUE);

      // A¤adido control para que los partes con solo dos zonas, no tomen por error un suplemento definido para tres zonas

      IF ptzonas[3]='' THEN
        rtmPrecC.SETRANGE("Tercera zona",'');

      CLEAR(lwOkPrecio);

      CLEAR(lwVuelta);
      REPEAT
        lwVuelta +=1;
        CASE lwVuelta OF
         1 :; // Filtrado por Tipo servicio, codigo servicio y Tipo vehiculo
         2 : rtmPrecC.SETRANGE("Tipo Vehiculo", ''); // Filtrado por Tipo servicio y Codigo Servicio
         3 : BEGIN // Filtrado por Tipo servicio y Tipo vehiculo
              rtmPrecC.SETRANGE("Codigo servicio", ''); // Probar con el codigo de servicio en blanco
              rtmPrecC.SETRANGE ("Tipo Vehiculo" , prParte."Tipo Vehiculo facturacion");   // y filtrando por vehiculo
             END;
         4 : rtmPrecC.SETRANGE("Tipo Vehiculo", ''); // Filtrado por Tipo servicio
        END;

        IF rtmPrecC.FINDSET THEN BEGIN
          REPEAT
            lwOkPrecio := CompruebaAplicacionCoste(rtmPrecC, prParte, ptzonas[1], ptzonas[2], ptzonas[3]);
          UNTIL (rtmPrecC.NEXT = 0) OR (lwOkPrecio);
        END;
      UNTIL lwOkPrecio OR (lwVuelta>=4);

      IF lwOkPrecio THEN
        prPre := rtmPrecC;

      EXIT(lwOkPrecio);
    END;

    PROCEDURE CompruebaAplicacionCoste@72(prPre@1100244000 : TEMPORARY Record 7010409;prParte@1100244001 : Record 7010360;pwZona1@1100244002 : Code[10];pwZona2@1100244003 : Code[10];pwZona3@1100244004 : Code[10]) : Boolean;
    VAR
      lwOk@1100253000 : Boolean;
    BEGIN
      // CompruebaAplicacionCoste
      //
      // Comprobar que se cumplen las condiciones de aplicacion para un suplemento automatico.

      lwOk := TRUE;

      // Comprobar Tipo Servicio
      IF lwOk AND (prPre."Tipo Servicio" <> '') THEN
        lwOk :=  prPre."Tipo Servicio" = prParte."Tipo Servicio";

      // Comprobar Codigo Servicio
      IF lwOk AND (prPre."Codigo servicio" <> '') THEN
        lwOk := prPre."Codigo servicio" = prParte."Codigo Servicio";

      // Comprobar Tipo Vehiculo
      IF lwOk AND (prPre."Tipo Vehiculo" <> '') THEN
        lwOk :=  prPre."Tipo Vehiculo" = prParte."Tipo Vehiculo facturacion";

      // Comprobar la zona desde
      IF lwOk AND (prPre."Zona desde" <> '') THEN
        lwOk := (prPre."Zona desde" = pwZona1) OR  (prPre."Zona desde" = pwZona2) OR (prPre."Zona desde" = pwZona3);

      // Comprobar la zona hasta
      IF lwOk AND (prPre."Zona hasta" <> '') THEN
        lwOk := (prPre."Zona hasta" = pwZona1) OR (prPre."Zona hasta" = pwZona2) OR (prPre."Zona hasta" = pwZona3);

      // Comprobar la tercera zona
      IF lwOk AND (prPre."Tercera zona" <> '') THEN
        lwOk := (prPre."Tercera zona" = pwZona1) OR (prPre."Tercera zona" = pwZona2) OR (prPre."Tercera zona" = pwZona3);

      // Comprobar si se han juntado 3 zonas que no se puedan aplican los suplementos por juntar 2
      IF lwOk AND (prPre."Tercera zona" = '') THEN
        lwOk :=  pwZona3 = '';

      EXIT(lwOk);
    END;

    PROCEDURE VuelosParteTouroperador@45(pwParte@1100244000 : Code[10];pwTTOO@1100244001 : Code[10];VAR pwHora@1100244002 : Time) : Text[30];
    VAR
      rSerPar@1100244003 : Record 7010359;
      lwText@1100253000 : Text[30];
      lwEnc@1100253001 : Boolean;
    BEGIN
      // VuelosParteTouroperador
      // Rellenar el campo Vuelos del fichero de coste ingreso con el primer vuelo del parte para un touroperador en concreto.

      CLEAR(rtmSerPar);
      CLEAR(lwText);
      CLEAR(pwHora);
      rtmSerPar.SETCURRENTKEY("N§ Parte",Touroperador);
      rtmSerPar.SETRANGE ("N§ Parte"  , pwParte);
      rtmSerPar.SETRANGE (Touroperador, pwTTOO);
      rtmSerPar.SETFILTER("Hora Vuelo", '<>%1', 0T);
      lwEnc := rtmSerPar.FINDFIRST;
      IF NOT lwEnc THEN
        rtmSerPar.SETRANGE("Hora Vuelo");
      lwEnc := rtmSerPar.FINDFIRST;

      IF lwEnc THEN BEGIN
        pwHora := rtmSerPar."Hora Vuelo";
        lwText := COPYSTR(rtmSerPar.Vuelo, 1, 30);
      END;

      EXIT(lwText);
    END;

    PROCEDURE ReparteCosteTouroperador@61(prParte@1100244000 : Record 7010360);
    VAR
      lwImporteLinea@1100244008 : Decimal;
      lwImporteLineaSin@1100244009 : Decimal;
      lwPaxesTo@1100244010 : Integer;
      lwTotalPaxes@1103355000 : Integer;
    BEGIN
      // ReparteCosteTouroperador
      //

      CLEAR(rtmTOPar);

      // Buscamos el total de trasportados menos invitados
      CLEAR(lwTotalPaxes);
      rtmTOPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF rtmTOPar.FINDSET THEN BEGIN
        REPEAT
          lwTotalPaxes += rtmTOPar."Adultos transportados" + rtmTOPar."Ni¤os transportados" -
                                 rtmTOPar."Adultos invitados coste" - rtmTOPar."Ni¤os invitados coste";
        UNTIL rtmTOPar.NEXT=0;
      END;

      CASE prParte."Tipo Calculo" OF
        prParte."Tipo Calculo"::Margen:
        BEGIN
          CLEAR(rtmMar);
          rtmMar[1].SETRANGE(Usuario             , USERID);
          rtmMar[1].SETRANGE("N§ Parte"          , prParte."N§ Parte");
          rtmMar[1].SETRANGE(Concepto            , rtmMar[1].Concepto::Coste);
          rtmMar[1].SETRANGE("Tipo linea"        , rtmMar[1]."Tipo linea"::Base);
          rtmMar[1].SETRANGE("Porcentaje reparto", 0);
          IF rtmMar[1].FINDSET THEN BEGIN
            REPEAT
              // Repartir cada linea entre todos los TTOO
              rtmTOPar.SETRANGE("N§ Parte", prParte."N§ Parte");
              IF rtmTOPar.FINDSET THEN BEGIN
                lwImporteLinea    := 0;
                lwImporteLineaSin := 0;
                REPEAT
                  lwPaxesTo := rtmTOPar."Adultos transportados" + rtmTOPar."Ni¤os transportados" -
                                 rtmTOPar."Adultos invitados coste" - rtmTOPar."Ni¤os invitados coste";
                  ProporcionalToMargen(rtmMar[1], rtmTOPar, lwPaxesTo, 0, lwImporteLinea, lwTotalPaxes,
                                         0, rtmMar[2], lwImporteLineaSin);
                UNTIL rtmTOPar.NEXT = 0;

                //  Si el reparto no ha cuadrado exactamente se acumula la diferencia en la linea del ultimo TTOO  ---
                IF rtmMar[1]."Importe con impuesto" <> lwImporteLinea THEN BEGIN
                  rtmMar[2].VALIDATE("Importe con impuesto", rtmMar[2]."Importe con impuesto" +
                                                          (rtmMar[1]."Importe con impuesto" - lwImporteLinea));
                  rtmMar[2].VALIDATE("Importe sin impuesto", rtmMar[2]."Importe sin impuesto" +
                                                          (rtmMar[1]."Importe sin impuesto" - lwImporteLineaSin));
                  rtmMar[2].MODIFY;
                END;

                rtmMar[3] := rtmMar[1];
                rtmMar[3].DELETE;
              END;
            UNTIL rtmMar[1].NEXT = 0;
          END;
        END;
        prParte."Tipo Calculo"::Confirmacion:
        BEGIN
          CLEAR(rtmProdCoste);
          rtmProdCoste[1].SETRANGE("N§ Parte"          , prParte."N§ Parte");
          rtmProdCoste[1].SETRANGE("Tipo linea"        , rtmProdCoste[1]."Tipo linea"::Base);
          rtmProdCoste[1].SETRANGE("Porcentaje reparto", 0);
          IF rtmProdCoste[1].FINDSET(TRUE) THEN BEGIN
            REPEAT
              // Repartir cada linea entre todos los TTOO
              rtmTOPar.SETRANGE("N§ Parte", prParte."N§ Parte");
              IF rtmTOPar.FINDSET THEN BEGIN
                lwImporteLinea    := 0;
                lwImporteLineaSin := 0;
                REPEAT
                  lwPaxesTo := rtmTOPar."Adultos transportados" + rtmTOPar."Ni¤os transportados" -
                                rtmTOPar."Adultos invitados coste" - rtmTOPar."Ni¤os invitados coste";
                  ProporcionalToCoste(rtmProdCoste[1], rtmTOPar, lwPaxesTo, 0, lwImporteLinea, lwTotalPaxes, 0,
                                      rtmProdCoste[2], lwImporteLineaSin);
                UNTIL rtmTOPar.NEXT = 0;

                // Si el reparto no ha cuadrado exactamente se acumula la diferencia en la linea del ultimo TTOO

                IF rtmProdCoste[1]."Importe con impuesto" <> lwImporteLinea THEN BEGIN
                  rtmProdCoste[2].VALIDATE("Importe con impuesto", rtmProdCoste[2]."Importe con impuesto" +
                                           (rtmProdCoste[1]."Importe con impuesto" - lwImporteLinea));

                  rtmProdCoste[2].MODIFY;
                END;
                rtmProdCoste[3] := rtmProdCoste[1];
                rtmProdCoste[3].DELETE;
              END;
            UNTIL rtmProdCoste[1].NEXT = 0;
          END;
        END;
      END;
    END;

    PROCEDURE ProporcionalToMargen@32(prMar@1100244000 : TEMPORARY Record 7010412;prToPar@1100244001 : TEMPORARY Record 7010365;pwAdulto@1100244002 : Integer;pwNi¤o@1100244003 : Integer;VAR pwTotal@1100244004 : Decimal;pwTotalAd@1100244005 : Integer;pwTotalNi@1100244006 : Integer;VAR prMar2@1100244007 : TEMPORARY Record 7010412;VAR pwTotalSin@1100244008 : Decimal);
    VAR
      lwPorcen@1100244010 : Decimal;
      lwCant@1100253000 : Decimal;
      lwPrecision@1100253001 : Decimal;
    BEGIN
      // ProporcionalToMargen

      // INPUT
      //     prMar           --> Registro del que queremos hacer el reparto
      //     prToPar         --> Touroperador que se va a repartir
      //     pw_adulto       --> Cantidad de adultos descontados los invitados
      //     pw_ni¤os        --> Cantidad de ni¤os descontados los invitados
      // VAR pwTotal         --> Acumulado del importe repartido hasta el momento con impuestos
      //     pwTotalAd       --> Total de adultos de la linea a repartir
      //     pwTotalNi       --> Total de ni¤os de la linea a repartir
      // VAR prMar2          --> Nueva linea que se va a crear con el importe repartido
      // VAR pwTotalsin      --> Acumulado del importe repartido hasta el momento sin impuestos

      // Temporalmente para los calculos del OPTRAT no tenemos precision de ingreso, asi que le ponemos la de coste


      IF wPrecisionIngreso = 0 THEN
        wPrecisionIngreso := wPrecisionCoste;

      lwPorcen := 0;
      CASE prMar."Tipo elemento" OF
        rPar."Codigo Adulto": BEGIN
          IF pwTotalAd <> 0 THEN
            lwPorcen := ROUND((pwAdulto * 100) / pwTotalAd, 0.01);
        END;
        rPar."Codigo Ni¤o": BEGIN
          IF pwTotalNi <> 0 THEN
            lwPorcen := ROUND((pwNi¤o * 100) / pwTotalNi, 0.01);
        END;
        Text000: BEGIN
          IF (pwTotalAd + pwTotalNi) <> 0 THEN
            lwPorcen := ROUND(((pwAdulto + pwNi¤o) * 100) / (pwTotalAd + pwTotalNi), 0.01);
        END;
      END;

      IF lwPorcen = 0 THEN
        EXIT;

      CASE prMar.Concepto OF
        prMar.Concepto::Coste  : lwPrecision := wPrecisionCoste;
        prMar.Concepto::Ingreso: lwPrecision := wPrecisionIngreso;
      END;

      prMar2 := prMar;
      prMar2.Touroperador           := prToPar.Touroperador;
      prMar2."Porcentaje reparto"   := lwPorcen;
      prMar2."Importe sin original" := prMar."Importe sin impuesto";
      prMar2."Importe con original" := prMar."Importe con impuesto";
      CASE prMar."Tipo elemento" OF
        rPar."Codigo Adulto": prMar2."Pax Real" := pwAdulto;
        rPar."Codigo Ni¤o"  : prMar2."Pax Real" := pwNi¤o;
        Text000             : prMar2."Pax Real" := pwAdulto + pwNi¤o;
      END;

      prMar2.VALIDATE("Importe sin impuesto", ROUND((prMar2."Importe sin original" * lwPorcen) / 100, lwPrecision));
      prMar2.VALIDATE("Importe con impuesto", ROUND((prMar2."Importe con original" * lwPorcen) / 100, lwPrecision));
      prMar2."Pax Transportados" := prToPar."Adultos transportados" + prToPar."Ni¤os transportados";
      wNLCont +=1; // Contador de numero de linea, No podemos utilizar el Insert(TRUE) al ser un temporal

      // JPT 22/08/03 Si No es precio vehiculo y No se han aplicado minimos se cambia los pax facturados
      IF (prMar."Precio Pax" <> 0) AND (prMar.Pax = prMar."Pax Real") THEN
        prMar2."Pax Facturados" := prMar2."Pax Real";

      // 22/08/06 Si el importe es sin impuestos
      IF prMar.Importe = prMar."Importe sin impuesto" THEN BEGIN
        prMar2.Importe      := prMar2."Importe sin impuesto";
        prMar2."Importe DL" := prMar2."Importe sin impuesto DL";
      END
      ELSE // Si es con impuestos
      IF prMar.Importe = prMar."Importe con impuesto" THEN BEGIN
        prMar2.Importe      := prMar2."Importe con impuesto";
        prMar2."Importe DL" := prMar2."Importe con impuesto DL";
      END;

      prMar2."N§ Linea" := wNLCont;
      prMar2.INSERT;

      pwTotal    += prMar2."Importe con impuesto";
      pwTotalSin += prMar2."Importe sin impuesto";
    END;

    PROCEDURE ProporcionalToCoste@16(prProdCoste@1100244000 : TEMPORARY Record 7035393;prTTOOPar@1100244001 : Record 7010365;pwAdulto@1100244002 : Integer;pwNi¤o@1100244003 : Integer;VAR pwTotal@1100244004 : Decimal;pwTotalAd@1100244005 : Integer;pwTotalNi@1100244006 : Integer;VAR prProdCoste2@1100244007 : TEMPORARY Record 7035393;VAR pwTotalSin@1100244008 : Decimal);
    VAR
      wPorcen@1100244010 : Decimal;
      lwPrecision@1100253000 : Decimal;
    BEGIN
      // ProporcionalToCoste
      //
      // INPUT
      //     prProdCoste    --> Registro del que queremos hacer el reparto
      //     prTTOOPar      --> Touroperador que se va a repartir
      //     pwAdulto       --> Cantidad de adultos descontados los invitados
      //     pwNi¤os        --> Cantidad de ni¤os descontados los invitados
      // VAR pwTotal        --> Acumulado del importe repartido hasta el momento con impuestos
      //     pwTotalAd      --> Total de adultos de la linea a repartir
      //     pwTotalNi      --> Total de ni¤os de la linea a repartir
      // VAR prProdCoste2   --> Nueva linea que se va a crear con el importe repartido
      // VAR pwTotalsin     --> Acumulado del importe repartido hasta el momento sin impuestos
      //
      wPorcen := 0;
      CASE prProdCoste."Tipo elemento" OF
        rPar."Codigo Adulto": BEGIN
          IF pwTotalAd <> 0 THEN
            wPorcen := ROUND((pwAdulto * 100) / pwTotalAd, 0.01);
        END;
        rPar."Codigo Ni¤o": BEGIN
          IF pwTotalNi <> 0 THEN
            wPorcen := ROUND((pwNi¤o * 100) / pwTotalNi, 0.01);
        END;
        Text000: BEGIN
          IF (pwTotalAd + pwTotalNi) <> 0 THEN
            wPorcen := ROUND(((pwAdulto + pwNi¤o) * 100) / (pwTotalAd + pwTotalNi), 0.01);
        END;
      END;
      IF wPorcen = 0 THEN
        EXIT;

      lwPrecision := wPrecisionCoste;

      prProdCoste2 := prProdCoste;
      prProdCoste2.Touroperador           := prTTOOPar.Touroperador;
      prProdCoste2."Porcentaje reparto"   := wPorcen;
      prProdCoste2."Importe sin original" := prProdCoste."Importe sin impuesto";
      prProdCoste2."Importe con original" := prProdCoste."Importe con impuesto";
      CASE prProdCoste."Tipo elemento" OF
        rPar."Codigo Adulto": prProdCoste2."Pax Real" := pwAdulto;
        rPar."Codigo Ni¤o"  : prProdCoste2."Pax Real" := pwNi¤o;
        Text000             : prProdCoste2."Pax Real" := pwAdulto + pwNi¤o;
      END;

      // JPT 22/08/03 Si No es precio vehiculo y No se han aplicado minimos se cambia los pax facturados

      IF (prProdCoste."Precio Pax" <> 0) AND (prProdCoste.Pax = prProdCoste."Pax Real") THEN
        prProdCoste2."Pax Facturados"    := prProdCoste2."Pax Real";
      prProdCoste2."Pax Transportados" := prTTOOPar."Pax Transportados";

      prProdCoste2.VALIDATE("Importe con impuesto", ROUND((prProdCoste2."Importe con original" * wPorcen) / 100, lwPrecision));

      // 22/08/06 Si el importe es sin impuestos
      IF prProdCoste.Importe = prProdCoste."Importe sin impuesto" THEN BEGIN
        prProdCoste2.Importe      := prProdCoste2."Importe sin impuesto";
        prProdCoste2."Importe DL" := prProdCoste2."Importe sin impuesto DL";
      END
      ELSE // Si es con impuestos
      IF prProdCoste.Importe = prProdCoste."Importe con impuesto" THEN BEGIN
        prProdCoste2.Importe      := prProdCoste2."Importe con impuesto";
        prProdCoste2."Importe DL" := prProdCoste2."Importe con impuesto DL";
      END;

      wNLCont += 1; // Contador de numero de linea, No podemos utilizar el Insert(TRUE) al ser un temporal

      prProdCoste2."N§ Linea" := wNLCont;
      prProdCoste2.INSERT;

      pwTotal    := pwTotal    + prProdCoste2."Importe con impuesto";
      pwTotalSin := pwTotalSin + prProdCoste2."Importe sin impuesto";
    END;

    PROCEDURE ProporcionalToIngreso@1103355004(prProdIng@1100244000 : TEMPORARY Record 7035392;prTTOOPar@1100244001 : Record 7010365;pwAdulto@1100244002 : Integer;pwNi¤o@1100244003 : Integer;VAR pwTotal@1100244004 : Decimal;pwTotalAd@1100244005 : Integer;pwTotalNi@1100244006 : Integer;VAR prProdIng2@1100244007 : TEMPORARY Record 7035392;VAR pwTotalSin@1100244008 : Decimal);
    VAR
      wPorcen@1100244010 : Decimal;
      lwPrecision@1100253000 : Decimal;
    BEGIN
      // ProporcionalToIngreso
      //
      // INPUT
      //     prProdIng    --> Registro del que queremos hacer el reparto
      //     prTTOOPar    --> Touroperador que se va a repartir
      //     pwAdulto     --> Cantidad de adultos descontados los invitados
      //     pwNi¤os      --> Cantidad de ni¤os descontados los invitados
      // VAR pwTotal      --> Acumulado del importe repartido hasta el momento con impuestos
      //     pwTotalAd    --> Total de adultos de la linea a repartir
      //     pwTotalNi    --> Total de ni¤os de la linea a repartir
      // VAR prProdIng2   --> Nueva linea que se va a crear con el importe repartido
      // VAR pwTotalsin   --> Acumulado del importe repartido hasta el momento sin impuestos
      //
      wPorcen := 0;
      CASE prProdIng."Tipo elemento" OF
        rPar."Codigo Adulto": BEGIN
          IF pwTotalAd <> 0 THEN
            wPorcen := ROUND((pwAdulto * 100) / pwTotalAd, 0.01);
        END;
        rPar."Codigo Ni¤o": BEGIN
          IF pwTotalNi <> 0 THEN
            wPorcen := ROUND((pwNi¤o * 100) / pwTotalNi, 0.01);
        END;
        Text000: BEGIN
          IF (pwTotalAd + pwTotalNi) <> 0 THEN
            wPorcen := ROUND(((pwAdulto + pwNi¤o) * 100) / (pwTotalAd + pwTotalNi), 0.01);
        END;
      END;
      IF wPorcen = 0 THEN
        EXIT;

      lwPrecision := wPrecisionIngreso;

      prProdIng2 := prProdIng;
      prProdIng2.Touroperador           := prTTOOPar.Touroperador;
      prProdIng2."Porcentaje reparto"   := wPorcen;
      prProdIng2."Importe sin original" := prProdIng."Importe sin impuesto";
      prProdIng2."Importe con original" := prProdIng."Importe con impuesto";
      CASE prProdIng."Tipo elemento" OF
        rPar."Codigo Adulto": prProdIng2."Pax Real" := pwAdulto;
        rPar."Codigo Ni¤o"  : prProdIng2."Pax Real" := pwNi¤o;
        Text000             : prProdIng2."Pax Real" := pwAdulto + pwNi¤o;
      END;

      // JPT 22/08/03 Si No es precio vehiculo y No se han aplicado minimos se cambia los pax facturados

      IF (prProdIng."Precio Pax" <> 0) AND (prProdIng.Pax = prProdIng."Pax Real") THEN
        prProdIng2."Pax Facturados"    := prProdIng2."Pax Real";
      prProdIng2."Pax Transportados" := prTTOOPar."Pax Transportados";

      prProdIng2.VALIDATE("Importe con impuesto", ROUND((prProdIng2."Importe con original" * wPorcen) / 100, lwPrecision));

      // 22/08/06 Si el importe es sin impuestos

      IF prProdIng.Importe = prProdIng."Importe sin impuesto" THEN BEGIN
        prProdIng2.Importe      := prProdIng2."Importe sin impuesto";
        prProdIng2."Importe DL" := prProdIng2."Importe sin impuesto DL";
      END
      ELSE // Si es con impuestos
        IF prProdIng.Importe = prProdIng."Importe con impuesto" THEN BEGIN
          prProdIng2.Importe      := prProdIng2."Importe con impuesto";
          prProdIng2."Importe DL" := prProdIng2."Importe con impuesto DL";
        END;

      wNLCont += 1; // Contador de numero de linea, No podemos utilizar el Insert(TRUE) al ser un temporal

      prProdIng2."N§ Linea" := wNLCont;
      prProdIng2.INSERT;

      pwTotal    := pwTotal    + prProdIng2."Importe con impuesto";
      pwTotalSin := pwTotalSin + prProdIng2."Importe sin impuesto";
    END;

    PROCEDURE BuscaPrecisionCompra@56(prCon@1100244000 : TEMPORARY Record 7010408) : Decimal;
    VAR
      rConf@1100244001 : Record 98;
      rDiv@1100244002 : Record 4;
      lwPrecision@1100253000 : Decimal;
    BEGIN
      // BuscaPrecisionCompra
      //
      // Determina cual va a ser la precision a aplicar en los ROUND de compra,
      //         puede ser la de la divisa del contrato la de Configuracion contabilidad.

      IF prCon."Cod. Divisa" <> '' THEN BEGIN
        rDiv.GET(prCon."Cod. Divisa");
        lwPrecision := rDiv."Amount Rounding Precision";
      END
      ELSE BEGIN
        rConf.FINDFIRST;
        lwPrecision := rConf."Amount Rounding Precision";
      END;
      wPrecisionCoste := lwPrecision;
      EXIT(lwPrecision);
    END;

    PROCEDURE TraduceOrigenCompra@44(prParte@1100244000 : Record 7010360;prCon@1100244001 : Record 7010408) : Code[10];
    VAR
      lrTipoSer@1100244004 : Record 7010319;
      lrPto@1100253000 : Record 7010315;
    BEGIN
      // TraduceOrigenCompra
      //
      // Buscar la traduccion del aeropuerto en el contrato de venta
      // Para saber si es una excursion hay que consultar el tipo de servicio

      lrTipoSer.RESET;
      lrTipoSer.GET(prParte."Tipo Servicio");
      IF (prParte."Origen/Destino" <> '') AND (lrTipoSer."Tipo fijo" <> lrTipoSer."Tipo fijo"::Excursion) THEN BEGIN

        lrPto.RESET;
        lrPto.GET(prParte."Origen/Destino");

        CLEAR(rtmZonaC);
        // Al buscar los precios habra que chequear que exista para el garaje del servicio o para el garaje TODOS
        rtmZonaC.SETFILTER(Garaje         , '%1|%2', prParte.Garaje, rPar."Todos los garajes");
        rtmZonaC.SETRANGE("N§ Contrato"  , NumeroContratoCompFacturacion(prCon));
        rtmZonaC.SETRANGE("Tipo contrato", rtmZonaC."Tipo contrato"::Compra);

        // AJS 11.06.2008
        // La conversion de zonas de precio tiene que tener en cuenta el campo de los contratos

        IF prCon."Base para zonas precio" = prCon."Base para zonas precio"::"Zona fisica" THEN
          rtmZonaC.SETRANGE("Codigo Origen"  , lrPto."Zona fisica")
        ELSE
          rtmZonaC.SETRANGE("Codigo Origen"  , prParte."Origen/Destino");

        IF rtmZonaC.FINDFIRST THEN
          EXIT(rtmZonaC."Zona Precio")
        ELSE BEGIN
          // Si el parte es gratuito no se inserta el error
          // Solo se insertan errores si el parte es facturable

          IF prParte.Facturable THEN BEGIN
            // AJS 11.06.2008
            // El mensaje de error variar  en funcion de la tabla base de las conversiones

            IF prCon."Base para zonas precio" = prCon."Base para zonas precio"::"Zona fisica" THEN
              InsertaError(prParte, STRSUBSTNO(Text025, lrPto."Zona fisica", prCon."N§ Contrato"), rErr.Tipo::Error)
            ELSE
              InsertaError(prParte, STRSUBSTNO(Text039, prParte."Origen/Destino", prCon."N§ Contrato"), rErr.Tipo::Error);
          END;
        END;
      END;
    END;

    PROCEDURE TipoPrecioCompra@30(prParte@1100244000 : Record 7010360;prCon@1100244001 : TEMPORARY Record 7010408;VAR prPre@1100244002 : TEMPORARY Record 7010409;prZonPre@1100244003 : TEMPORARY Record 7010364;prToPar@1100244004 : TEMPORARY Record 7010365;pwElem@1100244005 : Code[10];pwCant@1100244006 : Integer;pwOrigenDestino@1100244007 : Code[10];pwCantZona@1100244009 : Integer;VAR pwCosteAltoUnico@1100253002 : Boolean) : Boolean;
    VAR
      lrtmZonPre2@1103355000 : TEMPORARY Record 7010364;
      lrCon@1100244011 : TEMPORARY Record 7010408;
      lrPre@1100244013 : TEMPORARY Record 7010409;
      lrToPar2@1100253000 : TEMPORARY Record 7010365;
      lrZonPre2@1100253001 : TEMPORARY Record 7010364;
      lwEnc@1100244015 : Boolean;
      lwOrigenDestino@1100244016 : Code[10];
      lwOk@1100244017 : Boolean;
      lwPaxT@1103355001 : Decimal;
    BEGIN
      // TipoPrecioCompra
      //
      // INPUT
      //     prParte           --> Parte que se esta calculando
      //     prCon             --> Contrato de compra encontrado para la tripleta Proveedor - Cliente - Touroperador
      // VAR prPre             --> Registro de precios donde retornaremos el precio encontrado
      //     prZonPre          --> Zona para la que estamos buscando el precio
      //     prToPar           --> Touroperador para el que estamos buscando el precio
      //     pwElem            --> Codigo para el que buscamos el precio en los suplementos por elemento
      //     pwCant            --> Suma de adultos, ni¤os del touroperador
      //     pwOrigenDestino   --> Punto de origen/destino del parte, ya traducido para el contrato activo
      //     pwCantZona        --> Suma de adultos y ni¤os del touroperador en la zona
      //
      // OUTPUT
      //     (Boolean) --> Indica si se ha encontrado algun precio de compra

      CLEAR(prPre);

      // Copiamos el puntero para dejarlo como antes
      lrToPar2.COPY(rtmTOPar);
      lrZonPre2.COPY(rtmZonPre);

      // Comprobar cual es la manera de trabajar a la hora de buscar el precio del proveedor

      CLEAR(lwEnc);
      prParte.CALCFIELDS(prParte."Adultos transportados", prParte."Ni¤os transportados");
      CASE prParte."Tipo calculo coste" OF
        prParte."Tipo calculo coste"::Normal,prParte."Tipo calculo coste"::"Promedio Plazas" : BEGIN
          lwEnc := BuscaPrecioCompra(prParte, prCon, prPre, prZonPre, prToPar, '',
                   pwCant {prParte."Adultos transportados" + prParte."Ni¤os transportados"}, // AJF 06/08/08
                   pwOrigenDestino, prZonPre."Adultos facturados zona" + prZonPre."Ni¤os facturados zona");
        END;

        prParte."Tipo calculo coste"::"Precio mas alto": BEGIN
        // Buscar el touroperador con el precio mas caro y aplicarlo a todos


          CLEAR(rtmTOPar);
          rtmTOPar.SETRANGE("N§ Parte", prParte."N§ Parte");
          IF rtmTOPar.FINDSET THEN BEGIN
            REPEAT
              CLEAR(lwPaxT);
              CLEAR(lrtmZonPre2); // Segundo temporal local
              lrtmZonPre2.DELETEALL;
              // Buscar el contrato correspondiente al touroperador
              BuscaContratoCompra(lrCon, prParte.Proveedor, rtmTOPar.Touroperador, prParte.Cliente,
                                                           prParte."Fecha facturacion", prParte.Garaje);

              // Localizar la zona de precios correspondiente al touroperador

              CASE prParte."Coste Precios por" OF
                prParte."Coste Precios por"::"Cada zona": BEGIN
                  // Rellenamos el temporal
                  // Insertamos todas las zonas en un nuevo tamporal
                  {
                  lwOk := rtmZonPre.GET(prParte."N§ Parte", rtmZonPre."Tipo contrato"::Compra, lrCon."N§ Contrato",
                                        prZonPre."Zona Precio");
                  }
                  CLEAR(rtmZonPre);
                  rtmZonPre.SETCURRENTKEY("N§ Parte", "Tipo contrato", "N§ Contrato", Orden);
                  rtmZonPre.SETRANGE("N§ Parte"     , prParte."N§ Parte");
                  rtmZonPre.SETRANGE("Tipo contrato", rtmZonPre."Tipo contrato"::Compra);
                  IF rtmZonPre.FINDSET THEN BEGIN
                    REPEAT
                      lrtmZonPre2 := rtmZonPre;
                      lrtmZonPre2.INSERT;
                    UNTIL rtmZonPre.NEXT=0;
                  END;
                END;

                prParte."Coste Precios por"::"Zona mas alejada": BEGIN
                  CLEAR(rtmZonPre);
                  rtmZonPre.ASCENDING(FALSE);
                  rtmZonPre.SETCURRENTKEY("N§ Parte", "Tipo contrato", "N§ Contrato", Orden);
                  rtmZonPre.SETRANGE("N§ Parte"     , prParte."N§ Parte");
                  rtmZonPre.SETRANGE("Tipo contrato", rtmZonPre."Tipo contrato"::Compra);
                  rtmZonPre.SETRANGE("N§ Contrato"  , lrCon."N§ Contrato");
                  IF rtmZonPre.FINDFIRST THEN BEGIN
                    lrtmZonPre2 := rtmZonPre;
                    lrtmZonPre2.INSERT;
                  END;
                END;
              END;

              // Traducir el punto de origen/destino
              lwOrigenDestino := TraduceOrigenCompra(prParte, lrCon);

              IF lrtmZonPre2.FINDSET THEN BEGIN
                REPEAT

                  CASE prParte."Coste Precios por" OF // Seleccionamos el pax para buscar precios
                    prParte."Coste Precios por"::"Cada zona":
                                 lwPaxT := lrtmZonPre2."Adultos facturados zona" + lrtmZonPre2."Ni¤os facturados zona";
                    prParte."Coste Precios por"::"Zona mas alejada":
                                 lwPaxT := rtmTOPar."Adultos facturados"  + rtmTOPar."Ni¤os facturados";
                  END;

                  IF BuscaPrecioCompra(prParte, lrCon, lrPre, lrtmZonPre2, rtmTOPar, '', prParte."Adultos transportados" +
                                          prParte."Ni¤os transportados", lwOrigenDestino, lwPaxT) THEN BEGIN

                    // Si es un precio por pax hay que buscar el precio de adulto para comparar
                    // Comparar si el precio encontrado es mas alto del que ya tenemos
                    CASE lrPre."Tipo aplicacion" OF
                      lrPre."Tipo aplicacion"::Pax      : lwEnc:=  lrPre."Precio Adulto" > prPre."Precio Adulto";
                      lrPre."Tipo aplicacion"::Vehiculo : lwEnc := lrPre."Precio Vehiculo" > prPre."Precio Vehiculo";
                    END;
                  END;

                  IF lwEnc THEN BEGIN
                    prPre:=lrPre;
                    prPre.COPY(lrPre);
                  END;

                  IF prPre."Tipo aplicacion" = prPre."Tipo aplicacion"::Vehiculo THEN BEGIN
                    // Si el precio es por vehiculo solo hay que aplicar el touroperador mas caro
                    IF (prPre."N§ Contrato" <> NumeroContratoCompFacturacion(prCon)) OR (pwCosteAltoUnico) THEN
                      CLEAR(prPre);
                  END;

                UNTIL lrtmZonPre2.NEXT=0;
              END;

            UNTIL rtmTOPar.NEXT = 0;
          END;
        END;
      END;

      // Se si aplica un precio por vehiculo, se marca este booleano para que luego se reparta el coste entre touroperadores
      lwEnc := prPre."N§ Contrato" <> '';
      IF lwEnc THEN BEGIN
        IF (prPre."Tipo aplicacion" = prPre."Tipo aplicacion"::Vehiculo) OR
        (prParte."Tipo calculo coste" = prParte."Tipo calculo coste"::"Precio mas alto") THEN
          pwCosteAltoUnico := TRUE;
      END;

      // Dejamos el puntero como antes
      rtmTOPar.COPY(lrToPar2);
      rtmZonPre.COPY(lrZonPre2);

      EXIT(lwEnc);
    END;

    PROCEDURE BuscaPrecioCompra@31(prParte@1100244000 : Record 7010360;prCon@1100244001 : TEMPORARY Record 7010408;VAR prPre@1100244002 : TEMPORARY Record 7010409;prZonPre@1100244003 : TEMPORARY Record 7010364;prToPar@1100244004 : TEMPORARY Record 7010365;pwElem@1100244005 : Code[10];pwCant@1100244006 : Integer;pwOrigenDestino@1100244007 : Code[10];pwCantZona@1100244009 : Integer) : Boolean;
    VAR
      lrTipoSer@1100244010 : Record 7010319;
      lwEsExcursion@1100244011 : Boolean;
      lwEnc@1100253000 : Boolean;
      lwTextError@1100253001 : Text[250];
      lwNCont@1100253002 : Code[10];
      lwTarifaHoraria@1103355000 : Code[10];
      lwDiaFestivo@1103355001 : Boolean;
    BEGIN
      // BuscaPrecioCompra
      //  Buscamos el precio a aplicar en funcion de servicio, zona, fechas , tipo de vehiculo y rango de personas.

      lwNCont := NumeroContratoCompFacturacion(prCon);

      // AJS 16.05.2008, TNU08003
      // Buscamos si el contrato tiene tarifa horaria

      lwTarifaHoraria := BuscaTarifaHoraria(lwNCont, prParte."Hora inicio");

      lwDiaFestivo := CompruebaDiaFestivo(lwNCont, prParte.Fecha);

      CLEAR(rtmPrecC);
      rtmPrecC.SETCURRENTKEY(Garaje,
                          "N§ Contrato",
                          "Tipo precio",
                          "Codigo servicio",
                          "Zona desde",
                          "Zona hasta",
                          "Fecha desde",
                          "Fecha hasta",
                          "Tipo Vehiculo",
                          "Rango desde",
                          "Rango hasta");
      rtmPrecC.SETRANGE(Garaje           , prCon.Garaje);
      rtmPrecC.SETRANGE("N§ Contrato"    , lwNCont);
      IF pwElem = '' THEN
        rtmPrecC.SETRANGE("Tipo precio"    , rtmPrecC."Tipo precio"::"Precio Base")
      ELSE BEGIN
        rtmPrecC.SETRANGE("Tipo precio"    , rtmPrecC."Tipo precio"::"Suplemento elemento");
        rtmPrecC.SETRANGE ("Codigo suplemento", pwElem);
      END;

      rtmPrecC.SETRANGE("Codigo servicio", prParte."Codigo Servicio");
      // Para saber si un servicio es una excursion hay que consultar el tipo servicio
      lrTipoSer.RESET;
      lrTipoSer.GET(prParte."Tipo Servicio");
      lwEsExcursion := lrTipoSer."Tipo fijo" = lrTipoSer."Tipo fijo"::Excursion;

      IF lwEsExcursion THEN BEGIN
        rtmPrecC.SETRANGE("Zona desde"     , prZonPre."Zona Precio");
        rtmPrecC.SETRANGE("Zona hasta"     , '');
      END
      ELSE BEGIN
        rtmPrecC.SETRANGE("Zona desde"     , pwOrigenDestino);
        rtmPrecC.SETRANGE("Zona hasta"     , prZonPre."Zona Precio");
      END;
      rtmPrecC.SETFILTER("Fecha desde"     , '<=%1', prParte."Fecha facturacion");
      rtmPrecC.SETFILTER("Fecha hasta"     , '>=%1', prParte."Fecha facturacion");
      rtmPrecC.SETRANGE ("Tipo Vehiculo"   , prParte."Tipo Vehiculo facturacion");
      IF prParte."Busca precio pasaje x zona cos" THEN BEGIN
        rtmPrecC.SETFILTER("Rango desde"      , '<=%1', pwCantZona);
        rtmPrecC.SETFILTER("Rango hasta"      , '>=%1', pwCantZona);
      END
      ELSE BEGIN
        rtmPrecC.SETFILTER("Rango desde"      , '<=%1', pwCant);
        rtmPrecC.SETFILTER("Rango hasta"      , '>=%1', pwCant);
      END;

      // AJS 16.05.2008, TNU08003
      // Filtramos por la tarifa horaria y dia festivo

      rtmPrecC.SETRANGE("Tarifa horaria", lwTarifaHoraria);
      rtmPrecC.SETRANGE("Dia festivo"   , lwDiaFestivo);


      rtmPrecC.SETRANGE (Activo               , TRUE);
      lwEnc := rtmPrecC.FINDFIRST;
      IF NOT lwEnc THEN BEGIN
        rtmPrecC.SETRANGE ("Tipo Vehiculo");
        lwEnc := rtmPrecC.FINDFIRST;
        IF NOT lwEnc THEN BEGIN
          IF pwElem <> '' THEN BEGIN
            rtmPrecC.SETRANGE("Zona desde", '');
            rtmPrecC.SETRANGE("Zona hasta", '');
            lwEnc := rtmPrecC.FINDFIRST;
          END;
        END;
      END;

      IF lwEnc THEN
        prPre := rtmPrecC;

      IF NOT lwEnc THEN BEGIN
        IF pwElem <> '' THEN BEGIN
          IF lwEsExcursion THEN
            lwTextError:= STRSUBSTNO(Text029, prCon."N§ Contrato", prParte."Codigo Servicio", prZonPre."Zona Precio",
                                                                      prParte."Fecha facturacion", pwCant, pwElem)
          ELSE
            lwTextError:= STRSUBSTNO(Text030, prCon."N§ Contrato", prParte."Codigo Servicio", pwOrigenDestino, prZonPre."Zona Precio",
                                                                                         prParte."Fecha facturacion", pwCant, pwElem);
        END
        ELSE BEGIN
          IF lwEsExcursion THEN
            lwTextError:= STRSUBSTNO(Text027, prCon."N§ Contrato", prParte."Codigo Servicio",
                                                     prZonPre."Zona Precio", prParte."Fecha facturacion",pwCant)
          ELSE
            lwTextError:= STRSUBSTNO(Text028, prCon."N§ Contrato", prParte."Codigo Servicio", pwOrigenDestino, prZonPre."Zona Precio",
                                                                                                  prParte."Fecha facturacion", pwCant);
        END;
      END;

      IF NOT lwEnc THEN BEGIN
        IF prParte.Facturable AND (pwElem <> rPar."Codigo Maletas") THEN
          InsertaError(prParte, lwTextError , rErr.Tipo::Error);
      END;


      EXIT(lwEnc);
    END;

    PROCEDURE BuscaTarifaHoraria@1103355003(pwContrato@1103355001 : Code[20];pwHoraInicio@1103355002 : Time) : Code[10];
    VAR
      lrTarHor@1103355000 : Record 7035400;
    BEGIN
      // BuscaTarifaHoraria

      lrTarHor.RESET;
      lrTarHor.SETRANGE ("Num. Contrato", pwContrato);
      lrTarHor.SETFILTER("Hora desde"   , '<=%1', pwHoraInicio);
      lrTarHor.SETFILTER("Hora hasta"   , '>=%1', pwHoraInicio);
      lrTarHor.SETRANGE (Activo         , TRUE);
      IF lrTarHor.FINDFIRST THEN
        EXIT(lrTarHor.Codigo)
      ELSE
        EXIT('');
    END;

    PROCEDURE CompruebaDiaFestivo@1103355005(pwNumContrato@1103355000 : Code[20];pwFecha@1103355001 : Date) : Boolean;
    VAR
      lrCont@1103355002 : Record 7010408;
      lcCalendar@1103355003 : Codeunit 7010319;
      lwDummyText@1103355004 : Text[250];
    BEGIN
      // CompruebaDiaFestivo

      lrCont.RESET;
      lrCont.SETRANGE("N§ Contrato", pwNumContrato);
      IF NOT lrCont.FINDFIRST THEN
        EXIT(FALSE);

      IF lrCont."Calendario festivos" = '' THEN
        EXIT(FALSE);

      EXIT(lcCalendar.CheckDateStatus(lrCont."Calendario festivos", pwFecha, lwDummyText));
    END;

    PROCEDURE BuscaPrecioSuplementoCompra@48(prCon@1100244000 : Record 7010408;prParte@1100244001 : Record 7010360;pwDesde@1100244002 : Code[10];pwHasta@1100244003 : Code[10];VAR prPre@1100244004 : Record 7010409) : Boolean;
    VAR
      lwEnc@1100253000 : Boolean;
    BEGIN
      // BuscaPrecioSuplementoCompra
      //
      // Devuelve false o true en funcion de si ha encontrado el precio o no y devuelve el
      // precio en el registro que se le pasa por parametro.
      //

      CLEAR(prPre);
      CLEAR(rtmPrecC);
      rtmPrecC.SETCURRENTKEY(Garaje,
                          "N§ Contrato",
                          "Tipo precio",
                          "Codigo servicio",
                          "Zona desde",
                          "Zona hasta",
                          "Fecha desde",
                          "Fecha hasta",
                          "Tipo Vehiculo",
                          "Rango desde",
                          "Rango hasta");
      rtmPrecC.SETRANGE (Garaje           , prCon.Garaje);
      rtmPrecC.SETRANGE ("N§ Contrato"    , NumeroContratoCompFacturacion(prCon));
      rtmPrecC.SETRANGE ("Tipo precio"    , rtmPrecC."Tipo precio"::"Suplemento zona");
      rtmPrecC.SETRANGE ("Codigo servicio", prParte."Codigo Servicio");
      rtmPrecC.SETRANGE ("Zona desde"     , pwDesde);
      rtmPrecC.SETRANGE ("Zona hasta"     , pwHasta);
      rtmPrecC.SETFILTER("Fecha desde"    , '<=%1', prParte."Fecha facturacion");
      rtmPrecC.SETFILTER("Fecha hasta"    , '>=%1', prParte."Fecha facturacion");
      rtmPrecC.SETRANGE ("Tipo Vehiculo"  , prParte."Tipo Vehiculo facturacion");
      rtmPrecC.SETRANGE ("Tipo Servicio"  , prParte."Tipo Servicio");
      rtmPrecC.SETRANGE (Activo           , TRUE);

      lwEnc:= rtmPrecC.FINDFIRST;
      IF NOT lwEnc THEN BEGIN
        rtmPrecC.SETRANGE("Codigo servicio", '');
        lwEnc:= rtmPrecC.FINDFIRST;
      END;
      IF NOT lwEnc THEN BEGIN
        rtmPrecC.SETRANGE("Tipo Vehiculo", '');
        lwEnc:= rtmPrecC.FINDFIRST;
      END;
      IF NOT lwEnc THEN BEGIN
        rtmPrecC.SETRANGE("Tipo Servicio", '');
        lwEnc:= rtmPrecC.FINDFIRST;
      END;

      IF lwEnc THEN
        prPre := rtmPrecC;

      EXIT(lwEnc);
    END;

    PROCEDURE BorrarOtrosTo@27(prParte@1100244000 : Record 7010360;pwTTOO@1100244001 : Code[10]);
    BEGIN
      // BorrarOtrosTo
      //
      // Borrar todos las lineas de ingreso de los touroperadores que no sean el de mayor importe.

      CASE prParte."Tipo Calculo" OF
        prParte."Tipo Calculo"::Margen:
        BEGIN
          CLEAR(rtmMar);
          rtmMar[1].SETCURRENTKEY(Usuario, "N§ Parte", Touroperador);
          rtmMar[1].SETRANGE (Usuario     , USERID);
          rtmMar[1].SETRANGE ("N§ Parte"  , prParte."N§ Parte");
          rtmMar[1].SETFILTER(Touroperador, '<>%1', pwTTOO);
          IF rtmMar[1].FINDSET(TRUE) THEN
            rtmMar[1].DELETEALL;
        END;
        prParte."Tipo Calculo"::Confirmacion:
        BEGIN
          CLEAR(rtmProdIng);
          rtmProdIng[1].SETCURRENTKEY("N§ Parte",
                                      Touroperador);
          rtmProdIng[1].SETRANGE ("N§ Parte"   , prParte."N§ Parte");
          rtmProdIng[1].SETFILTER(Touroperador , '<>%1', pwTTOO);
          rtmProdIng[1].SETRANGE ("Linea abono", FALSE);
          IF rtmProdIng[1].FINDSET(TRUE) THEN
            rtmProdIng[1].DELETEALL;
        END;
      END;
    END;

    PROCEDURE RepartirIngresoTo@24(prParte@1100244000 : Record 7010360);
    VAR
      lrToPar2@1100253000 : TEMPORARY Record 7010365;
      lwTotalLinea@1100244014 : Decimal;
      lwTotalLineaSin@1100253001 : Decimal;
      lwTotalAd@1100253005 : Integer;
      lwTotalNi@1100253002 : Integer;
      lwAd@1100253003 : Integer;
      lwNi@1100253004 : Integer;
    BEGIN
      // RepartirIngresoTo
      // Repartir cada linea de ingreso proporcionalmente entre todos los touroperadores.

      lrToPar2.COPY(rtmTOPar); // Copiamos el puntero para dejarlo como estaba

      // Buscamos los Totales Pax
      CLEAR(rtmTOPar);
      CLEAR(lwTotalAd);
      CLEAR(lwTotalNi);
      rtmTOPar.SETRANGE("N§ Parte", prParte."N§ Parte");
      IF rtmTOPar.FINDSET THEN BEGIN  // Sumamos el total pax en una primera vuelta
        REPEAT
          lwTotalAd += rtmTOPar."Adultos transportados" - rtmTOPar."Adultos invitados ingreso";
          lwTotalNi += rtmTOPar."Ni¤os transportados" - rtmTOPar."Ni¤os invitados ingreso";
        UNTIL rtmTOPar.NEXT=0;
      END;

      CLEAR(lwTotalLinea);
      CLEAR(lwTotalLineaSin);

      CASE prParte."Tipo Calculo" OF
        prParte."Tipo Calculo"::Margen: BEGIN
          CLEAR(rtmMar);
          rtmMar[1].SETRANGE(Usuario             , USERID);
          rtmMar[1].SETRANGE("N§ Parte"          , prParte."N§ Parte");
          rtmMar[1].SETRANGE(Concepto            , rtmMar[1].Concepto::Ingreso);
          rtmMar[1].SETRANGE("Tipo linea"        , rtmMar[1]."Tipo linea"::Base);
          rtmMar[1].SETRANGE("Porcentaje reparto", 0);
          IF rtmMar[1].FINDSET THEN BEGIN
            REPEAT
              IF rtmTOPar.FINDSET THEN BEGIN
                REPEAT
                  lwAd := rtmTOPar."Adultos transportados" - rtmTOPar."Adultos invitados ingreso";
                  lwNi := rtmTOPar."Ni¤os transportados" - rtmTOPar."Ni¤os invitados ingreso";
                  ProporcionalToMargen(rtmMar[1], rtmTOPar , lwAd, lwNi, lwTotalLinea, lwTotalAd, lwTotalNi, rtmMar[3], lwTotalLineaSin)
      ;
                UNTIL rtmTOPar.NEXT=0;
              END;
              IF lwTotalLinea <> rtmMar[1]."Importe con impuesto" THEN BEGIN
                rtmMar[3].VALIDATE("Importe con impuesto", rtmMar[3]."Importe con impuesto" +
                                            (rtmMar[1]."Importe con impuesto" - lwTotalLinea));
                rtmMar[3].MODIFY;
              END;
              rtmMar[2] := rtmMar[1];
              rtmMar[2].DELETE;
            UNTIL rtmMar[1].NEXT = 0;
          END;
        END;

        prParte."Tipo Calculo"::Confirmacion:
        BEGIN
          CLEAR(rtmProdIng);
          rtmProdIng[1].SETRANGE("N§ Parte"          , prParte."N§ Parte");
          rtmProdIng[1].SETRANGE("Tipo linea"        , rtmProdIng[1]."Tipo linea"::Base);
          rtmProdIng[1].SETRANGE("Porcentaje reparto", 0);
          rtmProdIng[1].SETRANGE("Linea abono"       , FALSE);
          IF rtmProdIng[1].FINDSET THEN BEGIN
            REPEAT
              IF rtmTOPar.FINDSET THEN BEGIN
                REPEAT
                  lwAd := rtmTOPar."Adultos transportados" - rtmTOPar."Adultos invitados ingreso";
                  lwNi := rtmTOPar."Ni¤os transportados" - rtmTOPar."Ni¤os invitados ingreso";
                  ProporcionalToIngreso(rtmProdIng[1], rtmTOPar, lwAd, lwNi, lwTotalLinea, lwTotalAd, lwTotalNi,
                                        rtmProdIng[3], lwTotalLineaSin);
                UNTIL rtmTOPar.NEXT=0;
              END;
              IF lwTotalLinea <> rtmProdIng[1]."Importe con impuesto" THEN BEGIN
                rtmProdIng[3].VALIDATE("Importe con impuesto", rtmProdIng[3]."Importe con impuesto" +
                                       (rtmProdIng[1]."Importe con impuesto" - lwTotalLinea));
                rtmProdIng[3].MODIFY;
              END;
              rtmProdIng[2] := rtmProdIng[1];
              rtmProdIng[2].DELETE;
            UNTIL rtmProdIng[1].NEXT = 0;
          END;
        END;
      END;

      rtmTOPar.COPY(lrToPar2); // Dejamos el puntero como estaba
    END;

    PROCEDURE CalculoTTOOAsociado@1100253000(prParte@1100253001 : Record 7010360);
    VAR
      lrParte2@1100253013 : Record 7010360;
      lrToPar2@1100253014 : TEMPORARY Record 7010365;
      lrCliTO@1100253002 : Record 7010313;
      lrCliTO2@1100253003 : Record 7010313;
      lrConVta@1100253005 : TEMPORARY Record 7010403;
      lrPre@1100253006 : TEMPORARY Record 7010405;
      lwImporte@1100253009 : Decimal;
      lwPrecio@1100253010 : Decimal;
      lwTipoPrecio@1100253011 : 'Pax,Vehiculo';
      lwOrDest@1100253015 : Code[10];
      lwGrupPrec@1103355000 : Code[10];
    BEGIN
      // CalculoTTOOAsociado
      //  Para TRN cliente Universal
      // Si el touroperador tiene un TTOO asociado Duplicaremos las lineas de CI o Margenes con los preci¢s del nuevo contrato

      // No contemplamos los partes gratuitos
      IF prParte.Gratuito THEN
        EXIT;

      lrParte2 := prParte;
      CLEAR(rtmTOPar);
      rtmTOPar.SETRANGE("N§ Parte", lrParte2."N§ Parte");
      IF rtmTOPar.FINDSET THEN BEGIN
        REPEAT
          CLEAR(lrCliTO);
          lrCliTO.GET(rtmTOPar."Cliente operativo", rtmTOPar.Touroperador);
          // JPT 22/07/08 DRF 08004
          lwGrupPrec := lrCliTO."Agrupa para precio con";
          IF lwGrupPrec = '' THEN
            lwGrupPrec := lrCliTO.TTOO;

          IF lrCliTO."Touroperador Asociado" <> '' THEN BEGIN
            // lrCliTO2 es el touroperador asociado
            IF lrCliTO2.GET(lrCliTO.Cliente, lrCliTO."Touroperador Asociado") THEN BEGIN

              wVentana.UPDATE(2, Text008);
              lrToPar2 := rtmTOPar;
              lrToPar2.Touroperador := lrCliTO2.TTOO;
              IF NOT BuscaContratoVenta(lrConVta, lrCliTO2.Cliente, lrCliTO2.TTOO,
                                      lrParte2."Fecha facturacion", lrParte2.Garaje) THEN BEGIN
                InsertaError(lrParte2, STRSUBSTNO(Text020,lrParte2.Cliente,lrCliTO2.TTOO,lrParte2."Fecha facturacion"), rErr.Tipo::Error
      );
                EXIT;
              END;

              // Buscamos el codigo de zona precio de Origen/Destino
              CLEAR(lwOrDest);
              CLEAR(rtmZonaC);
              rtmZonaC.SETFILTER(Garaje         , '%1|%2', prParte.Garaje, rPar."Todos los garajes");
              rtmZonaC.SETRANGE("N§ Contrato"  , NumeroContratoVentFacturacion(lrConVta));
              rtmZonaC.SETRANGE("Tipo contrato", rtmZonaC."Tipo contrato"::Venta);
              rtmZonaC.SETRANGE("Codigo Origen"  , prParte."Origen/Destino");
              IF rtmZonaC.FINDFIRST THEN
                lwOrDest := rtmZonaC."Zona Precio";


              CASE lrParte2."Tipo Calculo" OF
                lrParte2."Tipo Calculo"::Margen: BEGIN

                  CLEAR(rtmMar);
                  rtmMar[2].SETCURRENTKEY(Usuario,"N§ Parte",Touroperador,Concepto,"Tipo linea");
                  rtmMar[2].SETRANGE(Usuario,USERID);
                  rtmMar[2].SETRANGE("N§ Parte"     , lrParte2."N§ Parte");
                  rtmMar[2].SETRANGE(Touroperador   , lrCliTO.TTOO);
                  rtmMar[2].SETRANGE(Concepto       , rtmMar[2].Concepto::Ingreso);
                  IF rtmMar[2].FINDSET THEN BEGIN
                    REPEAT
                      CLEAR(lwTipoPrecio);
                      CLEAR(lwImporte);
                      CLEAR(lwPrecio);
                      IF NOT rtmMar[2]."Precio manual" THEN
                        BuscaPrecioVenta(lrParte2, lrConVta, lrPre, rtmMar[2]."Zona Precios",'', rtmMar[2]."Pax Transportados", lwOrDest
      ,
                                          rtmMar[2]."Pax Transportados", lrToPar2."Pax Transportados", lwGrupPrec);

                      CASE rtmMar[2]."Tipo linea" OF
                        rtmMar[2]."Tipo linea"::Base, rtmMar[2]."Tipo linea"::Suplemento :BEGIN
                          IF (rtmMar[2]."Tipo linea"=rtmMar[2]."Tipo linea"::Suplemento) AND
                             (rtmMar[2]."Tipo elemento" = rPar."Codigo Maletas")  THEN BEGIN
                            lwImporte := rtmMar[2].Importe
                          END
                          ELSE BEGIN
                            CASE rtmMar[2]."Tipo elemento" OF
                              Text000             : BEGIN
                                lwImporte    := lrPre."Precio Vehiculo";
                                lwPrecio     := lrPre."Precio Vehiculo";
                                lwTipoPrecio := lwTipoPrecio::Vehiculo;
                              END;
                              rPar."Codigo Adulto": BEGIN
                                lwPrecio     := lrPre."Precio Adulto";
                                lwImporte    := lrPre."Precio Adulto" * rtmMar[2].Pax;
                                lwTipoPrecio := lwTipoPrecio::Pax;
                              END;
                              rPar."Codigo Ni¤o"  : BEGIN
                                lwPrecio     := lrPre."Precio Ni¤o";
                                lwImporte    := lrPre."Precio Ni¤o" * rtmMar[2].Pax;
                                lwTipoPrecio := lwTipoPrecio::Pax;
                              END;
                            END;
                          END;
                        END;
                        rtmMar[2]."Tipo linea"::Manual, rtmMar[2]."Tipo linea"::Extra : BEGIN
                          IF rtmMar[2]."Precio Pax" =0 THEN
                            lwTipoPrecio := lwTipoPrecio::Vehiculo;
                          CASE lwTipoPrecio OF
                            lwTipoPrecio::Pax     : lwPrecio := rtmMar[2]."Precio Pax";
                            lwTipoPrecio::Vehiculo: lwPrecio := rtmMar[2]."Precio Vehiculo";
                          END;
                          lwImporte   := rtmMar[2].Importe;
                        END;
                      END;

                      IF rtmMar[2]."Precio manual" THEN BEGIN
                        IF rtmMar[2]."Precio Pax" =0 THEN
                          lwTipoPrecio := lwTipoPrecio::Vehiculo;
                        CASE lwTipoPrecio OF
                          lwTipoPrecio::Pax     : lwPrecio := rtmMar[2]."Precio Pax";
                          lwTipoPrecio::Vehiculo: lwPrecio := rtmMar[2]."Precio Vehiculo";
                        END;
                        lwImporte   := rtmMar[2].Importe;
                      END;

                      lrParte2.Facturable:= TRUE;
                      InsertaLinea (rtmMar[2]."Zona Precios",
                                    rtmMar[2]."Tipo linea",
                                    rtmMar[2]."Cod. Divisa",
                                    lwImporte,
                                    lrCliTO2.TTOO,
                                    rtmMar[2]."Precio manual",
                                    rtmMar[2].Concepto,
                                    lwPrecio,
                                    lwTipoPrecio,
                                    lrConVta."N§ Contrato",
                                    rtmMar[2]."Tipo elemento",
                                    lrParte2,
                                    rtmMar[2]."Pax Facturados",
                                    rtmMar[2]."Pax Transportados",
                                    '',
                                    '');
                    UNTIL rtmMar[2].NEXT=0;
                  END;
                END;

               // CONFIRMACION *******************************************************************************
                lrParte2."Tipo Calculo"::Confirmacion: BEGIN

                  CLEAR(rtmProdIng);
                  rtmProdIng[2].SETCURRENTKEY("N§ Parte", Touroperador);
                  rtmProdIng[2].SETRANGE("N§ Parte"     , lrParte2."N§ Parte");
                  rtmProdIng[2].SETRANGE(Touroperador   , lrCliTO.TTOO);
                  IF rtmProdIng[2].FINDSET THEN BEGIN
                    REPEAT
                      CLEAR(lwImporte);
                      CLEAR(lwPrecio);
                      IF NOT rtmProdIng[2]."Precio manual" THEN
                        BuscaPrecioVenta(lrParte2, lrConVta, lrPre, rtmProdIng[2]."Zona Precios" , '',
                                         rtmProdIng[2]."Pax Transportados", lwOrDest, rtmProdIng[2]."Pax Transportados",
                                         lrToPar2."Pax Transportados", lwGrupPrec);

                      CASE rtmProdIng[2]."Tipo linea" OF
                        rtmProdIng[2]."Tipo linea"::Base, rtmProdIng[2]."Tipo linea"::Suplemento :BEGIN
                          IF (rtmProdIng[2]."Tipo linea" = rtmProdIng[2]."Tipo linea"::Suplemento) AND
                             (rtmProdIng[2]."Tipo elemento" = rPar."Codigo Maletas")  THEN BEGIN
                            lwImporte := rtmProdIng[2].Importe
                          END
                          ELSE BEGIN
                            CASE rtmProdIng[2]."Tipo elemento" OF
                              Text000             : BEGIN
                                lwImporte  := lrPre."Precio Vehiculo";
                                lwPrecio   := lrPre."Precio Vehiculo";
                                lwTipoPrecio := lwTipoPrecio::Vehiculo;
                              END;
                              rPar."Codigo Adulto": BEGIN
                                lwPrecio     := lrPre."Precio Adulto";
                                lwImporte    := lrPre."Precio Adulto" * rtmProdIng[2].Pax;
                                lwTipoPrecio := lwTipoPrecio::Pax;
                              END;
                              rPar."Codigo Ni¤o"  : BEGIN
                                lwPrecio     := lrPre."Precio Ni¤o";
                                lwImporte    := lrPre."Precio Ni¤o" * rtmProdIng[2].Pax;
                                lwTipoPrecio := lwTipoPrecio::Pax;
                              END;
                            END;
                          END;
                        END;
                        rtmProdIng[2]."Tipo linea"::Manual, rtmProdIng[2]."Tipo linea"::Extra : BEGIN
                          IF rtmProdIng[2]."Precio Pax" =0 THEN
                            lwTipoPrecio := lwTipoPrecio::Vehiculo;
                          CASE lwTipoPrecio OF
                            lwTipoPrecio::Pax     : lwPrecio := rtmProdIng[2]."Precio Pax";
                            lwTipoPrecio::Vehiculo: lwPrecio := rtmProdIng[2]."Precio Vehiculo";
                          END;
                          lwImporte   := rtmProdIng[2].Importe;
                        END;
                      END;

                      IF rtmProdIng[2]."Precio manual" THEN BEGIN
                        IF rtmProdIng[2]."Precio Pax" =0 THEN
                          lwTipoPrecio := lwTipoPrecio::Vehiculo;
                        CASE lwTipoPrecio OF
                          lwTipoPrecio::Pax     : lwPrecio := rtmProdIng[2]."Precio Pax";
                          lwTipoPrecio::Vehiculo: lwPrecio := rtmProdIng[2]."Precio Vehiculo";
                        END;
                        lwImporte   := rtmProdIng[2].Importe;
                      END;

                      lrParte2.Facturable:= TRUE;
                      InsertaLinea (rtmProdIng[2]."Zona Precios",
                                    rtmProdIng[2]."Tipo linea",
                                    rtmProdIng[2]."Cod. Divisa",
                                    lwImporte,
                                    lrCliTO2.TTOO,
                                    rtmProdIng[2]."Precio manual",
                                    0,                              // 0 = Ingreso
                                    lwPrecio,
                                    lwTipoPrecio,
                                    lrConVta."N§ Contrato",
                                    rtmProdIng[2]."Tipo elemento",
                                    lrParte2,
                                    rtmProdIng[2]."Pax Facturados",
                                    rtmProdIng[2]."Pax Transportados",
                                    rtmProdIng[2]."Concepto facturacion",
                                    '');
                    UNTIL rtmProdIng[2].NEXT = 0;
                  END;
                END;
              END;


            IF lrConVta."Maletas incluidas" THEN
              DescontarMaletas(1, lrParte2, lrToPar2, '', lrConVta."N§ Contrato");
            END;
          END;
        UNTIL rtmTOPar.NEXT=0;
      END;
    END;

    PROCEDURE GetPrecioVta@1100253028(VAR prPrecV@1100253001 : TEMPORARY Record 7010405) : Boolean;
    VAR
      lwEnc@1100253000 : Boolean;
    BEGIN
      // GetPrecioVta
      // Devuelve el registro de Precio Vta dada la clave primaria

      CLEAR(rtmPrecV);
      rtmPrecV := prPrecV;
      lwEnc := rtmPrecV.FIND;
      IF lwEnc THEN
        prPrecV:= rtmPrecV
      ELSE
        CLEAR(prPrecV);
      EXIT(lwEnc);
    END;

    PROCEDURE GetPrecision@1100253014(pwTipo@1100253000 : 'Ingreso,Coste') : Decimal;
    BEGIN
      // GetPrecision
      // Devuelve la precisi¢n del ultimo contrato encontrado

      CASE pwTipo OF
        pwTipo::Ingreso : EXIT(wPrecisionIngreso);
        pwTipo::Coste   : EXIT(wPrecisionCoste);
      END;
    END;

    PROCEDURE BuscaContratoReal@1100244000(VAR prContV@1100244000 : TEMPORARY Record 7010403);
    VAR
      lrContV2@1100253000 : TEMPORARY Record 7010403;
    BEGIN
      // BuscaContratoReal
      // Si el contrato hace referencia a otro devuelve el contrato que tiene los precios

      lrContV2.COPY(rtmConV);
      rtmConV.RESET;
      rtmConV := prContV;
      WHILE rtmConV."Basado en contrato n§" <> '' DO BEGIN
        rtmConV.SETRANGE("N§ Contrato", rtmConV."Basado en contrato n§");
        IF NOT rtmConV.FINDFIRST THEN
          CLEAR(rtmConV);
      END;
      prContV := rtmConV;
      rtmConV.COPY(lrContV2); // Dejamos el puntero tal y como estaba;
    END;

    PROCEDURE RepasaTTOOs@1103355002(VAR prParte@1103355000 : Record 7010360);
    VAR
      lrSerPar@1103355001 : Record 7010359;
      lrTTOOxParte@1103355002 : Record 7010365;
    BEGIN
      // RepasaTTOOs

      // JPT 08/04/08 Si le falta algun TTOOxParte lo creamos

      lrSerPar.SETCURRENTKEY("N§ Parte",
                             Touroperador,
                             "Hora recogida");
      lrSerPar.SETRANGE("N§ Parte"            , prParte."N§ Parte");

      // AJS 22.07.2008
      // Filtramos unicamente por las lineas que tienen paxes transportados

      lrSerPar.SETFILTER("Paxes transportados", '<>%1', 0);

      IF lrSerPar.FINDSET THEN BEGIN
        REPEAT
          IF lrSerPar.Touroperador <> '' THEN BEGIN
            IF NOT lrTTOOxParte.GET(lrSerPar."N§ Parte", lrSerPar.Touroperador) THEN BEGIN
              lrSerPar.es_alta(TRUE);
              lrSerPar.mantener_touroperador_parte(prParte);
            END;
          END;
        UNTIL lrSerPar.NEXT=0;
      END;
    END;

    PROCEDURE BuscaZonaFacturacion@1103355006(pwContrato@1103355000 : Code[10];pwZonaPrecio@1103355001 : Code[10];pwTipoServicio@1103355003 : Integer) : Code[10];
    VAR
      lrZona@1103355002 : Record 7010404;
      lrCont@1103355004 : Record 7010403;
    BEGIN
      // BuscaZonaFacturacion

      lrCont.RESET;
      lrCont.SETRANGE("N§ Contrato", pwContrato);
      lrCont.FINDFIRST;

      lrZona.RESET;
      lrZona.SETRANGE("N§ Contrato"  , NumeroContratoVentFacturacion(lrCont));
      lrZona.SETRANGE("Tipo contrato", lrZona."Tipo contrato"::Venta);
      lrZona.SETRANGE("Zona Precio"  , pwZonaPrecio);

      // AJS 30.06.2008, TNU08002
      // Filtramos por el tipo de servicio fijo del parte de trabajo

      lrZona.SETRANGE("Tipo Servicio fijo", pwTipoServicio);

      lrZona.FINDFIRST;

      EXIT(lrZona."Zona facturacion");
    END;

    PROCEDURE SumaPaxPrecioVenta@1103355009(VAR prParte@1103355000 : Record 7010360;pwZona@1103355002 : Code[10];pwGrupo@1103355003 : Code[10]) : Decimal;
    VAR
      lrtmZonPre2@1103355001 : TEMPORARY Record 7010364;
      lwTotal@1103355004 : Decimal;
    BEGIN
      // SumaPaxPrecioVenta

      CLEAR(lwTotal);
      // Hacemos una copia del puntero para dejarlo como estaba al final de la funci¢n
      lrtmZonPre2.COPY(rtmZonPre);

      CLEAR(rtmZonPre);

      IF prParte."Busca precio pasaje x zona ing" THEN
        rtmZonPre.SETRANGE("Zona Precio", pwZona);
      IF prParte."Busca precio ingreso" = prParte."Busca precio ingreso"::"Pasaje independiente" THEN
        rtmZonPre.SETRANGE("Grupo Precio", pwGrupo);
      IF rtmZonPre.FINDSET THEN BEGIN
        REPEAT
          lwTotal += rtmZonPre."Adultos facturados zona" + rtmZonPre."Ni¤os facturados zona";
        UNTIL rtmZonPre.NEXT=0;
      END;

      // Dejamos el puntero tal y como estaba antes de entrar en la funci¢n
      rtmZonPre.COPY(lrtmZonPre2);

      EXIT(lwTotal);
    END;

    PROCEDURE SetCostesTTOOseparados@1103355007(VAR prPorSeparado@1103355000 : Boolean);
    BEGIN
      // SetCostesTTOOseparados
      // Marcamos la variable que se ocupa de indicar si los costes se calculan como un solo touroperador
      // o con los touroperadores por separado.
      // Lo usamos para saber como actuar  la busqueda de contratos de compra.

      wCosteTTOOSeparados := prPorSeparado;
    END;

    PROCEDURE RepasaParametrosCoste@1103355008(VAR prParte@1103355000 : Record 7010360);
    VAR
      lrTTOOxParte@1103355001 : Record 7010365;
    BEGIN
      // RepasaParametrosCoste
      // Repaso que las l¡neas de touroperador x parte tengan los parametros de c lculo de costes igual al parte.

      lrTTOOxParte.SETRANGE("N§ Parte", prParte."N§ Parte");

      IF lrTTOOxParte.FINDSET(TRUE) THEN
        lrTTOOxParte.MODIFYALL("Coste Precios Por", prParte."Coste Precios por");
    END;

    BEGIN
    {
      Es una Codeunit SingleInstance
      Antes del Lanzar el calculo para varias reservas hacer un BorraTemps(TRUE) para borrar temporales de contratos

      $001 AJS 20112014 Cambio la gesti¢n del calendario para utilizar la codeunit en numeracion AddOn
    }
    END.
  }
}
