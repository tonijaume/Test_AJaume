OBJECT Codeunit 7009720 Funciones varias
{
  OBJECT-PROPERTIES
  {
    Date=16/01/15;
    Time=15:50:39;
    Modified=Yes;
    Version List=AIC2009;
  }
  PROPERTIES
  {
    OnRun=VAR
            prProveedores@1103355000 : TEMPORARY Record 318;
          BEGIN
          END;

  }
  CODE
  {
    VAR
      Text000@1103355002 : TextConst 'ENU=Processing @1@@@@@@@@@@@@;ESP=Procesando @1@@@@@@@@@@@@';
      Text001@1103355003 : TextConst 'ENU=\ TABLE %1 - FIELD %2;ESP=\ TABLA %1 - CAMPO %2';
      Text002@1103355004 : TextConst 'ENU=Prices have been changed correctly;ESP=Se han cambiado los precios sin ning£n problema.';
      Text003@1103355005 : TextConst 'ENU=Problems:\;ESP=Problemas:\';
      Text004@1103355007 : TextConst 'ENU=This purchase document has already assigned a barcode, would you like to replace it?;ESP=Este documento de compra ya tiene asignado un codigo de barras, desea sustituirlo ?';
      Text005@1103355006 : TextConst 'ENU=Cancelled modification.;ESP=Modificacion cancelada.';
      rPar@1103355008 : Record 7009700;
      Text006@1103355009 : TextConst 'ENU=Duplicated barcode with %1 %2.;ESP=Codigo de barras duplicado con %1 %2.';
      autFileSystem@1103355010 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
      Text007@1103355011 : TextConst 'ENU=Purchase documents;ESP=Documentos Compra';
      Text008@1103355012 : TextConst 'ENU=Related scanned document does not exist;ESP=El documento escaneado asociado no existe.';
      Text009@1103355013 : TextConst 'ENU=Hotel confirmations;ESP=Confirmaciones hotel';
      Text010@1103355014 : TextConst 'ENU=Label for this bank statement has already been printed;ESP=Ya se han impreso etiquetas para este extracto bancario.';
      Text011@1103355015 : TextConst 'ENU=Bank statements;ESP=Extractos bancarios';
      Text012@1103355016 : TextConst 'ENU=PDF file related to the bank statement does not exist;ESP=No existe el fichero PDF ligado al extracto bancario.';
      wTipoRegistro@1103355017 : 'Doc Compra,Conf Hotel,Ext Banco';
      Text013@1103355018 : TextConst 'ENU=C:\FundsRequest\;ESP=C:\FundsRequest\';
      Text014@1103355019 : TextConst 'ENU=File %1 does not exist, if registration date is after 01.05.2007 consult your administrator;ESP=No existe el fichero %1, si la fecha de registro es posterior al 01.05.2007 consulte con su administrador';
      Text015@1103355020 : TextConst 'ENU=Must print a label before assigning confirmation number to booking;ESP=Se debe imprimir una etiqueta antes de asignar numero de confirmacion a la reserva.';
      Text016@1103355021 : TextConst 'ENU=C:\InformesEBB\;ESP=C:\InformesEBB\';
      Text017@1103355022 : TextConst 'ENU=EBB Reports;ESP=Informes EBB';
      Text018@1103355023 : TextConst 'ENU=Print;ESP=Imprimir';
      Text021@1103355026 : TextConst 'ENU=PRINT;ESP=PRINT';
      Text019@1103355024 : TextConst 'ENU=Text019;ESP=Text019';
      Text020@1103355025 : TextConst 'ENU=ftp.cmd;ESP=ftp.cmd';
      Text031@1103355036 : TextConst 'ENU=Directory %1 does not exist or not accessible by now;ESP=El directorio %1 no existe o no est  accesible en este momento.';
      Text032@1103355035 : TextConst 'ENU=Would you like to continue(Yes) or exit(No)?;ESP=¨Desea continuar(Si) o abortar(No)?';
      Text033@1103355034 : TextConst 'ENU=There is no unit for directory %1 or it does not have permissions to read.;ESP=No existe unidad para el directorio %1 o no tiene permiso de lectura.';
      Text034@1103355033 : TextConst 'ENU=No permission to write for the directory %1.;ESP=No tiene permiso de escritura para el directorio %1.';
      Text035@1103355032 : TextConst 'ENU=Would you like to try to create the directory?;ESP=¨Desea tratar de crear el directorio?';
      Text036@1103355031 : TextConst 'ENU=\~zzzzz.zzz;ESP=\~zzzzz.zzz';
      Text037@1103355030 : TextConst 'ENU=File %1 does not exist;ESP=No existe el fichero %1.';
      Text038@1103355029 : TextConst 'ENU=Route %1 does not exist;ESP=No existe la ruta %1.';
      Text039@1103355028 : TextConst 'ENU=File %1 already exists in destination route. Would you like to rename the file?;ESP=El fichero %1 ya existe en la ruta destino. ¨Desea renombrar el fichero?';
      Text040@1103355027 : TextConst 'ENU=File %1 already exists in destination route;ESP=El fichero %1 ya existe en la ruta destino';

    PROCEDURE IsLapYear@4(year@1103355000 : Integer) value : Boolean;
    BEGIN
      // IsLapYear

      EXIT((year MOD 4 = 0) AND ((year MOD 100 <> 0) OR (year MOD 400 = 0)));
    END;

    PROCEDURE DaysPerMonth@1(month@1103355000 : Integer;year@1103355001 : Integer) days : Integer;
    VAR
      DaysInMonth@1103355002 : ARRAY [12] OF Integer;
      d@1103355003 : Integer;
    BEGIN
      // DaysPerMonth
      //
      DaysInMonth[1]:=31;
      DaysInMonth[2]:=28;
      DaysInMonth[3]:=31;
      DaysInMonth[4]:=30;
      DaysInMonth[5]:=31;
      DaysInMonth[6]:=30;
      DaysInMonth[7]:=31;
      DaysInMonth[8]:=31;
      DaysInMonth[9]:=30;
      DaysInMonth[10]:=31;
      DaysInMonth[11]:=30;
      DaysInMonth[12]:=31;

      d := DaysInMonth[month];
      IF (month = 2) AND (IsLapYear(year)) THEN
        d := d + 1;

      EXIT(d);
    END;

    PROCEDURE SustituirDocumentoFactura@1103355000(pwAntCodigoBarras@1103355002 : Code[20]);
    VAR
      lwNomFichero@1103355001 : Text[250];
    BEGIN
      // SustituirDocumentoFactura

      IF NOT CONFIRM(Text004) THEN
        ERROR(Text005);

      //-$003rPar.FINDFIRST;
      //-$003rPar.TESTFIELD("Ruta ficheros PDF");

      //-$003lwNomFichero := rPar."Ruta ficheros PDF" + '\'  + pwAntCodigoBarras + '.PDF';
      //-$003IF EXISTS(lwNomFichero) THEN
      //-$003  ERASE(lwNomFichero);
    END;

    PROCEDURE CheckCodBarrasCompraDuplicado@1103355001(pwCodBarras@1103355003 : Code[20];pwNumFactura@1103355004 : Code[20]);
    VAR
      PurchHeader@1103355000 : Record 38;
      PurchInvHeader@1103355001 : Record 122;
      PurchCrMemoHeader@1103355002 : Record 124;
    BEGIN
      // CheckCodBarrasCompraDuplicado

      // Vamos a comprobar duplicidad en cab compra

      PurchHeader.RESET;
      PurchHeader.SETRANGE ("Codigo barras PDF", pwCodBarras);
      PurchHeader.SETFILTER("No."              , '<>%1', pwNumFactura);
      IF PurchHeader.FINDFIRST THEN
        ERROR(Text006, PurchHeader."Document Type", PurchHeader."No.");

      // Lo buscamos en facturas registradas

      PurchInvHeader.RESET;
      PurchInvHeader.SETRANGE("Codigo barras PDF", pwCodBarras);
      PurchInvHeader.SETRANGE("No."              , '<>%1', pwNumFactura);
      IF PurchInvHeader.FINDFIRST THEN
        ERROR(Text006, PurchHeader."Document Type"::Invoice, PurchInvHeader."No.");

      // Lo buscamos en abonos registrados

      PurchCrMemoHeader.RESET;
      PurchCrMemoHeader.SETRANGE("Codigo barras PDF", pwCodBarras);
      PurchCrMemoHeader.SETRANGE("No."              , '<>%1', pwNumFactura);
      IF PurchCrMemoHeader.FINDFIRST THEN
        ERROR(Text006, PurchHeader."Document Type"::"Credit Memo", PurchCrMemoHeader."No.");
    END;

    PROCEDURE RegistrarDocCompraEscaneado@1103355002(pwCodBarras@1103355000 : Code[20];pwFechaRegistro@1103355001 : Date);
    VAR
      lwNomFicheroDestino@1103355002 : Text[250];
      lwNomFicheroOrigen@1103355004 : Text[250];
      lwExist@1103355003 : ARRAY [2] OF Boolean;
    BEGIN
      // RegistrarDocCompraEscaneado

      rPar.FINDFIRST;
      rPar.TESTFIELD("Ruta ficheros PDF");

      // Instanciamos el Automation
      CLEAR(autFileSystem);
      IF NOT CREATE(autFileSystem) THEN
        EXIT;

      // Comprobamos si existe la ruta de carpetas

      lwNomFicheroDestino := rPar."Ruta ficheros PDF" + '\' + Text007 + '\';

      IF NOT autFileSystem.FolderExists(lwNomFicheroDestino) THEN
        autFileSystem.CreateFolder(lwNomFicheroDestino);

      lwNomFicheroDestino := lwNomFicheroDestino + '\' + FORMAT(pwFechaRegistro, 0, '<Year4>');

      IF NOT autFileSystem.FolderExists(lwNomFicheroDestino) THEN
        autFileSystem.CreateFolder(lwNomFicheroDestino);

      lwNomFicheroDestino := lwNomFicheroDestino + '\' + FORMAT(pwFechaRegistro, 0, '<Month,2>');
      IF NOT autFileSystem.FolderExists(lwNomFicheroDestino) THEN
        autFileSystem.CreateFolder(lwNomFicheroDestino);

      // Comprobar si existe el fichero PDF y lo movemos a la carpeta destino

      lwNomFicheroOrigen  := rPar."Ruta ficheros PDF" + '\' + pwCodBarras + '.PDF';
      lwNomFicheroDestino := lwNomFicheroDestino + '\' + pwCodBarras + '.PDF';

      CLEAR(lwExist);
      lwExist[1] := autFileSystem.FileExists(lwNomFicheroOrigen);
      lwExist[2] := autFileSystem.FileExists(lwNomFicheroDestino);
      // JPT 02/07/08 Si no se encuentra en origen pero si en destino se supone que ya se ha traspasado
      IF lwExist[2] AND (NOT lwExist[1]) THEN BEGIN
        CLEAR(autFileSystem);
        EXIT;
      END;

      IF lwExist[1] THEN
        autFileSystem.MoveFile(lwNomFicheroOrigen, lwNomFicheroDestino)
      ELSE BEGIN
        IF pwFechaRegistro >= 010507D THEN
          ERROR(Text008);
      END;

      CLEAR(autFileSystem);
    END;

    PROCEDURE AnularDocCompraEscaneado@1103355003(pwCodBarras@1103355000 : Code[20];pwFechaRegistro@1103355001 : Date);
    VAR
      lwNomFicheroDestino@1103355002 : Text[250];
      lwNomFicheroOrigen@1103355004 : Text[250];
      lwOk@1103355003 : Boolean;
    BEGIN
      // AnularDocCompraEscaneado

      rPar.FINDFIRST;
      rPar.TESTFIELD("Ruta ficheros PDF");

      // Instanciamos el Automation

      IF NOT CREATE(autFileSystem) THEN
        EXIT;

      // Comprobar si existe el fichero PDF y lo movemos a la carpeta destino

      lwNomFicheroOrigen := rPar."Ruta ficheros PDF" + '\' +
                            Text007 + '\' +
                            FORMAT(pwFechaRegistro, 0, '<Year4>') + '\' +
                            FORMAT(pwFechaRegistro, 0, '<Month,2>');

      lwNomFicheroOrigen  := lwNomFicheroOrigen + '\' + pwCodBarras + '.PDF';
      lwNomFicheroDestino := rPar."Ruta ficheros PDF" + '\' + pwCodBarras + '.PDF';

      IF autFileSystem.FileExists(lwNomFicheroOrigen) THEN
        autFileSystem.MoveFile(lwNomFicheroOrigen, lwNomFicheroDestino)
    END;

    PROCEDURE MantenMarcaArchivo@1103355021(pwFuncion@1103355002 : 'Eliminar,Crear';pwTipoDoc@1103355000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order,Receipt,Posted Invoice,Posted Credit Memo,Posted Return Shipment';psNumDoc@1103355001 : Code[20]);
    VAR
      lrLin@1103355003 : Record 43;
      lwEnc@1103355004 : Boolean;
      lText0001@1103355005 : TextConst 'ENU=PDF file could not be moved to final folder;ESP=El archivo PDF no se pudo mover a su carpeta definitiva';
    BEGIN
      // MantenMarcaArchivo
      // JPT 11/03/08 En cuanto se registra una factura de compra se mueve el archivo PDF de una carpeta
      // a otra. Si se registra primero y luego se mueve se corre el peligro que se registre el documento
      // y por alg£n error no se mueva y al rev‚s, si se mueve y luego se registra est  el peligro de que
      // se mueva y que no quede registrado.

      // Es por eso de esta funci¢n: antes de registrar se inserta una linea de comentario con numeraci¢n
      // -1 que una vez registrado el docuemento y movido el archivo se elimina. Si se encuentra quiere decir
      // que la factura se ha registrado pero no se ha movido el archivo.

      // Solo para facturas y abonos
      IF NOT (pwTipoDoc IN [pwTipoDoc::Invoice,pwTipoDoc::"Credit Memo",pwTipoDoc::"Posted Invoice",pwTipoDoc::"Posted Credit Memo"])
      THEN
        EXIT;

      CLEAR(lrLin);
      lwEnc := lrLin.GET(pwTipoDoc,psNumDoc,-1);

      CASE pwFuncion OF
        pwFuncion::Eliminar : IF lwEnc THEN
                                lrLin.DELETE;
        pwFuncion::Crear    : IF NOT lwEnc THEN BEGIN
                                CLEAR(lrLin);
                                lrLin."Document Type" := pwTipoDoc;
                                lrLin."No."           := psNumDoc;
                                lrLin."Line No."      := -1;
                                lrLin.Comment         := lText0001;
                                lrLin.Date            := TODAY;
                                lrLin.INSERT;
                              END;
      END;
    END;

    PROCEDURE AseguraTraspasoArchivo@1103355022(pwTipoDoc@1103355001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order,Receipt,Posted Invoice,Posted Credit Memo,Posted Return Shipment';psNumDoc@1103355000 : Code[20];pwCodBarras@1103355003 : Code[20];pwFechaRegistro@1103355002 : Date);
    VAR
      lrLin@1103355005 : Record 43;
      lwEnc@1103355004 : Boolean;
    BEGIN
      // AseguraTraspasoArchivo
      // Si no se ha traspasado el archivo lo vuelve a intentar

      // Solo para facturas y abonos
      IF NOT (pwTipoDoc IN [pwTipoDoc::Invoice,pwTipoDoc::"Credit Memo",pwTipoDoc::"Posted Invoice",pwTipoDoc::"Posted Credit Memo"])
      THEN
        EXIT;

      CLEAR(lrLin);
      lwEnc := lrLin.GET(pwTipoDoc,psNumDoc,-1);

      // Mueve y luego elimina el registro
      IF lwEnc THEN BEGIN
         RegistrarDocCompraEscaneado(pwCodBarras, pwFechaRegistro);
         MantenMarcaArchivo(0, pwTipoDoc, psNumDoc);
         SLEEP(300); // Guarda un tiempo a dejar grabar el archivo para que pueda abrirse inmediatamente
      END;
    END;

    PROCEDURE VisualizaDocCompraPendiente@1103355019(pwCodBarras@1103355000 : Code[20]);
    VAR
      lwNombreFichero@1103355001 : Text[250];
    BEGIN
      // VisualizaDocCompraPendiente

      // Abrir el pdf asignado a un documento de compra

      IF pwCodBarras = '' THEN
        EXIT;

      // Instanciamos el Automation

      IF NOT CREATE(autFileSystem) THEN
        EXIT;

      rPar.FINDFIRST;
      rPar.TESTFIELD("Ruta ficheros PDF");

      lwNombreFichero := rPar."Ruta ficheros PDF" + '\' + pwCodBarras + '.PDF';

      IF autFileSystem.FileExists(lwNombreFichero) THEN
        HYPERLINK(lwNombreFichero)
      ELSE
        ERROR(Text014, lwNombreFichero);
    END;

    PROCEDURE VisualizaDocCompra@1103355004(pwCodBarras@1103355000 : Code[20];pwFechaRegistro@1103355002 : Date);
    VAR
      lwNombreFichero@1103355001 : Text[250];
    BEGIN
      // VisualizaDocCompra

      // Abrir el pdf asignado a un documento de compra

      IF pwCodBarras = '' THEN
        EXIT;

      rPar.FINDFIRST;
      rPar.TESTFIELD("Ruta ficheros PDF");

      lwNombreFichero := rPar."Ruta ficheros PDF" + '\' +
                         Text007 + '\' +
                         FORMAT(pwFechaRegistro, 0, '<Year4>') + '\' +
                         FORMAT(pwFechaRegistro, 0, '<Month,2>') + '\' +
                         pwCodBarras + '.PDF';


      HYPERLINK(lwNombreFichero);
    END;

    PROCEDURE VisualizaDocCompraProveedor@1103355005(prMovProv@1103355000 : Record 25);
    VAR
      lrCabFra@1103355001 : Record 122;
      lrCabAbo@1103355002 : Record 124;
    BEGIN
      // VisualizaDocCompraProveedor

      IF (prMovProv."Document Type" <> prMovProv."Document Type"::Invoice) AND
         (prMovProv."Document Type" <> prMovProv."Document Type"::"Credit Memo") THEN
        EXIT;

      IF prMovProv."Document Type" = prMovProv."Document Type"::Invoice THEN BEGIN
        lrCabFra.GET(prMovProv."Document No.");
        VisualizaDocCompra(lrCabFra."Codigo barras PDF", lrCabFra."Posting Date");
      END
      ELSE BEGIN
        lrCabAbo.GET(prMovProv."Document No.");
        VisualizaDocCompra(lrCabAbo."Codigo barras PDF", lrCabAbo."Posting Date");
      END;
    END;

    PROCEDURE VisualizaDocCompraContabilidad@1103355006(prMovCon@1103355000 : Record 17);
    VAR
      lrMovProv@1103355001 : Record 25;
      lrCabFra@1103355002 : Record 122;
      lrCabAbo@1103355003 : Record 124;
    BEGIN
      // VisualizaDocCompraContabilidad

      IF prMovCon."Source Type" <> prMovCon."Source Type"::Vendor THEN
        EXIT;

      // Como todos los movimientos relacionados con una factura/abono de compra se marca con el codigo de
      // procedencia hay que hacer este GET para evitar errores

      IF lrMovProv.GET(prMovCon."Entry No.") THEN
        VisualizaDocCompraProveedor(lrMovProv)
      ELSE

      // AJS 23.06.2008
      // Mejoramos la funcion para poder ver el PDF desde cualquier movimiento asociado

      BEGIN
        IF prMovCon."Document Type" = prMovCon."Document Type"::Invoice THEN BEGIN
          lrCabFra.GET(prMovCon."Document No.");
          VisualizaDocCompra(lrCabFra."Codigo barras PDF", lrCabFra."Posting Date");
        END
        ELSE BEGIN
          lrCabAbo.GET(prMovCon."Document No.");
          VisualizaDocCompra(lrCabAbo."Codigo barras PDF", lrCabAbo."Posting Date");
        END;
      END;
    END;

    PROCEDURE ImprimirEtiquetaConfHotel@1103355008(pwHotel@1103355005 : Code[20];pwNumEnvio@1103355004 : Integer);
    VAR
      lrUsu@1103355003 : Record 7010085;
      lrConfEnvi@1103355002 : Record 7009832;
      lfFichaImpresion@1103355000 : Form 7009886;
      lwCodigoImpreso@1103355001 : Code[20];
    BEGIN
      // ImprimirEtiquetaConfHotel

      IF NOT lrUsu.GET(USERID) THEN BEGIN
        CLEAR(lrUsu);
        lrUsu.Usuario := USERID;
        lrUsu.INSERT;
      END;

      lrUsu.Hotel        := pwHotel;
      lrUsu."N§ Factura" := FORMAT(pwNumEnvio); // Utilizo el campo "N§ Factura" para mostrar el envio
      lrUsu.MODIFY;
      COMMIT;

      lrUsu.SETRECFILTER;

      CLEAR(lfFichaImpresion);
      lfFichaImpresion.SETTABLEVIEW(lrUsu);
      lfFichaImpresion.RUNMODAL;
      lfFichaImpresion.RetornaParametros(lwCodigoImpreso);

      IF lwCodigoImpreso = '' THEN
        EXIT;

      // Comprobar si se tiene que crear el registro.
      CLEAR(lrConfEnvi);
      lrConfEnvi."Num. Envio"               := pwNumEnvio;
      lrConfEnvi."Identificacion documento" := 'X' + FORMAT(TODAY, 0, '<Year4>') + FORMAT(TODAY, 0, '<Month, 2>') +
                                               lwCodigoImpreso;
      lrConfEnvi."Fecha recepcion"          := TODAY;
      lrConfEnvi.INSERT;
    END;

    PROCEDURE ValidateNumConfirmacion@1103355007(pwNumEnvio@1103355000 : Integer;pwNumConfirmacion@1103355001 : Code[20];pwDelegacion@1103355004 : Code[10];pwNumReserva@1103355005 : Integer);
    VAR
      lrConfEnvio@1103355002 : Record 7009832;
      lrConfEnvio2@1103355006 : Record 7009832;
      lfConfEnvio@1103355003 : Form 7010028;
    BEGIN
      // ValidateNumConfirmacion

      // Buscamos el ultimo fichero enlazado con el envio

      lrConfEnvio.RESET;
      lrConfEnvio.SETRANGE("Num. Envio", pwNumEnvio);

      // Filtramos por el numero de confirmacion en blanco para localizar los registros que se crean al imprimir
      // las etiquetas

      lrConfEnvio.SETRANGE("Num confirmacion hotel", '');
      IF NOT lrConfEnvio.FINDLAST THEN
        ERROR(Text015);

      // Comprobamos si para el mismo dia de recepcion tenemos m s de un fichero

      lrConfEnvio.SETRANGE("Fecha recepcion", lrConfEnvio."Fecha recepcion");
      IF lrConfEnvio.COUNT <> 1 THEN BEGIN

        // Esta commit se corresponde con la modificacion de la reserva hotel

        COMMIT;

        CLEAR(lfConfEnvio);
        lfConfEnvio.SETTABLEVIEW(lrConfEnvio);
        lfConfEnvio.LOOKUPMODE(TRUE);
        IF lfConfEnvio.RUNMODAL <> ACTION::LookupOK THEN
          ERROR(Text005);
        lfConfEnvio.GETRECORD(lrConfEnvio);
      END;

      // Rellenamos un registro en la tabla auxiliar de confirmaciones de envio para ligar la reserva
      // al fichero escaneado

      CLEAR(lrConfEnvio2);
      lrConfEnvio2."Num. Envio"               := pwNumEnvio;
      lrConfEnvio2."Identificacion documento" := lrConfEnvio."Identificacion documento";
      lrConfEnvio2."Num confirmacion hotel"   := pwNumConfirmacion;
      lrConfEnvio2.Delegacion                 := pwDelegacion;
      lrConfEnvio2."Num. Reserva"             := pwNumReserva;
      lrConfEnvio2."Fecha recepcion"          := TODAY;
      lrConfEnvio2.INSERT;
    END;

    PROCEDURE AlmacenaConfHotel@1103355009();
    VAR
      lrFicheros@1103355000 : Record 2000000022;
    BEGIN
      // AlmacenaConfHotel

      rPar.FINDFIRST;
      rPar.TESTFIELD("Ruta ficheros PDF");

      lrFicheros.RESET;
      lrFicheros.SETRANGE (Path       , rPar."Ruta ficheros PDF");
      lrFicheros.SETRANGE ("Is a file", TRUE);
      lrFicheros.SETFILTER(Name       , '%1', '@X*.pdf'); //$***
      IF lrFicheros.FIND('-') THEN BEGIN

        // Instanciamos el Automation

        //IF NOT CREATE(autFileSystem) THEN
        //  EXIT;
        CREATE(autFileSystem);

        REPEAT
          MoverFicheroConfHotel(lrFicheros.Name);
        UNTIL lrFicheros.NEXT = 0;
      END;
    END;

    PROCEDURE MoverFicheroConfHotel@1103355012(pwNombreFichero@1103355002 : Text[250]);
    VAR
      lwNomFicheroDestino@1103355001 : Text[250];
      lwNomFicheroOrigen@1103355000 : Text[250];
      lrResHot@1100253000 : Record 7009743;
      lrEnvHot@1100253001 : Record 7009761;
      lrHistEnv@1100253003 : Record 7009823;
      lwBase@1100253002 : Text[250];
      lwFecha@1100253004 : Date;
    BEGIN
      // MoverFicheroConfHotel

      // Comprobamos si existe la ruta de carpetas y sino la vamos creando

      lwNomFicheroOrigen  := rPar."Ruta ficheros PDF" + '\' + pwNombreFichero;


      lwNomFicheroDestino := GetRutaFicheroConfEnvio(pwNombreFichero);

      // Creamos toda la ruta que pueda faltar.
      CrearDirectorio(lwNomFicheroDestino, TRUE);

      lwNomFicheroDestino := A¤adiraRuta(lwNomFicheroDestino, pwNombreFichero);

      CopiarFichero(lwNomFicheroOrigen, lwNomFicheroDestino, FALSE);
      EliminarFichero(lwNomFicheroOrigen, FALSE);
    END;

    PROCEDURE VisualizaConfHotelEnvio@1103355010(pwNumEnvio@1103355000 : Integer);
    VAR
      lrConfEnvio@1103355001 : Record 7009832;
      lrEnvHot@1100253000 : Record 7009761;
      lrHistEnv@1100253001 : Record 7009823;
    BEGIN
      // VisualizaConfHotelEnvio

      rPar.FINDFIRST;

      lrConfEnvio.RESET;
      lrConfEnvio.SETRANGE("Num. Envio"            , pwNumEnvio);
      lrConfEnvio.SETRANGE("Num confirmacion hotel", '');
      IF lrConfEnvio.FINDFIRST THEN BEGIN
        REPEAT
          VisualizaConfHotel(lrConfEnvio);
        UNTIL lrConfEnvio.NEXT = 0;
      END;
    END;

    PROCEDURE VisualizaConfHotelReserva@1103355015(pwDelegacion@1103355001 : Code[10];pwNumReserva@1103355002 : Integer;pwSoloUltima@1103355003 : Boolean);
    VAR
      lrConfEnvio@1103355000 : Record 7009832;
      lrEnvHot@1100253000 : Record 7009761;
      lrHistEnv@1100253001 : Record 7009823;
    BEGIN
      // VisualizaConfHotelReserva

      rPar.FINDFIRST;

      lrConfEnvio.RESET;
      lrConfEnvio.SETRANGE(Delegacion    , pwDelegacion);
      lrConfEnvio.SETRANGE("Num. Reserva", pwNumReserva);
      IF pwSoloUltima THEN BEGIN
        IF lrConfEnvio.FINDLAST THEN
          VisualizaConfHotel(lrConfEnvio);
      END
      ELSE BEGIN
        IF lrConfEnvio.FINDFIRST THEN BEGIN
          REPEAT
            VisualizaConfHotel(lrConfEnvio);
          UNTIL lrConfEnvio.NEXT = 0;
        END;
      END;
    END;

    PROCEDURE VisualizaConfHotel@1103355013(VAR prConfEnv@1100253000 : Record 7009832);
    VAR
      lwNomFichero@1103355001 : Text[250];
    BEGIN
      // VisualizaConfHotel


      lwNomFichero := A¤adiraRuta(GetRutaFicheroConfEnvio(prConfEnv."Identificacion documento"),
                                  prConfEnv."Identificacion documento" + '.PDF');

      HYPERLINK(lwNomFichero);
    END;

    PROCEDURE ImprimirEtiquetaExtracto@1103355011(pwNumCopias@1103355004 : Integer);
    VAR
      lrExtracto@1103355002 : Record 273;
      lrBanco@1103355003 : Record 270;
      lfListaBanco@1103355005 : Form 371;
      iEtiqueta@1103355000 : Report 7009743;
      lwCodigoImpreso@1103355001 : Code[20];
    BEGIN
      // ImprimirEtiquetaExtracto

      // - Mostrar la lista de bancos para que el usuario seleccione uno

      lrBanco.RESET;

      CLEAR(lfListaBanco);
      lfListaBanco.LOOKUPMODE(TRUE);
      IF lfListaBanco.RUNMODAL <> ACTION::LookupOK THEN
        EXIT;

      lfListaBanco.GETRECORD(lrBanco);

      // - Imprimir la etiqueta de extracto bancario

      CLEAR(iEtiqueta);
      iEtiqueta.PasarParametros(pwNumCopias, wTipoRegistro::"Ext Banco");
      iEtiqueta.USEREQUESTFORM(FALSE);
      iEtiqueta.RUNMODAL;

      iEtiqueta.RetornaParametros(lwCodigoImpreso);

      IF lwCodigoImpreso = '' THEN
        EXIT;

      rPar.FINDFIRST;

      // - Crear la ficha de extracto

      lrExtracto.INIT;
      lrExtracto.VALIDATE("Bank Account No.", lrBanco."No.");
      lrExtracto."Codigo barras PDF" := rPar.Delegacion + lwCodigoImpreso;
      lrExtracto.INSERT(TRUE);
    END;

    PROCEDURE AlmacenaExtractoBancario@1103355014(prExtracto@1103355000 : Record 273);
    VAR
      lwNomFicheroDestino@1103355002 : Text[250];
      lwNomFicheroOrigen@1103355001 : Text[250];
    BEGIN
      // AlmacenaExtractoBancario

      prExtracto.TESTFIELD("Codigo barras PDF");

      rPar.FINDFIRST;
      rPar.TESTFIELD("Ruta ficheros PDF");

      // Instanciamos el Automation

      IF NOT CREATE(autFileSystem) THEN
        EXIT;

      // Comprobamos si existe la ruta de carpetas y sino la vamos creando

      lwNomFicheroDestino := rPar."Ruta ficheros PDF" + '\' + Text011 + '\';

      IF NOT autFileSystem.FolderExists(lwNomFicheroDestino) THEN
        autFileSystem.CreateFolder(lwNomFicheroDestino);

      lwNomFicheroDestino := lwNomFicheroDestino + '\' + FORMAT(prExtracto."Statement Date", 0, '<Year4>');

      IF NOT autFileSystem.FolderExists(lwNomFicheroDestino) THEN
        autFileSystem.CreateFolder(lwNomFicheroDestino);

      lwNomFicheroDestino := lwNomFicheroDestino + '\' + FORMAT(prExtracto."Statement Date", 0, '<Month, 2>');
      IF NOT autFileSystem.FolderExists(lwNomFicheroDestino) THEN
        autFileSystem.CreateFolder(lwNomFicheroDestino);

      // Comprobar si existe el fichero PDF y lo movemos a la carpeta destino

      lwNomFicheroOrigen  := rPar."Ruta ficheros PDF" + '\' + prExtracto."Codigo barras PDF" + '.PDF';
      lwNomFicheroDestino := lwNomFicheroDestino + '\' + prExtracto."Codigo barras PDF" + '.PDF';

      IF autFileSystem.FileExists(lwNomFicheroOrigen) THEN
        autFileSystem.MoveFile(lwNomFicheroOrigen, lwNomFicheroDestino)
      ELSE
        ERROR(Text012);
    END;

    PROCEDURE VisualizaExtractoBancario@1103355016(pwNomFichero@1103355000 : Code[20];pwFechaExtracto@1103355002 : Date);
    VAR
      lwNomFichero@1103355001 : Text[250];
    BEGIN
      // VisualizaConfHotel

      rPar.FINDFIRST;

      lwNomFichero := rPar."Ruta ficheros PDF" + '\' +
                      Text011 + '\' +
                      FORMAT(pwFechaExtracto, 0, '<Year4>') + '\' +
                      FORMAT(pwFechaExtracto, 0, '<Month, 2>') + '\' + pwNomFichero + '.PDF';

      HYPERLINK(lwNomFichero);
    END;

    PROCEDURE CambiaFechaExtracto@1103355018(VAR prExtracto@1103355000 : Record 273);
    VAR
      lwNomFicheroOrigen@1103355001 : Text[250];
    BEGIN
      // CambiaFechaExtracto

      rPar.FINDFIRST;
      rPar.TESTFIELD("Ruta ficheros PDF");

      IF prExtracto."Codigo barras PDF" = '' THEN
        EXIT;

      lwNomFicheroOrigen  := rPar."Ruta ficheros PDF" + '\' + prExtracto."Codigo barras PDF" + '.PDF';

      IF EXISTS(lwNomFicheroOrigen) THEN
        ERASE(lwNomFicheroOrigen);

      prExtracto."Codigo barras PDF" := '';
      prExtracto.MODIFY;
    END;

    PROCEDURE GuardaFacturasFundRequest@1103355017(pwCodBarras@1103355004 : Code[20];pwFechaRegistro@1103355003 : Date;pwPrimeraFactura@1103355005 : Boolean) : Boolean;
    VAR
      lwNomFicheroDestino@1103355001 : Text[250];
      lwNomFicheroOrigen@1103355000 : Text[250];
      lrFichero@1103355002 : Record 2000000022;
      lwExists@1103355006 : Boolean;
    BEGIN
      // GuardaFacturasFundRequest
      // Devuelve true si ha encontrado el archivo origen

      // Instanciamos el Automation

      IF NOT CREATE(autFileSystem) THEN
        EXIT;

      // Comprobamos si existe la ruta de carpetas y sino la creamos

      lwNomFicheroDestino := Text013;

      IF NOT autFileSystem.FolderExists(lwNomFicheroDestino) THEN
        autFileSystem.CreateFolder(lwNomFicheroDestino);

      // Con una variable de la tabla FILE vaciamos la carpeta, en la primera factura del informe

      IF pwPrimeraFactura THEN BEGIN
        lrFichero.RESET;
        lrFichero.SETRANGE(Path       , Text013);
        lrFichero.SETRANGE("Is a file", TRUE);
        IF lrFichero.FINDSET THEN BEGIN
          REPEAT
            IF EXISTS(lrFichero.Path + '\' + lrFichero.Name) THEN
              ERASE(lrFichero.Path + '\' + lrFichero.Name);
          UNTIL lrFichero.NEXT = 0;
        END;
      END;

      lwNomFicheroOrigen := ArchOrigenFundRequest(pwCodBarras,pwFechaRegistro,pwPrimeraFactura);

      lwNomFicheroDestino := Text013 + pwCodBarras + '.PDF';

      lwExists := autFileSystem.FileExists(lwNomFicheroOrigen);
      IF lwExists THEN
        autFileSystem.CopyFile(lwNomFicheroOrigen, lwNomFicheroDestino);

      CLEAR(autFileSystem);

      EXIT(lwExists);
    END;

    PROCEDURE ArchOrigenFundRequest@1103355023(pwCodBarras@1103355003 : Code[20];pwFechaRegistro@1103355002 : Date;pwPrimeraFactura@1103355001 : Boolean) : Text[250];
    VAR
      lwArch@1103355000 : Text[250];
    BEGIN
      // ArchOrigenFundRequest
      // Devuelve el nombre del archivo de origen FundRequest

      CLEAR(lwArch);

      rPar.FINDFIRST;
      rPar.TESTFIELD("Ruta ficheros PDF");

      lwArch  := rPar."Ruta ficheros PDF" + '\' +
                 Text007 + '\' +
                 FORMAT(pwFechaRegistro, 0, '<Year4>') + '\' +
                 FORMAT(pwFechaRegistro, 0, '<Month,2>') + '\' +
                 pwCodBarras + '.PDF';


      EXIT(lwArch);
    END;

    PROCEDURE GuardaInformesEBB@1103355020(IDHotel@1103355000 : Code[20];pwFechaEmi@1103355005 : Date;wPrimerInforme@1103355001 : Boolean);
    VAR
      lwNomFicheroDestino@1103355002 : Text[250];
      lwNomFicheroOrigen@1103355003 : Text[250];
      lrFichero@1103355004 : Record 2000000022;
    BEGIN
      // GuardaInformesEBB

      // Instanciamos el Automation

      IF NOT CREATE(autFileSystem) THEN
        EXIT;

      // Comprobamos si existe la ruta de carpetas y sino la creamos

      lwNomFicheroDestino := Text016;

      IF NOT autFileSystem.FolderExists(lwNomFicheroDestino) THEN
        autFileSystem.CreateFolder(lwNomFicheroDestino);

      // Con una variable de la tabla FILE vaciamos la carpeta, en el primer informe

      IF wPrimerInforme THEN BEGIN
        lrFichero.RESET;
        lrFichero.SETRANGE(Path       , Text016);
        lrFichero.SETRANGE("Is a file", TRUE);
        IF lrFichero.FINDSET THEN BEGIN
          REPEAT
            IF EXISTS(lrFichero.Path + '\' + lrFichero.Name) THEN
              ERASE(lrFichero.Path + '\' + lrFichero.Name);
          UNTIL lrFichero.NEXT = 0;
        END;
      END;

      rPar.FINDFIRST;
      rPar.TESTFIELD("Ruta ficheros PDF");

      lwNomFicheroOrigen := rPar."Ruta ficheros PDF" + '\' +
                            Text017 + '\' +
                            FORMAT(pwFechaEmi, 0, '<Year4>') + '\' +
                            FORMAT(pwFechaEmi, 0, '<Month,2>') + '\' +
                            IDHotel + '.PDF';

      lwNomFicheroDestino := Text016 + IDHotel + '.PDF';

      IF autFileSystem.FileExists(lwNomFicheroOrigen) THEN
        autFileSystem.CopyFile(lwNomFicheroOrigen, lwNomFicheroDestino);

      CLEAR(autFileSystem);
    END;

    PROCEDURE ImportarFTP@1103355024(pwDireccion@1103355005 : Text[250];pwUsusario@1103355006 : Text[250];pwPasswprd@1103355007 : Text[250];pwDirectorio@1103355008 : Text[250];pwFiltro@1103355009 : Text[250]) : Boolean;
    VAR
      lfFtp@1103355000 : File;
      lwScrpName@1103355001 : Text[250];
      lwFTPOK@1103355004 : Boolean;
    BEGIN
      // ImportarFTP

      // Nombre de la archivo script

      lwScrpName:= 'scpt.ftp';

      //SI EXISTE EL SCRIPT PARA EL FTP LO BORRAMOS
      IF EXISTS(lwScrpName) THEN
        ERASE(lwScrpName);

      //GENERAMOS EL SCRIPT PARA EL FTP
      lfFtp.CREATE(lwScrpName);
      lfFtp.WRITEMODE (TRUE);
      lfFtp.TEXTMODE (TRUE);

      lfFtp.WRITE(STRSUBSTNO('o %1'   , pwDireccion));
      lfFtp.WRITE(STRSUBSTNO('%1'     , pwUsusario));
      lfFtp.WRITE(STRSUBSTNO('%1'     , pwPasswprd));
      lfFtp.WRITE('binary');
      lfFtp.WRITE(STRSUBSTNO('lcd %1' , pwDirectorio));
      lfFtp.WRITE(STRSUBSTNO('mget %1', pwFiltro));
      lfFtp.WRITE('bye');
      lfFtp.CLOSE;

      //LLAMAMOS AL COMANDO DE DOS "FTP" CON LOS PARAMETROS SIGUIENTES:
      //  -v         :: Desactiva las peticiones interactivas de datos durante la transferencia de m£ltiples archivos
      //  -i         :: Suprime la presentaci¢n de las respuestas del servidor remoto
      //  -s:archivo :: Especifica un archivo de texto que contiene comandos de FTP; los comandos se ejecutan autom ticamente
      //                despu‚s del inicio de FTP

      //CONTROL SI EL UPLOAD A LA FTP HA SIDO CORRECTO
      //lwFTPOK:= SHELL('ftp -v -i -s:' + lwScrpName) = 0;
      lwFTPOK:= SHELL('C:\WINDOWS\system32\ftp.exe','-v -i -s:' + lwScrpName) = 0;

      EXIT(lwFTPOK);
    END;

    PROCEDURE ImportarTodosFTP@1103355042(pwDireccion@1103355005 : Text[250];pwUsuario@1103355006 : Text[250];pwPassword@1103355007 : Text[250];pwDirectorioOrigen@1103355008 : Text[250];pwDirectorioDestino@1103355002 : Text[250]) : Boolean;
    VAR
      lfFtp@1103355000 : File;
      lwScrpName@1103355001 : Text[250];
      lwFTPOK@1103355004 : Boolean;
    BEGIN
      // ImportarFTP

      // Nombre de la archivo script

      lwScrpName:= 'scpt.ftp';

      //SI EXISTE EL SCRIPT PARA EL FTP LO BORRAMOS
      IF EXISTS(lwScrpName) THEN
        ERASE(lwScrpName);

      //GENERAMOS EL SCRIPT PARA EL FTP
      lfFtp.CREATE(lwScrpName);
      lfFtp.WRITEMODE (TRUE);
      lfFtp.TEXTMODE (TRUE);

      lfFtp.WRITE(STRSUBSTNO('o %1'   , pwDireccion));
      lfFtp.WRITE(STRSUBSTNO('%1'     , pwUsuario));
      lfFtp.WRITE(STRSUBSTNO('%1'     , pwPassword));
      lfFtp.WRITE('binary');
      lfFtp.WRITE(STRSUBSTNO('cd %1'  , pwDirectorioOrigen));
      lfFtp.WRITE(STRSUBSTNO('lcd %1' , pwDirectorioDestino));
      lfFtp.WRITE('mget *');
      lfFtp.WRITE('bye');
      lfFtp.CLOSE;

      //LLAMAMOS AL COMANDO DE DOS "FTP" CON LOS PARAMETROS SIGUIENTES:
      //  -v         :: Desactiva las peticiones interactivas de datos durante la transferencia de m£ltiples archivos
      //  -i         :: Suprime la presentaci¢n de las respuestas del servidor remoto
      //  -s:archivo :: Especifica un archivo de texto que contiene comandos de FTP; los comandos se ejecutan autom ticamente
      //                despu‚s del inicio de FTP

      //CONTROL SI EL UPLOAD A LA FTP HA SIDO CORRECTO
      //lwFTPOK:= SHELL('ftp -v -i -s:' + lwScrpName) = 0;
      lwFTPOK:= SHELL('C:\WINDOWS\system32\ftp.exe','-v -i -s:' + lwScrpName) = 0;

      EXIT(lwFTPOK);
    END;

    PROCEDURE ExportarFTP@1103355028(pwDireccion@1103355005 : Text[250];pwUsusario@1103355006 : Text[250];pwPasswprd@1103355007 : Text[250];pwArchivo@1103355009 : Text[250]) : Boolean;
    VAR
      lfFtp@1103355000 : File;
      lwScrpName@1103355001 : Text[250];
      lrArchDest@1103355002 : Text[250];
      lwFTPOK@1103355004 : Boolean;
    BEGIN
      // ExportarFTP

      // Nombre de la archivo script

      lwScrpName:= 'scpt.ftp';

      //SI EXISTE EL SCRIPT PARA EL FTP LO BORRAMOS
      IF EXISTS(lwScrpName) THEN
        ERASE(lwScrpName);

      //GENERAMOS EL SCRIPT PARA EL FTP
      lfFtp.CREATE(lwScrpName);
      lfFtp.WRITEMODE (TRUE);
      lfFtp.TEXTMODE (TRUE);

      lfFtp.WRITE(STRSUBSTNO('o %1'   , pwDireccion));
      lfFtp.WRITE(STRSUBSTNO('%1'     , pwUsusario));
      lfFtp.WRITE(STRSUBSTNO('%1'     , pwPasswprd));
      lfFtp.WRITE('binary');
      // lfFtp.WRITE(STRSUBSTNO('put %1' , pwArchivo));
      lfFtp.WRITE(STRSUBSTNO('send %1' , pwArchivo));
      lfFtp.WRITE('bye');
      lfFtp.CLOSE;

      //LLAMAMOS AL COMANDO DE DOS "FTP" CON LOS PARAMETROS SIGUIENTES:
      //  -v         :: Desactiva las peticiones interactivas de datos durante la transferencia de m£ltiples archivos
      //  -i         :: Suprime la presentaci¢n de las respuestas del servidor remoto
      //  -s:archivo :: Especifica un archivo de texto que contiene comandos de FTP; los comandos se ejecutan autom ticamente
      //                despu‚s del inicio de FTP

      //CONTROL SI EL UPLOAD A LA FTP HA SIDO CORRECTO
      // lwFTPOK:= SHELL('ftp -v -i -s:' + lwScrpName) = 0;
      lwFTPOK:= SHELL('C:\WINDOWS\system32\ftp.exe','-v -i -s:' + lwScrpName) = 0;

      EXIT(lwFTPOK);
    END;

    PROCEDURE BorraArchFTP@1103355025(pwDireccion@1103355005 : Text[250];pwUsusario@1103355006 : Text[250];pwPasswprd@1103355007 : Text[250];VAR prArchTmp@1103355003 : TEMPORARY Record 2000000022) : Boolean;
    VAR
      lfFtp@1103355000 : File;
      lwScrpName@1103355001 : Text[250];
      lrArchDest@1103355002 : Text[250];
      lwFTPOK@1103355004 : Boolean;
    BEGIN
      // BorraArchFTP
      // Borra determinados archivos en el servidor FTP
      // Para ello utilizamos un tabla temporal apuntando a archivo

      // Nombre de la archivo script

      lwScrpName:= 'scpt.ftp';

      //SI EXISTE EL SCRIPT PARA EL FTP LO BORRAMOS
      IF EXISTS(lwScrpName) THEN
        ERASE(lwScrpName);

      IF prArchTmp.FINDSET THEN BEGIN
        //GENERAMOS EL SCRIPT PARA EL FTP
        lfFtp.CREATE(lwScrpName);
        lfFtp.WRITEMODE (TRUE);
        lfFtp.TEXTMODE (TRUE);

        lfFtp.WRITE(STRSUBSTNO('o %1'   , pwDireccion));
        lfFtp.WRITE(STRSUBSTNO('%1'     , pwUsusario));
        lfFtp.WRITE(STRSUBSTNO('%1'     , pwPasswprd));
        lfFtp.WRITE('binary');


        REPEAT
          lfFtp.WRITE(STRSUBSTNO('delete %1' , prArchTmp.Name));
        UNTIL prArchTmp.NEXT=0;

        lfFtp.WRITE('bye');
        lfFtp.CLOSE;

        //LLAMAMOS AL COMANDO DE DOS "FTP" CON LOS PARAMETROS SIGUIENTES:
        //  -v         :: Desactiva las peticiones interactivas de datos durante la transferencia de m£ltiples archivos
        //  -i         :: Suprime la presentaci¢n de las respuestas del servidor remoto
        //  -s:archivo :: Especifica un archivo de texto que contiene comandos de FTP; los comandos se ejecutan autom ticamente
        //                despu‚s del inicio de FTP

        //CONTROL SI EL UPLOAD A LA FTP HA SIDO CORRECTO
        // lwFTPOK:= SHELL('ftp -v -i -s:' + lwScrpName) = 0;
        lwFTPOK:= SHELL('C:\WINDOWS\system32\ftp.exe','-v -i -s:' + lwScrpName) = 0;
      END;

      EXIT(lwFTPOK);
    END;

    PROCEDURE BorraArchFTPOrigen@1103355041(pwDireccion@1103355005 : Text[250];pwUsuario@1103355006 : Text[250];pwPassword@1103355007 : Text[250];pwCarpetaOrigen@1103355008 : Text[250];VAR prArchTmp@1103355003 : TEMPORARY Record 2000000022) : Boolean;
    VAR
      lfFtp@1103355000 : File;
      lwScrpName@1103355001 : Text[250];
      lrArchDest@1103355002 : Text[250];
      lwFTPOK@1103355004 : Boolean;
    BEGIN
      // BorraArchFTPOrigen
      // Borra determinados archivos en el servidor FTP
      // Para ello utilizamos un tabla temporal apuntando a archivo

      // Nombre de la archivo script

      lwScrpName:= 'scpt.ftp';

      //SI EXISTE EL SCRIPT PARA EL FTP LO BORRAMOS
      IF EXISTS(lwScrpName) THEN
        ERASE(lwScrpName);

      IF prArchTmp.FINDSET THEN BEGIN
        //GENERAMOS EL SCRIPT PARA EL FTP
        lfFtp.CREATE(lwScrpName);
        lfFtp.WRITEMODE (TRUE);
        lfFtp.TEXTMODE (TRUE);

        lfFtp.WRITE(STRSUBSTNO('o %1'   , pwDireccion));
        lfFtp.WRITE(STRSUBSTNO('%1'     , pwUsuario));
        lfFtp.WRITE(STRSUBSTNO('%1'     , pwPassword));
        lfFtp.WRITE('binary');

        lfFtp.WRITE(STRSUBSTNO('cd %1'  , pwCarpetaOrigen));
        REPEAT
          lfFtp.WRITE(STRSUBSTNO('delete "%1"' , prArchTmp.Name));
        UNTIL prArchTmp.NEXT=0;

        lfFtp.WRITE('bye');
        lfFtp.CLOSE;

        //LLAMAMOS AL COMANDO DE DOS "FTP" CON LOS PARAMETROS SIGUIENTES:
        //  -v         :: Desactiva las peticiones interactivas de datos durante la transferencia de m£ltiples archivos
        //  -i         :: Suprime la presentaci¢n de las respuestas del servidor remoto
        //  -s:archivo :: Especifica un archivo de texto que contiene comandos de FTP; los comandos se ejecutan autom ticamente
        //                despu‚s del inicio de FTP

        //CONTROL SI EL UPLOAD A LA FTP HA SIDO CORRECTO
        // lwFTPOK:= SHELL('ftp -v -i -s:' + lwScrpName) = 0;
        lwFTPOK:= SHELL('C:\WINDOWS\system32\ftp.exe','-v -i -s:' + lwScrpName) = 0;
      END;

      EXIT(lwFTPOK);
    END;

    PROCEDURE InterPer@1103355030(VAR prPeriodos@1103355000 : TEMPORARY Record 2000000007;VAR prPerOper@1103355001 : TEMPORARY Record 2000000007;VAR prPersRes@1103355002 : TEMPORARY Record 2000000007);
    BEGIN
      // InterPer

      prPersRes.RESET;
      prPersRes.DELETEALL;

      prPeriodos.RESET;
      IF prPeriodos.FINDSET THEN BEGIN
        REPEAT
          IF  (prPerOper."Period Start" >= prPeriodos."Period Start") AND (prPerOper."Period Start" <= prPeriodos."Period End") THEN
      BEGIN

            prPersRes.INIT;
            prPersRes."Period Start" := prPerOper."Period Start";

            IF (prPerOper."Period End" < prPeriodos."Period End") THEN
              prPersRes."Period End" := prPerOper."Period End"
            ELSE
              prPersRes."Period End" := prPeriodos."Period End";

            prPersRes.INSERT;

          END
          ELSE IF (prPerOper."Period End" >= prPeriodos."Period Start") AND (prPerOper."Period End" <= prPeriodos."Period End") THEN
      BEGIN

            prPersRes.INIT;
            prPersRes."Period End" := prPerOper."Period End";

            IF (prPerOper."Period Start" > prPeriodos."Period Start") THEN
              prPersRes."Period Start" := prPerOper."Period Start"
            ELSE
              prPersRes."Period Start" := prPeriodos."Period Start";

            prPersRes.INSERT;

          END
          ELSE IF (prPerOper."Period Start" < prPeriodos."Period Start") AND (prPerOper."Period End" > prPeriodos."Period End") THEN
      BEGIN

            prPersRes.INIT;
            prPersRes."Period Start" := prPeriodos."Period Start";
            prPersRes."Period End"   := prPeriodos."Period End";
            prPersRes.INSERT;

          END;

        UNTIL prPeriodos.NEXT = 0;
      END;
    END;

    PROCEDURE InterPerDirecto@1103355029(VAR prPeriodos@1103355002 : TEMPORARY Record 2000000007;VAR prPerOper@1103355001 : TEMPORARY Record 2000000007);
    VAR
      lrAuxPer@1103355000 : TEMPORARY Record 2000000007;
    BEGIN
      // InterPerDirecto

      InterPer(prPeriodos, prPerOper, lrAuxPer);
      CopiaPeriodos(lrAuxPer, prPeriodos);
    END;

    PROCEDURE DiferPer@1103355031(VAR prPeriodos@1103355002 : TEMPORARY Record 2000000007;VAR prPerOper@1103355001 : TEMPORARY Record 2000000007;VAR prPersRes@1103355000 : TEMPORARY Record 2000000007);
    BEGIN
      // DiferPer

      prPersRes.RESET;
      prPersRes.DELETEALL;

      prPeriodos.RESET;
      IF prPeriodos.FINDSET THEN BEGIN
        REPEAT
          IF  (prPerOper."Period Start" > prPeriodos."Period Start") AND (prPerOper."Period Start" <= prPeriodos."Period End") THEN
      BEGIN

            prPersRes.INIT;
            prPersRes."Period Start" := prPeriodos."Period Start";
            prPersRes."Period End"   := prPerOper."Period Start" - 1;
            prPersRes.INSERT;

          END
          ELSE IF (prPerOper."Period End" >= prPeriodos."Period Start") AND (prPerOper."Period End" < prPeriodos."Period End") THEN
      BEGIN

            prPersRes.INIT;
            prPersRes."Period Start" := prPerOper."Period End" + 1;
            prPersRes."Period End"   := prPeriodos."Period End";
            prPersRes.INSERT;

          END
          ELSE
            IF NOT((prPerOper."Period Start" <= prPeriodos."Period Start") AND
                   (prPerOper."Period End" >= prPeriodos."Period End")) THEN BEGIN

            prPersRes.INIT;
            prPersRes."Period Start" := prPeriodos."Period Start";
            prPersRes."Period End"   := prPeriodos."Period End";
            prPersRes.INSERT;

          END;

        UNTIL prPeriodos.NEXT = 0;
      END;
    END;

    PROCEDURE DiferPerDirecto@1103355032(VAR prPeriodos@1103355001 : TEMPORARY Record 2000000007;VAR prPerOper@1103355000 : TEMPORARY Record 2000000007);
    VAR
      lrAuxPer@1103355002 : TEMPORARY Record 2000000007;
    BEGIN
      // DiferPerDirecto

      DiferPer(prPeriodos, prPerOper, lrAuxPer);
      CopiaPeriodos(lrAuxPer, prPeriodos);
    END;

    PROCEDURE UnionPer@1103355033(VAR prPeriodos@1103355002 : TEMPORARY Record 2000000007;VAR prPerOper@1103355001 : TEMPORARY Record 2000000007;VAR prPersRes@1103355000 : TEMPORARY Record 2000000007);
    VAR
      lwIni@1103355003 : Date;
      lwFin@1103355004 : Date;
    BEGIN
      // UnionPer

      prPersRes.RESET;
      prPersRes.DELETEALL;

      lwIni := prPerOper."Period Start";
      lwFin := prPerOper."Period End";

      prPeriodos.RESET;
      IF prPeriodos.FINDSET THEN BEGIN
        REPEAT
          IF  ((prPerOper."Period Start" >= prPeriodos."Period Start") AND (prPerOper."Period Start" <= prPeriodos."Period End")) OR
              ((prPerOper."Period End" >= prPeriodos."Period Start") AND (prPerOper."Period End" <= prPeriodos."Period End")) THEN BEGIN

            IF lwIni > prPeriodos."Period Start" THEN
              lwIni := prPeriodos."Period Start";

            IF lwFin < prPeriodos."Period End" THEN
              lwFin := prPeriodos."Period End";
          END
          ELSE IF NOT ((prPerOper."Period Start" < prPeriodos."Period Start") AND
                       (prPerOper."Period End" > prPeriodos."Period End")) THEN BEGIN

            prPersRes.INIT;
            prPersRes."Period Start" := prPeriodos."Period Start";
            prPersRes."Period End"   := prPeriodos."Period End";
            prPersRes.INSERT;

          END;

        UNTIL prPeriodos.NEXT = 0;
      END;

      prPersRes.INIT;
      prPersRes."Period Start" := lwIni;
      prPersRes."Period End"   := lwFin;
      prPersRes.INSERT;
    END;

    PROCEDURE UnionPerDirecto@1103355034(VAR prPeriodos@1103355001 : TEMPORARY Record 2000000007;VAR prPerOper@1103355000 : TEMPORARY Record 2000000007);
    VAR
      lrAuxPer@1103355002 : TEMPORARY Record 2000000007;
    BEGIN
      // UnionPerDirecto

      UnionPer(prPeriodos, prPerOper, lrAuxPer);
      CopiaPeriodos(lrAuxPer, prPeriodos);
    END;

    PROCEDURE PeriodoVacio@1103355058(VAR prPeriodos@1103355000 : TEMPORARY Record 2000000007);
    BEGIN
      // PeriodoVacio

      prPeriodos.RESET;
      prPeriodos.DELETEALL;
    END;

    PROCEDURE IniciarPeriodo@1103355059(VAR prPeriodos@1103355000 : TEMPORARY Record 2000000007;pwIni@1103355001 : Date;pwFin@1103355002 : Date);
    BEGIN
      // IniciarPeriodo

      prPeriodos.RESET;
      prPeriodos.DELETEALL;

      prPeriodos.INIT;
      prPeriodos."Period Start" := pwIni;
      prPeriodos."Period End"   := pwFin;
      prPeriodos.INSERT;
    END;

    PROCEDURE CopiaPeriodos@1103355026(VAR prPerIn@1103355000 : TEMPORARY Record 2000000007;VAR prPerOut@1103355001 : TEMPORARY Record 2000000007);
    BEGIN
      // CopiaPeriodos

      prPerOut.RESET;
      prPerOut.DELETEALL;

      prPerIn.RESET;

      IF prPerIn.FINDSET THEN BEGIN
        REPEAT
          prPerOut := prPerIn;
          prPerOut.INSERT;
        UNTIL prPerIn.NEXT = 0;
      END;
    END;

    PROCEDURE EstaVacio@1103355027(VAR prPeriodo@1103355000 : TEMPORARY Record 2000000007) : Boolean;
    BEGIN
      // EstaVacio

      prPeriodo.RESET;

      EXIT(prPeriodo.ISEMPTY);
    END;

    PROCEDURE CompararPeriodos@1103355035(VAR prPeriodo1@1103355000 : TEMPORARY Record 2000000007;VAR prPeriodo2@1103355001 : TEMPORARY Record 2000000007) : Boolean;
    VAR
      lwBool1@1103355002 : Boolean;
      lwBool2@1103355003 : Boolean;
      lwAcaba@1103355004 : Boolean;
    BEGIN
      // CompararPeriodos

      prPeriodo1.RESET;
      prPeriodo2.RESET;

      lwBool1 := prPeriodo1.FINDSET;
      lwBool2 := prPeriodo2.FINDSET;

      IF lwBool1 <> lwBool2 THEN
        EXIT(FALSE);

      lwAcaba := FALSE;

      REPEAT

        IF (prPeriodo1."Period Start" <> prPeriodo2."Period Start")  OR
           (prPeriodo1."Period End" <> prPeriodo2."Period End") THEN
           EXIT(FALSE);

        lwBool1 := (prPeriodo1.NEXT <> 0);
        lwBool2 := (prPeriodo2.NEXT <> 0);

        IF lwBool1 <> lwBool2 THEN
          EXIT(FALSE);

        IF (lwBool1 = FALSE) AND (lwBool2 = FALSE) THEN
          lwAcaba := TRUE;

      UNTIL lwAcaba;

      EXIT(TRUE);
    END;

    PROCEDURE GetDiasPeriodo@1103355036(VAR prPeriodos@1103355000 : TEMPORARY Record 2000000007) rvDias : Integer;
    BEGIN
      // GetDiasPeriodo

      rvDias := 0;
      prPeriodos.RESET;

      IF prPeriodos.FINDSET THEN BEGIN
        REPEAT
          rvDias += (prPeriodos."Period End" - prPeriodos."Period Start") + 1;
        UNTIL prPeriodos.NEXT = 0;
      END;

      EXIT(rvDias);
    END;

    PROCEDURE ImprimirArchivo@1103355037(pwNombreFichero@1103355000 : Text[1024]);
    VAR
      objShell@1103355001 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{13709620-C279-11CE-A49E-444553540000}:'Microsoft Shell Controls And Automation'.Shell";
      objFolder@1103355002 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{BBCBDE60-C3FF-11CE-8350-444553540000}:'Microsoft Shell Controls And Automation'.Folder";
      objFolderItems@1103355003 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{744129E0-CBE5-11CE-8350-444553540000}:'Microsoft Shell Controls And Automation'.FolderItems";
      objFolderItem@1103355004 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{FAC32C80-CBE4-11CE-8350-444553540000}:'Microsoft Shell Controls And Automation'.FolderItem";
      objVerbs@1103355005 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{1F8352C0-50B0-11CF-960C-0080C7F4EE85}:'Microsoft Shell Controls And Automation'.FolderItemVerbs";
      objVerb@1103355006 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{08EC3E00-50B0-11CF-960C-0080C7F4EE85}:'Microsoft Shell Controls And Automation'.FolderItemVerb";
      lwRuta@1103355007 : Text[1024];
      lwFichero@1103355008 : Text[1024];
      lwIndex@1103355009 : Integer;
      lwAux@1103355010 : Text[1024];
      lwCont@1103355011 : Integer;
      lwVerbos@1103355012 : Text[1024];
    BEGIN
      // ImprimirArchivo

      CREATE(objShell);

      IF NOT EXISTS(pwNombreFichero) THEN
        EXIT;

      // Separo el fichero de la ruta.
      lwCont    := STRLEN(pwNombreFichero) - STRLEN(DELCHR(pwNombreFichero, '<=>', '\'));
      lwFichero := SELECTSTR(lwCont + 1, CONVERTSTR(pwNombreFichero, '\', ','));
      lwRuta    := COPYSTR(pwNombreFichero, 1, STRLEN(pwNombreFichero) - STRLEN(lwFichero));

      objFolder      := objShell.NameSpace(lwRuta);
      objFolderItems := objFolder.Items;
      objFolderItem  := objFolderItems.Item(lwFichero);
      objVerbs       := objFolderItem.Verbs;

      lwIndex := -1;

      REPEAT

        lwIndex += 1;

        IF lwIndex < objVerbs.Count THEN
          objVerb := objVerbs.Item(lwIndex);

      UNTIL (STRPOS(UPPERCASE(DELCHR(objVerb.Name, '<=>', '&')), Text018) > 0) OR
            (STRPOS(UPPERCASE(DELCHR(objVerb.Name, '<=>', '&')), Text021) > 0) OR (lwIndex >= objVerbs.Count);

      IF lwIndex <= objVerbs.Count THEN BEGIN
        objVerb.DoIt;
      END
      ELSE
        ERROR(Text019,
              pwNombreFichero);
    END;

    PROCEDURE ImprimirDirectorio@1103355038(pwRuta@1103355000 : Text[1024]);
    VAR
      objShell@1103355012 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{13709620-C279-11CE-A49E-444553540000}:'Microsoft Shell Controls And Automation'.Shell";
      objFolder@1103355011 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{BBCBDE60-C3FF-11CE-8350-444553540000}:'Microsoft Shell Controls And Automation'.Folder";
      objFolderItems@1103355010 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{744129E0-CBE5-11CE-8350-444553540000}:'Microsoft Shell Controls And Automation'.FolderItems";
      objFolderItem@1103355009 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{FAC32C80-CBE4-11CE-8350-444553540000}:'Microsoft Shell Controls And Automation'.FolderItem";
      objVerbs@1103355008 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{1F8352C0-50B0-11CF-960C-0080C7F4EE85}:'Microsoft Shell Controls And Automation'.FolderItemVerbs";
      objVerb@1103355007 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{08EC3E00-50B0-11CF-960C-0080C7F4EE85}:'Microsoft Shell Controls And Automation'.FolderItemVerb";
      lwFichero@1103355005 : Text[1024];
      lwIndex@1103355004 : Integer;
      lwVerbos@1103355001 : Text[1024];
      lwIndex2@1103355013 : Integer;
    BEGIN
      // ImprimirDirectorio

      CREATE(objShell);


      objFolder      := objShell.NameSpace(pwRuta);

      IF ISCLEAR(objFolder) THEN
        EXIT;

      objFolderItems := objFolder.Items;


      FOR lwIndex2 := 0 TO objFolderItems.Count - 1 DO BEGIN

        objFolderItem  := objFolderItems.Item(lwIndex2);
        objVerbs       := objFolderItem.Verbs;

        lwIndex := -1;

        REPEAT

          lwIndex += 1;

          IF lwIndex < objVerbs.Count THEN
            objVerb := objVerbs.Item(lwIndex);

        UNTIL (STRPOS(UPPERCASE(DELCHR(objVerb.Name, '<=>', '&')), Text018) > 0) OR
              (STRPOS(UPPERCASE(DELCHR(objVerb.Name, '<=>', '&')), Text021) > 0) OR (lwIndex >= objVerbs.Count);


        IF lwIndex <= objVerbs.Count THEN BEGIN
          objVerb.DoIt;
        END
        ELSE
          ERROR(Text019,
                pwRuta);
      END;
    END;

    PROCEDURE GetRutaFicheroConfEnvio@1100253003(pwFich@1100253000 : Text[250]) rvRuta : Text[250];
    BEGIN
      // GetRutaFicheroConfEnvio.


      rPar.FINDFIRST;

      rvRuta := rPar."Ruta ficheros PDF" + '\' + Text009 + '\' +
                COPYSTR(pwFich, 2, 4) + '\' + COPYSTR(pwFich, 6, 2);
    END;

    PROCEDURE ComprobarRuta@1103355039(pwRuta@1103355000 : Text[1024]);
    VAR
      autFileSystem@1103355001 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
      lwPos@1103355002 : Integer;
      lwRuta1@1103355003 : Text[250];
      lwRuta2@1103355004 : Text[250];
    BEGIN
      // ComprobarRuta
      //: Comprueba si la ruta existe, si no la crea.

      lwRuta1 := pwRuta;
      IF lwRuta1[STRLEN(lwRuta1)] <> '\' THEN
        lwRuta1 += '\';

      lwRuta2 := '';

      lwPos := STRPOS(pwRuta, ':\');

      IF lwPos = 0 THEN
        lwPos := STRPOS(pwRuta, '\\');

      IF lwPos = 0 THEN
        EXIT;

      lwRuta2 := COPYSTR(lwRuta1, 1, lwPos + 1);
      lwRuta1 := COPYSTR(lwRuta1, lwPos + 2, STRLEN(lwRuta1));

      CREATE(autFileSystem);

      REPEAT

        lwPos := STRPOS(lwRuta1, '\');

        IF lwPos <> 0 THEN BEGIN

          // Me salto posibles separadores seguidos.
          lwPos += 1;
          WHILE lwRuta1[lwPos] = '\' DO BEGIN
            lwPos += 1;
          END;
          lwPos -= 1;

          lwRuta2 += COPYSTR(lwRuta1, 1, lwPos);
          lwRuta1 := COPYSTR(lwRuta1, lwPos + 1, STRLEN(lwRuta1));

          IF NOT autFileSystem.FolderExists(lwRuta2) THEN BEGIN
            autFileSystem.CreateFolder(lwRuta2);
          END;

        END;
      UNTIL (lwPos = 0);
    END;

    PROCEDURE GetNombreFichero@1103355040(pwRuta@1103355000 : Text[1024]) rvNomFich : Text[250];
    VAR
      autFileSystem@1103355001 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // GetNombreFichero.

      IF EXISTS(pwRuta) THEN BEGIN
        CREATE(autFileSystem);
        rvNomFich := autFileSystem.GetFileName(pwRuta);
      END;
    END;

    PROCEDURE ExisteDirectorio@1103355060(pwDir@1103355001 : Text[250];pwConfirm@1103355002 : Boolean;pwError@1103355003 : Boolean;pwCrear@1103355004 : Boolean) rvExiste : Boolean;
    VAR
      laFileSys@1103355000 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // ExisteDirectorio.
      //: Comprueba si existe el directorio indicado.
      //: @pwDir: directorio a comprobar.
      //: @pwConfirm: se pide confirmaci¢n antes de continuar.
      //: @pwError: da un mensaje de error si no existe el directorio. esta opci¢n tiene preferencia sobre la confirmaci¢n.
      //: @pwCrear: crea el directorio si este no existe.

      CREATE(laFileSys);
      EXIT(_ExisteDirectorio(pwDir,pwConfirm,pwError, pwCrear, laFileSys));
    END;

    LOCAL PROCEDURE _ExisteDirectorio@1103355061(pwDir@1103355001 : Text[250];pwConfirm@1103355002 : Boolean;pwError@1103355003 : Boolean;pwCrear@1103355004 : Boolean;VAR paFileSys@1103355000 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject") rvExiste : Boolean;
    BEGIN
      // _ExisteDirectorio.
      //: Comprueba si existe el directorio indicado. funci¢n local para reaprovecha el automation.
      //: @pwDir: directorio a comprobar.
      //: @pwConfirm: se pide confirmaci¢n antes de continuar.
      //: @pwError: da un mensaje de error si no existe el directorio. esta opci¢n tiene preferencia sobre la confirmaci¢n.
      //: @pwCrear: crea el directorio si este no existe.
      //: @paFileSys: Automation para el sistema de ficheros.

      rvExiste := paFileSys.FolderExists(pwDir);
      IF NOT rvExiste THEN BEGIN

        IF pwError THEN
          ERROR(Text031, pwDir);

        IF pwConfirm AND pwCrear THEN BEGIN
          IF NOT CONFIRM(Text031 + Text035, FALSE, pwDir) THEN
            ERROR('');
        END;

        IF pwCrear THEN BEGIN
          EXIT(_CrearDirectorio(pwDir, pwError, paFileSys));
        END;

        IF pwConfirm THEN BEGIN
          IF NOT CONFIRM(Text031 + Text032, FALSE, pwDir) THEN
            ERROR('');
        END;

      END;
    END;

    PROCEDURE CrearDirectorio@1103355062(pwDir@1103355001 : Text[1024];pwError@1103355002 : Boolean) rvOk : Boolean;
    VAR
      laFileSys@1103355003 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // CrearDirectorio.
      //: Crea el directorio indicado.
      //: @pwDir: Directorio a crear.
      //: @pwError: detiene la ejecuci¢n con mensajes de error.

      CREATE(laFileSys);
      rvOk := _CrearDirectorio(pwDir,pwError, laFileSys);
    END;

    LOCAL PROCEDURE _CrearDirectorio@1103355067(pwDir@1103355001 : Text[1024];pwError@1103355002 : Boolean;VAR paFileSys@1103355003 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject") rvOk : Boolean;
    VAR
      lwAuxDir@1103355000 : Text[1024];
      lwAuxDir2@1103355004 : Text[1024];
      laDict@1103355005 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{EE09B103-97E0-11CF-978F-00A02463E06F}:'Microsoft Scripting Runtime'.Dictionary";
      lwCont@1103355006 : Integer;
    BEGIN
      // _CrearDirectorio.
      //: Crea el directorio indicado. Funci¢n local para reaprovechar el automation.
      //: @pwDir: Directorio a crear.
      //: @pwError: detiene la ejecuci¢n con mensajes de error.
      //: @paFileSys: automation del sistema de ficheros.

      CREATE(laDict);
      lwAuxDir  := paFileSys.GetAbsolutePathName(pwDir);
      lwAuxDir2 := paFileSys.GetAbsolutePathName(pwDir);

      WHILE NOT _ExisteDirectorio(lwAuxDir, FALSE, FALSE, FALSE, paFileSys) AND (lwAuxDir <> '') DO BEGIN
        lwCont += 1;
        lwAuxDir2 := paFileSys.GetBaseName(lwAuxDir);
        laDict.Add(lwCont, lwAuxDir2);
        lwAuxDir := paFileSys.GetParentFolderName(lwAuxDir);
      END;

      IF lwAuxDir = '' THEN BEGIN
        IF pwError THEN
          ERROR(Text033, pwDir)
        ELSE
          EXIT(FALSE);
      END;

      rvOk := TestEscritura(lwAuxDir, pwError);

      IF rvOk THEN BEGIN
        FOR lwCont := laDict.Count DOWNTO 1 DO BEGIN
          lwAuxDir2 := laDict.Item(lwCont);
          lwAuxDir := paFileSys.BuildPath(lwAuxDir, lwAuxDir2);
          paFileSys.CreateFolder(lwAuxDir);
        END;
      END;
    END;

    PROCEDURE TestEscritura@1103355063(pwDir@1103355001 : Text[1024];pwError@1103355002 : Boolean) rvOk : Boolean;
    VAR
      lwFile@1103355000 : File;
    BEGIN
      // TestEscritura.
      //: Comprueba si se permite la escritura en un directorio.
      //: @pwDir: directorio que se va a comprobar.
      //: @pwError: detiene la ejecuci¢n con mensajes de error.

      rvOk := TRUE;
      IF lwFile.CREATE(pwDir + Text036) THEN BEGIN
        lwFile.CLOSE;
        ERASE(pwDir + Text036);
      END
      ELSE
        IF pwError THEN
          ERROR(Text034, pwDir)
        ELSE
          EXIT(FALSE);
    END;

    PROCEDURE EsFichero@1103355064(pwPath@1103355000 : Text[250]) rvOK : Boolean;
    VAR
      laFileSys@1103355001 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // EsFichero.
      //: comprueba si la ruta indicada es un fichero.
      //: @pwPath: Ruta.

      CREATE(laFileSys);
      EXIT(laFileSys.FileExists(pwPath));
    END;

    PROCEDURE EsCarpeta@1103355065(pwPath@1103355000 : Text[250]) rvOk : Boolean;
    VAR
      laFileSys@1103355001 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // EsCarpeta.
      //: comprueba si la ruta indicada es una carpeta.
      //: @pwPath: Ruta.

      CREATE(laFileSys);
      EXIT(laFileSys.FolderExists(pwPath));
    END;

    PROCEDURE DevolverNombreFichero@1103355066(pwPath@1103355000 : Text[250]) rvNom : Text[250];
    VAR
      laFileSys@1103355001 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // DevolverNombreFichero.
      //: Devuelve el nombre de fichero de una ruta.
      //: @pwPath: Ruta.

      CREATE(laFileSys);
      EXIT(laFileSys.GetFileName(pwPath));
    END;

    PROCEDURE CopiarFichero@1103355069(pwFuente@1103355000 : Text[250];pwDestino@1103355001 : Text[250];pwError@1103355003 : Boolean) rvOk : Boolean;
    VAR
      laFileSys@1103355002 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
      lwDummy@1103355004 : Text[250];
    BEGIN
      // CopiarFichero.
      //: Copia un fichero fuente a un destino indicado.
      //: @pwFuente: Ruta fuente del fichero a copiar.
      //: @pwDestino: Ruta del destino del fichero a copiar.
      //: @pwError: Indica si se detiene la ejecuci¢n con mensajes de error.

      CREATE(laFileSys);
      EXIT(_CopiarFichero(pwFuente, pwDestino, pwError, FALSE, lwDummy, laFileSys));
    END;

    PROCEDURE CopiarFicheroRenombrar@1103355071(pwFuente@1103355002 : Text[250];pwDestino@1103355001 : Text[250];pwError@1103355000 : Boolean;VAR pwDestinoDef@1103355004 : Text[250]);
    VAR
      laFileSys@1103355003 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // CopiarFichero.
      //: Copia un fichero fuente a un destino indicado. Si el fichero ya existe en la carpeta de destino lo renombra.
      //: @pwFuente: Ruta fuente del fichero a copiar.
      //: @pwDestino: Ruta del destino del fichero a copiar.
      //: @pwError: Indica si se detiene la ejecuci¢n con mensajes de error.
      //: @pwdestinoDef: devuelve el destino al que se a copiado definitivamente el fichero.

      CREATE(laFileSys);
      _CopiarFichero(pwFuente, pwDestino, pwError, TRUE, pwDestinoDef, laFileSys);
    END;

    LOCAL PROCEDURE _CopiarFichero@1103355068(pwFuente@1103355000 : Text[250];pwDestino@1103355001 : Text[250];pwError@1103355004 : Boolean;pwRenombrar@1103355003 : Boolean;VAR pwDestinoDef@1103355005 : Text[250];VAR paFileSys@1103355002 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject") rvOk : Boolean;
    VAR
      lwParent@1103355006 : Text[250];
      lwFichero@1103355008 : Text[250];
    BEGIN
      // _CopiarFichero.
      //: Copia un fichero fuente a un destino indicado. funci¢n local para reaprovechar el automation.
      //: @pwFuente: Ruta fuente del fichero a copiar.
      //: @pwDestino: Ruta del destino del fichero a copiar.
      //: @pwError: Indica si se detiene la ejecuci¢n con mensajes de error.
      //: @pwRenombrar: Indica si se debe renombrar el fichero en caso de que este ya exista en el destino.
      //: @pwdestinoDef: devuelve el destino al que se a copiado definitivamente el fichero.
      //: @paFileSys: Automation del sistema de ficheros.

      // Comprobamos si existe el fichero
      rvOk := paFileSys.FileExists(pwFuente);
      IF NOT rvOk THEN
        IF pwError THEN
          ERROR(Text037, pwFuente)
        ELSE
          EXIT(FALSE);

      IF NOT paFileSys.FolderExists(pwDestino) THEN BEGIN
        lwParent  := paFileSys.GetParentFolderName(pwDestino);
        lwFichero := paFileSys.GetFileName(pwDestino);
      END
      ELSE BEGIN
        lwParent := pwDestino;
        lwFichero := paFileSys.GetFileName(pwFuente);
      END;

      IF NOT paFileSys.FolderExists(lwParent) THEN BEGIN
        IF pwError THEN
          ERROR(Text038, pwDestino)
        ELSE
          EXIT(FALSE);
      END;

      rvOk := TestEscritura(lwParent, pwError);
      IF NOT rvOk THEN
        EXIT(FALSE);

      IF paFileSys.FileExists(lwParent +  '\' + lwFichero) THEN BEGIN
        IF pwError THEN BEGIN
          IF pwRenombrar THEN BEGIN
            IF NOT CONFIRM(Text039, TRUE, lwFichero) THEN
              ERROR('');
            lwFichero := _BuscarNombreFichero(lwParent, lwFichero, paFileSys)
          END
          ELSE
            ERROR(Text040, lwFichero);
        END
        ELSE BEGIN
          IF pwRenombrar THEN
            lwFichero := _BuscarNombreFichero(lwParent, lwFichero, paFileSys)
          ELSE
            EXIT(FALSE);
        END;
      END;

      pwDestinoDef := lwParent + '\' + lwFichero;
      paFileSys.CopyFile(pwFuente, pwDestinoDef);

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE _BuscarNombreFichero@1103355072(pwRuta@1103355000 : Text[250];pwNomFich@1103355001 : Text[250];VAR paFileSys@1103355004 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject") rvNuevoNom : Text[250];
    VAR
      lwBase@1103355003 : Text[250];
      lwExt@1103355002 : Text[250];
      lwCont@1103355005 : Integer;
    BEGIN
      // _BuscarNombreFichero.
      // Busca un nombre que no exista para un fichero en una ruta indicada.
      //: @pwRuta: ruta en la que se va a buscar.
      //: @pwNomFich: Nombre original del fichero.
      //: @paFileSys: automation del sistema de ficheros.

      lwCont := 0;
      rvNuevoNom := pwNomFich;
      lwBase    := paFileSys.GetBaseName(pwNomFich);
      lwExt     := paFileSys.GetExtensionName(pwNomFich);

      WHILE paFileSys.FileExists(pwRuta + '\' + rvNuevoNom) DO BEGIN
        lwCont += 1;
        rvNuevoNom := lwBase + '(' + FORMAT(lwCont) + ').' + lwExt;
      END;
    END;

    LOCAL PROCEDURE _EliminarFichero@1103355043(pwFichero@1103355000 : Text[250];pwError@1103355004 : Boolean;VAR paFileSys@1103355002 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject") rvOk : Boolean;
    VAR
      lwParent@1103355006 : Text[250];
    BEGIN
      // _EliminarFichero.
      //: Elimina el fichero indicado. funci¢n local para reaprovechar el automation.
      //: @pwFichero: Ruta fuente del fichero a eliminar.
      //: @pwError: Indica si se detiene la ejecuci¢n con mensajes de error.
      //: @paFileSys: Automation del sistema de ficheros.

      // Comprobamos si existe el fichero
      rvOk := paFileSys.FileExists(pwFichero);
      IF NOT rvOk THEN
        IF pwError THEN
          ERROR(Text037, pwFichero)
        ELSE
          EXIT(FALSE);

      lwParent  := paFileSys.GetParentFolderName(pwFichero);
      rvOk := TestEscritura(lwParent, pwError);
      IF NOT rvOk THEN
        EXIT(FALSE);

      paFileSys.DeleteFile(pwFichero);

      EXIT(TRUE);
    END;

    PROCEDURE EliminarFichero@1103355049(pwFichero@1103355001 : Text[250];pwError@1103355000 : Boolean);
    VAR
      laFileSys@1103355002 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // EliminarFichero.
      //: Elimina el fichero indicado.
      //: @pwFichero: Ruta fuente del fichero a eliminar.
      //: @pwError: Indica si se detiene la ejecuci¢n con mensajes de error.

      CREATE(laFileSys);
      _EliminarFichero(pwFichero, pwError, laFileSys);
    END;

    PROCEDURE DevolverBaseFichero@1100253000(pwFichero@1100253001 : Text[250]) rvNom : Text[250];
    VAR
      laFileSys@1100253000 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // DevolverBaseFichero.

      CREATE(laFileSys);
      EXIT(laFileSys.GetBaseName(pwFichero));
    END;

    PROCEDURE DevolverExtensionFichero@1100253001(pwFichero@1100253000 : Text[250]) rvNom : Text[250];
    VAR
      laFileSys@1100253001 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // DevolverExtensionFichero.

      CREATE(laFileSys);
      EXIT(laFileSys.GetExtensionName(pwFichero));
    END;

    PROCEDURE A¤adiraRuta@1100253002(pwRuta@1100253001 : Text[250];pwNombre@1100253002 : Text[250]) rvRuta : Text[250];
    VAR
      laFileSys@1100253000 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
    BEGIN
      // A¤adiraRuta.

      CREATE(laFileSys);
      EXIT(laFileSys.BuildPath(pwRuta,pwNombre));
    END;

    PROCEDURE GetNombreTemporal@1100253004() rvPath : Text[250];
    VAR
      laFileSys@1100253000 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{0D43FE01-F093-11CF-8940-00A0C9054228}:'Microsoft Scripting Runtime'.FileSystemObject";
      laFolder@1100253001 : Automation "{420B2830-E718-11CF-893D-00A0C9054228} 1.0:{C7C3F5B3-88A3-11D0-ABCB-00A0C90FFFC0}:'Microsoft Scripting Runtime'.Folder";
    BEGIN
      // GetNombreTemporal.

      CREATE(laFileSys);
      laFolder := laFileSys.GetSpecialFolder(2);
      EXIT(laFileSys.BuildPath(laFolder.Path , laFileSys.GetTempName));
    END;

    PROCEDURE ComprobarCalendarioImpuestos@1100253005();
    VAR
      lrUserSetup@1100253000 : Record 91;
      lrCalendario@1100253001 : Record 7009707;
      lfCalendario@1100253002 : Form 7009707;
      lwFecha@1100253003 : Date;
      lwDiasAviso@1100253004 : Text[30];
    BEGIN
      // ComprobarCalendarioImpuestos

      IF NOT lrUserSetup.GET(USERID) THEN
        EXIT;

      IF NOT lrUserSetup."Control Calendario impuestos" THEN
        EXIT;

      lrCalendario.RESET;
      IF lrCalendario.FINDSET THEN
      BEGIN
        REPEAT
          lwDiasAviso := STRSUBSTNO('-%1D', lrCalendario."Dias antelacion en aviso");
          lwFecha := CALCDATE(lwDiasAviso, lrCalendario."Proximo vencimiento");
          IF TODAY >= lwFecha THEN
            lrCalendario.MARK(TRUE);
        UNTIL lrCalendario.NEXT = 0;

        lrCalendario.MARKEDONLY(TRUE);
        IF lrCalendario.FINDFIRST THEN
        BEGIN
          COMMIT;

          CLEAR(lfCalendario);
          lfCalendario.SETTABLEVIEW(lrCalendario);
          lfCalendario.PasaParametros(TRUE); //. Vista de consulta
          lfCalendario.RUNMODAL;
        END;
      END;
    END;

    BEGIN
    {
      ## AJF 29/06/09

        .- (09/00319) cambio c¢digos de hotel de code10 a code20.

      ## AJF 05/10/09

        .- (GOC09002) A¤adida funci¢n "ComprobarRuta" para comprobar y completar rutas de sistema de ficheros.
        .- (GOC09002) A¤adida funci¢n "GetNombreFichero" para devolver solo el nombre del fichero de una ruta.

      $001 AJS 03022012 He creado nueva funcion ComprobarCalendarioImpuestos para verificar si hay que mostrar avisos
                        a los usuarios autorizados por vencimiento de impuestos

      $002 AJS 18122014 Eliminadas funciones obsoletas de tipo de cambio

      $003 AJS 18122014 Modificar la funcion SustituirDocumentoFactura para dejar de borrar el documento anterior
    }
    END.
  }
}
