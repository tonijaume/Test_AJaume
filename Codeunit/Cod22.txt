OBJECT Codeunit 22 Item Jnl.-Post Line
{
  OBJECT-PROPERTIES
  {
    Date=14/08/09;
    Time=12:00:00;
    Version List=NAVW16.00.01,NAVES6.00.01;
  }
  PROPERTIES
  {
    TableNo=83;
    Permissions=TableData 27=imd,
                TableData 32=imd,
                TableData 46=imd,
                TableData 281=imd,
                TableData 339=imd,
                TableData 355=imd,
                TableData 5410=imd,
                TableData 5700=imd,
                TableData 5802=imd,
                TableData 5804=rim,
                TableData 5811=ri,
                TableData 5832=imd;
    OnRun=VAR
            TempJnlLineDim2@1000 : TEMPORARY Record 356;
          BEGIN
            GetGLSetup;
            TempJnlLineDim2.RESET;
            TempJnlLineDim2.DELETEALL;
            IF "Shortcut Dimension 1 Code" <> '' THEN BEGIN
              TempJnlLineDim2."Table ID" := DATABASE::"Item Journal Line";
              TempJnlLineDim2."Journal Template Name" := "Journal Template Name";
              TempJnlLineDim2."Journal Batch Name" := "Journal Batch Name";
              TempJnlLineDim2."Journal Line No." := "Line No.";
              TempJnlLineDim2."Dimension Code" := GLSetup."Global Dimension 1 Code";
              TempJnlLineDim2."Dimension Value Code" := "Shortcut Dimension 1 Code";
              TempJnlLineDim2.INSERT;
            END;
            IF "Shortcut Dimension 2 Code" <> '' THEN BEGIN
              TempJnlLineDim2."Table ID" := DATABASE::"Item Journal Line";
              TempJnlLineDim2."Journal Template Name" := "Journal Template Name";
              TempJnlLineDim2."Journal Batch Name" := "Journal Batch Name";
              TempJnlLineDim2."Journal Line No." := "Line No.";
              TempJnlLineDim2."Dimension Code" := GLSetup."Global Dimension 2 Code";
              TempJnlLineDim2."Dimension Value Code" := "Shortcut Dimension 2 Code";
              TempJnlLineDim2.INSERT;
            END;
            RunWithCheck(Rec,TempJnlLineDim2);
          END;

  }
  CODE
  {
    VAR
      Text000@1063 : TextConst 'ENU=cannot be less than zero;ESP=no puede ser menor a cero';
      Text001@1071 : TextConst 'ENU=Item Tracking is signed wrongly.;ESP=Seguim. pdto. no est  bien definido.';
      Text003@1000 : TextConst 'ENU=Reserved item %1 is not on inventory.;ESP=Producto reservado %1 no est  en existencias.';
      Text004@1001 : TextConst 'ENU=is too low;ESP=es muy peque¤o/a';
      Text005@1002 : TextConst 'ENU=Item %1 is not on inventory.;ESP=El producto %1 no est  en el stock.';
      Text011@1003 : TextConst 'ENU=Tracking Specification is missing.;ESP=Introduzca la especif. seguimiento.';
      Text012@1007 : TextConst 'ENU=Item %1 must be reserved.;ESP=Prod. %1 debe ser reservado.';
      Text014@1009 : TextConst 'ENU=Serial No. %1 is already on inventory.;ESP=N§ serie %1 est  ya en stock.';
      Text015@1010 : TextConst 'ENU=Serial Number is required for Item %1.;ESP=N§ serie es requerido para prod. %1.';
      Text016@1011 : TextConst 'ENU=Lot Number is required for Item %1.;ESP=N§ Lote es requerido para prod. %1.';
      Text017@1012 : TextConst 'ENU=" is before the posting date.";ESP=" es antes la fecha registro."';
      Text018@1013 : TextConst 'ENU=Item Tracking Serial No. %1 Lot No. %2 for Item No. %3 Variant %4 cannot be fully applied.;ESP=N§ serie seguim. prod. %1 n§ lote. %2 para n§ prod. %3 variante %4 no puede ser liq. totalm.';
      Text021@1044 : TextConst 'ENU=You must not define item tracking on %1 %2.;ESP=No debe definir seguim. pdto. en %1 %2.';
      Text022@1064 : TextConst 'ENU=You cannot apply %1 to %2 on the same item %3 on Production Order %4.;ESP=No puede aplicar %1 a %2 en el mismo producto %3 en la orden de producci¢n %4.';
      Text100@1006 : TextConst 'ENU=Fatal error when retrieving Tracking Specification.;ESP=Error grave al recuperar la especificaci¢n de seguimiento.';
      Text99000000@1014 : TextConst 'ENU=must not be filled out when reservations exist;ESP=no debe rellenarse cuando hay reservas';
      GLSetup@1028 : Record 98;
      Currency@1027 : Record 4;
      InvtSetup@1017 : Record 313;
      MfgSetup@1070 : Record 99000765;
      Location@1076 : Record 14;
      NewLocation@1082 : Record 14;
      Item@1016 : Record 27;
      GlobalItemLedgEntry@1018 : Record 32;
      OldItemLedgEntry@1019 : Record 32;
      ItemReg@1020 : Record 46;
      ItemJnlLine@1021 : Record 83;
      ItemJnlLineOrigin@1072 : Record 83;
      SourceCodeSetup@1022 : Record 242;
      GenPostingSetup@1023 : Record 252;
      ItemApplnEntry@1024 : Record 339;
      GlobalValueEntry@1025 : Record 5802;
      DirCostValueEntry@1079 : Record 5802;
      SKU@1026 : Record 5700;
      CurrExchRate@1029 : Record 330;
      ItemTrackingCode@1032 : Record 6502;
      TempJnlLineDim@1036 : TEMPORARY Record 356;
      TempSplitItemJnlLine@1035 : TEMPORARY Record 83;
      TempTrackingSpecification@1034 : TEMPORARY Record 336;
      TempValueEntryRelation@1033 : TEMPORARY Record 6508;
      TempItemEntryRelation@1030 : TEMPORARY Record 6507;
      WhseJnlLine@1074 : Record 7311;
      WMSMgmt@1073 : Codeunit 7302;
      WhseJnlPostLine@1075 : Codeunit 7301;
      ItemJnlCheckLine@1037 : Codeunit 21;
      ReservEngineMgt@1038 : Codeunit 99000831;
      ReserveItemJnlLine@1039 : Codeunit 99000835;
      ReserveProdOrderComp@1066 : Codeunit 99000838;
      ReserveProdOrderLine@1004 : Codeunit 99000837;
      ItemTrackingMgt@1041 : Codeunit 6500;
      DimMgt@1040 : Codeunit 408;
      InvtPost@1042 : Codeunit 5802;
      CostCalcMgt@1068 : Codeunit 5836;
      ACYMgt@1005 : Codeunit 5837;
      ItemLedgEntryNo@1043 : Integer;
      PhysInvtEntryNo@1045 : Integer;
      CapLedgEntryNo@1060 : Integer;
      ValueEntryNo@1046 : Integer;
      ItemApplnEntryNo@1077 : Integer;
      TotalAppliedQty@1048 : Decimal;
      OverheadAmount@1049 : Decimal;
      VarianceAmount@1050 : Decimal;
      OverheadAmountACY@1051 : Decimal;
      VarianceAmountACY@1052 : Decimal;
      QtyPerUnitOfMeasure@1084 : Decimal;
      InvtSetupRead@1053 : Boolean;
      GLSetupRead@1054 : Boolean;
      MfgSetupRead@1069 : Boolean;
      SKUExists@1055 : Boolean;
      AverageTransfer@1056 : Boolean;
      SNRequired@1057 : Boolean;
      LotRequired@1058 : Boolean;
      PostponeReservationHandling@1059 : Boolean;
      VarianceRequired@1031 : Boolean;
      LastOperation@1062 : Boolean;
      DisableItemTracking@1015 : Boolean;
      CalledFromInvtPutawayPick@1080 : Boolean;
      CalledFromAdjustment@1078 : Boolean;
      PostToGL@1008 : Boolean;
      PostItemJnlLine@1081 : Boolean;
      ProdOrderCompModified@1083 : Boolean;
      Text023@1061 : TextConst 'ENU=Entries applied to an Outbound Transfer cannot be unapplied.;ESP=No se pueden desliquidar los movimientos liquidados en una transferencia salida.';
      Text024@1047 : TextConst 'ENU=Entries applied to a Drop Shipment Order cannot be unapplied.;ESP=No se pueden desliquidar los movimientos liquidados en un pedido env¡o directo.';
      Text025@1085 : TextConst 'ENU=Entries applied to a Correction entry cannot be unapplied.;ESP=No se pueden desliquidar los movimientos aplicados a un movimiento de correcci¢n.';
      IsServUndoConsumption@1088 : Boolean;
      TouchedItemLedgerEntries@1065 : TEMPORARY Record 32;
      Text027@1086 : TextConst 'ENU=A fixed application was not unapplied and this prevented the reapplication. Use the Application Worksheet to remove the applications.;ESP=No se desliquid¢ una liquidaci¢n establecida y esto impidi¢ la nueva liquidaci¢n. Utilice la Hoja liquidaci¢n para eliminar las liquidaciones.';
      Text01@1087 : TextConst 'ENU=Checking for open entries.;ESP=Comprobando movimientos abiertos.';
      Text028@1089 : TextConst 'ENU=Entries applied to a Job Purchase cannot be unapplied.;ESP=No se pueden desliquidar los movimientos liquidados en una compra proyecto.';
      BlockRetrieveIT@1067 : Boolean;
      Text029@1091 : TextConst 'ENU=%1 %2 for %3 %4 is reserved for %5.;ESP=%1 %2 para %3 %4 est  reservado para %5.';

    PROCEDURE RunWithCheck@13(VAR ItemJnlLine2@1000 : Record 83;VAR TempJnlLineDim2@1001 : Record 356);
    BEGIN
      ItemJnlLine.COPY(ItemJnlLine2);
      TempJnlLineDim.RESET;
      TempJnlLineDim.DELETEALL;
      PostItemJnlLine := DimMgt.CopyJnlLineDimToJnlLineDim(TempJnlLineDim2,TempJnlLineDim);

      SetupSplitJnlLine(ItemJnlLine2,PostItemJnlLine);
      IF NOT PostItemJnlLine THEN
        PostItemJnlLine := IsNotInternalWhseMovement(ItemJnlLine2);

      WHILE SplitJnlLine(ItemJnlLine,PostItemJnlLine) DO
        IF PostItemJnlLine THEN
          Code;
      ItemJnlLine2 := ItemJnlLine;

      RedoApplications;
    END;

    LOCAL PROCEDURE Code@3();
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF EmptyLine AND NOT Correction AND NOT Adjustment THEN
          IF NOT IsValueEntryForDeletedItem THEN
            EXIT;

        ItemJnlCheckLine.SetCalledFromInvtPutawayPick(CalledFromInvtPutawayPick);
        ItemJnlCheckLine.SetCalledFromAdjustment(CalledFromAdjustment);

        ItemJnlCheckLine.RunCheck(ItemJnlLine,TempJnlLineDim);

        IF "Document Date" = 0D THEN
          "Document Date" := "Posting Date";

        IF ItemLedgEntryNo = 0 THEN BEGIN
          GlobalItemLedgEntry.LOCKTABLE;
          IF GlobalItemLedgEntry.FINDLAST THEN
            ItemLedgEntryNo := GlobalItemLedgEntry."Entry No.";
        END;
        IF ValueEntryNo = 0 THEN BEGIN
          GlobalValueEntry.LOCKTABLE;
          IF GlobalValueEntry.FINDLAST THEN
            ValueEntryNo := GlobalValueEntry."Entry No.";
        END;
        GetInvtSetup;
        IF NOT CalledFromAdjustment THEN
          PostToGL := InvtSetup."Automatic Cost Posting";

        IF (SNRequired OR LotRequired) AND ("Quantity (Base)" <> 0) AND
          ("Value Entry Type" = "Value Entry Type"::"Direct Cost") AND
          NOT DisableItemTracking AND NOT Adjustment AND NOT IsServUndoConsumption
          AND NOT Subcontracting
        THEN
          CheckItemTracking;

        IF Correction THEN
          UndoQuantityPosting;

        IF ("Entry Type" IN ["Entry Type"::Consumption,"Entry Type"::Output]) AND
           NOT ("Value Entry Type" = "Value Entry Type"::Revaluation) AND
           NOT OnlyStopTime
        THEN BEGIN
          TESTFIELD("Prod. Order No.");
          TESTFIELD("Prod. Order Line No.");
          GetLocation("Location Code");
          IF Location."Directed Put-away and Pick" THEN BEGIN
            WMSMgmt.CheckProductionInbBin(ItemJnlLine);
            WMSMgmt.CheckProductionOutbBin(ItemJnlLine);
          END;
        END;

        IF ("Gen. Bus. Posting Group" <> GenPostingSetup."Gen. Bus. Posting Group") OR
           ("Gen. Prod. Posting Group" <> GenPostingSetup."Gen. Prod. Posting Group")
        THEN
          GenPostingSetup.GET("Gen. Bus. Posting Group","Gen. Prod. Posting Group");

        IF "Qty. per Unit of Measure" = 0 THEN
          "Qty. per Unit of Measure" := 1;
        IF "Qty. per Cap. Unit of Measure" = 0 THEN
          "Qty. per Cap. Unit of Measure" := 1;

        Quantity := "Quantity (Base)";
        "Invoiced Quantity" := "Invoiced Qty. (Base)";
        "Setup Time" := "Setup Time (Base)";
        "Run Time" := "Run Time (Base)";
        "Stop Time" := "Stop Time (Base)";
        "Output Quantity" := "Output Quantity (Base)";
        "Scrap Quantity" := "Scrap Quantity (Base)";

        IF NOT ItemJnlLine.Subcontracting AND
           ("Entry Type" = "Entry Type"::Output)
        THEN
          QtyPerUnitOfMeasure := "Qty. per Cap. Unit of Measure"
        ELSE
          QtyPerUnitOfMeasure := "Qty. per Unit of Measure";

        "Unit Amount" := ROUND(
          "Unit Amount" / QtyPerUnitOfMeasure,GLSetup."Unit-Amount Rounding Precision");
        "Unit Cost" := ROUND(
          "Unit Cost" / QtyPerUnitOfMeasure,GLSetup."Unit-Amount Rounding Precision");
        "Unit Cost (ACY)" := ROUND(
          "Unit Cost (ACY)" / QtyPerUnitOfMeasure,Currency."Unit-Amount Rounding Precision");

        OverheadAmount := 0;
        VarianceAmount := 0;
        OverheadAmountACY := 0;
        VarianceAmountACY := 0;
        VarianceRequired := FALSE;
        LastOperation := FALSE;

        IF Adjustment OR
           ("Value Entry Type" IN ["Value Entry Type"::Rounding, "Value Entry Type"::Revaluation])
        THEN
          PostItem
        ELSE
          CASE "Entry Type" OF
            "Entry Type"::Consumption:
              PostConsumption;
            "Entry Type"::Output:
              PostOutput;
            ELSE
              IF NOT Correction THEN
                PostItem;
          END;

        // Entry no. is returned to shipment/receipt
        IF Subcontracting THEN
          "Item Shpt. Entry No." := CapLedgEntryNo
        ELSE
          "Item Shpt. Entry No." := GlobalItemLedgEntry."Entry No.";
      END;
    END;

    LOCAL PROCEDURE PostConsumption@29();
    VAR
      ProdOrderComp@1003 : Record 5407;
      TempHandlingSpecification@1000 : TEMPORARY Record 336;
      RemQtyToPost@1004 : Decimal;
      RemQtyToPostThisLine@1001 : Decimal;
      QtyToPost@1005 : Decimal;
      UseItemTrackingApplication@1007 : Boolean;
      LastLoop@1006 : Boolean;
      EndLoop@1002 : Boolean;
      NewRemainingQty@1008 : Decimal;
    BEGIN
      WITH ProdOrderComp DO BEGIN
        SETCURRENTKEY(Status,"Prod. Order No.","Prod. Order Line No.","Item No.","Line No.");
        SETRANGE(Status,Status::Released);
        SETRANGE("Prod. Order No.",ItemJnlLine."Prod. Order No.");
        SETRANGE("Prod. Order Line No.",ItemJnlLine."Prod. Order Line No.");
        SETRANGE("Item No.",ItemJnlLine."Item No.");
        IF ItemJnlLine."Prod. Order Comp. Line No." <> 0 THEN
          SETRANGE("Line No.",ItemJnlLine."Prod. Order Comp. Line No.");
        LOCKTABLE;

        RemQtyToPost := ItemJnlLine.Quantity;

        IF FINDSET THEN BEGIN
          IF ((ItemJnlLine."Serial No." <> '') OR (ItemJnlLine."Lot No." <> '')) AND NOT BlockRetrieveIT THEN
            UseItemTrackingApplication :=
              ItemTrackingMgt.RetrieveConsumpItemTracking(ItemJnlLine,TempHandlingSpecification);

          IF UseItemTrackingApplication THEN BEGIN
            TempHandlingSpecification.SETRANGE("Serial No.",ItemJnlLine."Serial No.");
            TempHandlingSpecification.SETRANGE("Lot No.",ItemJnlLine."Lot No.");
            LastLoop := FALSE;
          END ELSE BEGIN
            RemQtyToPostThisLine := RemQtyToPost;
            LastLoop := TRUE;
          END;

          REPEAT
            IF UseItemTrackingApplication THEN BEGIN
              TempHandlingSpecification.SETRANGE("Source Ref. No.","Line No.");
              IF LastLoop THEN BEGIN
                RemQtyToPostThisLine := "Remaining Qty. (Base)";
                IF TempHandlingSpecification.FINDSET THEN
                  REPEAT
                    CheckItemTrackingOfComp(TempHandlingSpecification,ItemJnlLine);
                    RemQtyToPostThisLine += TempHandlingSpecification."Qty. to Handle (Base)";
                  UNTIL TempHandlingSpecification.NEXT = 0;
                IF RemQtyToPostThisLine * RemQtyToPost < 0 THEN
                  ERROR(Text001); // Assertion: Test signing
              END ELSE BEGIN
                IF TempHandlingSpecification.FINDFIRST THEN BEGIN
                  RemQtyToPostThisLine := -TempHandlingSpecification."Qty. to Handle (Base)";
                  TempHandlingSpecification.DELETE;
                END ELSE BEGIN
                  TempHandlingSpecification.SETRANGE("Serial No.");
                  TempHandlingSpecification.SETRANGE("Lot No.");
                  TempHandlingSpecification.FINDFIRST;
                  CheckItemTrackingOfComp(TempHandlingSpecification,ItemJnlLine);
                  RemQtyToPostThisLine := 0;
                END;
              END;
              IF RemQtyToPostThisLine > RemQtyToPost THEN
                RemQtyToPostThisLine := RemQtyToPost;
            END;

            QtyToPost := RemQtyToPostThisLine;
            CALCFIELDS("Act. Consumption (Qty)");
            NewRemainingQty := "Expected Qty. (Base)" - "Act. Consumption (Qty)" - QtyToPost;
            NewRemainingQty := ROUND(NewRemainingQty,0.00001);
            IF (NewRemainingQty * "Expected Qty. (Base)") < 0 THEN BEGIN
              QtyToPost := "Remaining Qty. (Base)";
              "Remaining Qty. (Base)" := 0;
            END ELSE BEGIN
              IF ("Remaining Qty. (Base)" * "Expected Qty. (Base)") >= 0 THEN
                QtyToPost := "Remaining Qty. (Base)" - NewRemainingQty
              ELSE
                QtyToPost := NewRemainingQty;
              "Remaining Qty. (Base)" := NewRemainingQty;
            END;

            "Remaining Quantity" := ROUND("Remaining Qty. (Base)" / "Qty. per Unit of Measure",0.00001);

            IF QtyToPost <> 0 THEN BEGIN
              RemQtyToPost := RemQtyToPost - QtyToPost;
              MODIFY;
              IF ProdOrderCompModified THEN
                InsertConsumpEntry(ProdOrderComp,"Line No.",QtyToPost,FALSE)
              ELSE
                InsertConsumpEntry(ProdOrderComp,"Line No.",QtyToPost,TRUE);
            END;

            IF UseItemTrackingApplication THEN BEGIN
              IF NEXT = 0 THEN BEGIN
                EndLoop := LastLoop;
                LastLoop := TRUE;
                FINDFIRST;
                TempHandlingSpecification.RESET;
              END;
            END ELSE
              EndLoop := NEXT = 0;

          UNTIL EndLoop OR (RemQtyToPost = 0);
        END;

        IF RemQtyToPost <> 0 THEN
          InsertConsumpEntry(ProdOrderComp,ItemJnlLine."Prod. Order Comp. Line No.",RemQtyToPost,FALSE);
      END;
      ProdOrderCompModified := FALSE;
    END;

    LOCAL PROCEDURE PostOutput@25();
    VAR
      MfgItem@1012 : Record 27;
      MfgSKU@1003 : Record 5700;
      MachCenter@1008 : Record 99000758;
      WorkCenter@1004 : Record 99000754;
      CapLedgEntry@1000 : Record 5832;
      ProdOrder@1007 : Record 5405;
      ProdOrderLine@1006 : Record 5406;
      ProdOrderRtngLine@1005 : Record 5409;
      DirCostAmt@1002 : Decimal;
      IndirCostAmt@1001 : Decimal;
      ValuedQty@1011 : Decimal;
      MfgUnitCost@1010 : Decimal;
      ReTrack@1009 : Boolean;
      ItemLedgerEntry@1013 : Record 32;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF "Stop Time" <> 0 THEN BEGIN
          InsertCapLedgEntry(CapLedgEntry,"Stop Time","Stop Time");
          IF OnlyStopTime THEN
            EXIT;
        END;

        IF OutputValuePosting THEN BEGIN
          PostItem;
          EXIT;
        END;

        IF Subcontracting THEN
          ValuedQty := "Invoiced Quantity"
        ELSE
          ValuedQty := CalcCapQty;

        IF Item.GET("Item No.") THEN
          IF NOT CalledFromAdjustment THEN
            Item.TESTFIELD("Inventory Value Zero",FALSE);

        IF "Item Shpt. Entry No." <> 0 THEN
          CapLedgEntry.GET("Item Shpt. Entry No.")
        ELSE BEGIN
          ProdOrder.GET(ProdOrder.Status::Released,"Prod. Order No.");
          ProdOrder.TESTFIELD(Blocked,FALSE);
          ProdOrderLine.LOCKTABLE;
          ProdOrderLine.GET(ProdOrder.Status::Released,"Prod. Order No.","Prod. Order Line No.");

          "Inventory Posting Group" := ProdOrderLine."Inventory Posting Group";

          ProdOrderRtngLine.SETRANGE(Status,ProdOrderRtngLine.Status::Released);
          ProdOrderRtngLine.SETRANGE("Prod. Order No.","Prod. Order No.");
          ProdOrderRtngLine.SETRANGE("Routing Reference No.","Routing Reference No.");
          ProdOrderRtngLine.SETRANGE("Routing No.","Routing No.");
          IF ProdOrderRtngLine.FINDFIRST THEN BEGIN
            TESTFIELD("Operation No.");
            TESTFIELD("No.");

            IF Type = Type::"Machine Center" THEN BEGIN
              MachCenter.GET("No.");
              MachCenter.TESTFIELD(Blocked,FALSE);
            END;
            WorkCenter.GET("Work Center No.");
            WorkCenter.TESTFIELD(Blocked,FALSE);

            ApplyCapNeed("Setup Time (Base)","Run Time (Base)");
          END;

          IF "Operation No." <> '' THEN BEGIN
            ProdOrderRtngLine.GET(
              ProdOrderRtngLine.Status::Released,"Prod. Order No.",
              "Routing Reference No.","Routing No.","Operation No.");
            IF Finished THEN
              ProdOrderRtngLine."Routing Status" := ProdOrderRtngLine."Routing Status"::Finished
            ELSE
              ProdOrderRtngLine."Routing Status" := ProdOrderRtngLine."Routing Status"::"In Progress";
            LastOperation := (NOT NextOperationExist(ProdOrderRtngLine));
            ProdOrderRtngLine.MODIFY;
          END ELSE
            LastOperation := TRUE;

          IF Subcontracting THEN
            InsertCapLedgEntry(CapLedgEntry,Quantity,"Invoiced Quantity")
          ELSE
            InsertCapLedgEntry(CapLedgEntry,ValuedQty,ValuedQty);

          FlushOperation(ProdOrder,ProdOrderLine);
        END;

        CalcDirAndIndirCostAmts(DirCostAmt,IndirCostAmt,ValuedQty,"Unit Cost","Indirect Cost %","Overhead Rate");

        InsertCapValueEntry(CapLedgEntry,"Value Entry Type"::"Direct Cost",ValuedQty,ValuedQty,DirCostAmt);
        InsertCapValueEntry(CapLedgEntry,"Value Entry Type"::"Indirect Cost",ValuedQty,0,IndirCostAmt);

        IF LastOperation AND ("Output Quantity" <> 0) THEN BEGIN
          CheckItemTracking;
          IF ("Output Quantity" < 0) AND (NOT Adjustment) THEN BEGIN
            ItemLedgerEntry.GET("Applies-to Entry");
            TESTFIELD("Lot No.",ItemLedgerEntry."Lot No.");
            TESTFIELD("Serial No.",ItemLedgerEntry."Serial No.");
          END;
          MfgItem.GET(ProdOrderLine."Item No.");
          MfgItem.TESTFIELD("Gen. Prod. Posting Group");
          IF MfgSKU.GET(ProdOrderLine."Location Code",ProdOrderLine."Item No.",ProdOrderLine."Variant Code") THEN
            MfgUnitCost := MfgSKU."Unit Cost"
          ELSE
            MfgUnitCost := MfgItem."Unit Cost";
          Amount := "Output Quantity" * MfgUnitCost;
          "Amount (ACY)" := ACYMgt.CalcACYAmt(Amount,"Posting Date",FALSE);
          "Gen. Bus. Posting Group" := ProdOrder."Gen. Bus. Posting Group";
          "Gen. Prod. Posting Group" := MfgItem."Gen. Prod. Posting Group";
          IF ("Output Quantity (Base)" * ProdOrderLine."Remaining Qty. (Base)" <= 0) THEN
            ReTrack := TRUE
          ELSE
            IF NOT(CalledFromInvtPutawayPick) THEN
              ReserveProdOrderLine.TransferPOLineToItemJnlLine(
                ProdOrderLine,ItemJnlLine,"Output Quantity (Base)");

          GetLocation("Location Code");
          IF Location."Bin Mandatory" AND (NOT CalledFromInvtPutawayPick) THEN BEGIN
            WMSMgmt.CreateWhseJnlLineFromOutputJnl(ItemJnlLine,WhseJnlLine);
            WMSMgmt.CheckWhseJnlLine(WhseJnlLine,2,0,FALSE);
          END;

          ItemJnlLine.Description := ProdOrderLine.Description;
          IF Subcontracting THEN BEGIN
            "Document Type" := "Document Type"::" ";
            "Document No." := "Prod. Order No.";
            "Document Line No." := 0;
            "Invoiced Quantity" := 0;
          END;
          PostItem;
          UpdateProdOrderLine(ProdOrderLine,ReTrack);
          IF Location."Bin Mandatory" AND (NOT CalledFromInvtPutawayPick) THEN
            WhseJnlPostLine.RUN(WhseJnlLine);
        END;
      END;
    END;

    LOCAL PROCEDURE PostItem@28();
    BEGIN
      WITH ItemJnlLine DO BEGIN
        SKUExists := SKU.GET("Location Code","Item No.","Variant Code");
        IF "Item Shpt. Entry No." <> 0 THEN BEGIN
          "Location Code" := '';
          "Variant Code" := '';
        END;

        IF Item.GET("Item No.") THEN
          IF NOT CalledFromAdjustment THEN
            Item.TESTFIELD(Blocked,FALSE);

        IF "Inventory Posting Group" = '' THEN BEGIN
          Item.TESTFIELD("Inventory Posting Group");
          "Inventory Posting Group" := Item."Inventory Posting Group";
        END;

        IF ("Entry Type" = "Entry Type"::Transfer) AND
           (Item."Costing Method" = Item."Costing Method"::Average) AND
           ("Applies-to Entry" = 0)
        THEN BEGIN
          AverageTransfer := TRUE;
          TotalAppliedQty := 0;
        END ELSE
          AverageTransfer := FALSE;

        IF Item."Costing Method" = Item."Costing Method"::Standard THEN BEGIN
          "Overhead Rate" := Item."Overhead Rate";
          "Indirect Cost %" := Item."Indirect Cost %";
        END;

        IF ("Value Entry Type" <> "Value Entry Type"::"Direct Cost") OR
           ("Item Charge No." <> '')
          THEN BEGIN
            "Overhead Rate" := 0;
            "Indirect Cost %" := 0;
          END;

        IF (Quantity <> 0) AND
           ("Item Charge No." = '') AND
           NOT ("Value Entry Type" IN ["Value Entry Type"::Revaluation,"Value Entry Type"::Rounding]) AND
           NOT Adjustment
        THEN
          ItemQtyPosting
        ELSE BEGIN
          IF ("Invoiced Quantity" <> 0) OR Adjustment OR
             IsInterimRevaluation
          THEN BEGIN
            IF "Value Entry Type" = "Value Entry Type"::"Direct Cost" THEN
              GlobalItemLedgEntry.GET("Item Shpt. Entry No.")
            ELSE
              GlobalItemLedgEntry.GET("Applies-to Entry");
            InitValueEntry(GlobalValueEntry,GlobalItemLedgEntry);
          END;
        END;
        IF (Quantity <> 0) OR ("Invoiced Quantity" <> 0) THEN
          ItemValuePosting;

        UpdateUnitCost(GlobalValueEntry);
      END;
    END;

    LOCAL PROCEDURE InsertConsumpEntry@31(VAR ProdOrderComp@1005 : Record 5407;ProdOrderCompLineNo@1004 : Integer;QtyBase@1003 : Decimal;ModifyProdOrderComp@1000 : Boolean);
    VAR
      PostWhseJnlLine@1001 : Boolean;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        Quantity := QtyBase;
        "Quantity (Base)" := QtyBase;
        "Invoiced Quantity" := QtyBase;
        "Invoiced Qty. (Base)" := QtyBase;
        "Prod. Order Comp. Line No." := ProdOrderCompLineNo;
        IF ModifyProdOrderComp THEN BEGIN
          IF NOT CalledFromInvtPutawayPick THEN
            ReserveProdOrderComp.TransferPOCompToItemJnlLine(ProdOrderComp,ItemJnlLine,QtyBase);
          ProdOrderComp.MODIFY;
        END;

        IF "Value Entry Type" <> "Value Entry Type"::Revaluation THEN BEGIN
          GetLocation("Location Code");
          IF Location."Bin Mandatory" AND (NOT CalledFromInvtPutawayPick) THEN BEGIN
            WMSMgmt.CreateWhseJnlLineFromConsumJnl(ItemJnlLine,WhseJnlLine);
            WMSMgmt.CheckWhseJnlLine(WhseJnlLine,3,0,FALSE);
            PostWhseJnlLine := TRUE;
          END;
        END;
      END;

      PostItem;
      IF PostWhseJnlLine THEN
        WhseJnlPostLine.RUN(WhseJnlLine);
    END;

    LOCAL PROCEDURE CalcCapQty@30() CapQty@1000 : Decimal;
    BEGIN
      GetMfgSetup;

      WITH ItemJnlLine DO BEGIN
        IF "Unit Cost Calculation" = "Unit Cost Calculation"::Time THEN BEGIN
          IF MfgSetup."Cost Incl. Setup" THEN
            CapQty := "Setup Time" + "Run Time"
          ELSE
            CapQty := "Run Time";
        END ELSE
          CapQty := Quantity + "Scrap Quantity";
      END;
    END;

    LOCAL PROCEDURE CalcDirAndIndirCostAmts@26(VAR DirCostAmt@1000 : Decimal;VAR IndirCostAmt@1001 : Decimal;CapQty@1005 : Decimal;UnitCost@1002 : Decimal;IndirCostPct@1003 : Decimal;OvhdRate@1004 : Decimal);
    VAR
      CostAmt@1006 : Decimal;
    BEGIN
      CostAmt := ROUND(CapQty * UnitCost);
      DirCostAmt := ROUND((CostAmt - CapQty * OvhdRate) / (1 + IndirCostPct / 100));
      IndirCostAmt := CostAmt - DirCostAmt;
    END;

    LOCAL PROCEDURE ApplyCapNeed@27(PostedSetupTime@1000 : Decimal;PostedRunTime@1003 : Decimal);
    VAR
      ProdOrderCapNeed@1001 : Record 5410;
      Qty@1002 : Decimal;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        ProdOrderCapNeed.LOCKTABLE;
        ProdOrderCapNeed.RESET;
        ProdOrderCapNeed.SETCURRENTKEY(
          Status,"Prod. Order No.","Routing Reference No.","Operation No.",Date,"Starting Time");
        ProdOrderCapNeed.SETRANGE(Status,ProdOrderCapNeed.Status::Released);
        ProdOrderCapNeed.SETRANGE("Prod. Order No.","Prod. Order No.");
        ProdOrderCapNeed.SETRANGE("Requested Only",FALSE);
        ProdOrderCapNeed.SETRANGE("Routing No.","Routing No.");
        ProdOrderCapNeed.SETRANGE("Routing Reference No.","Routing Reference No.");
        ProdOrderCapNeed.SETRANGE("Operation No.","Operation No.");

        IF Finished THEN
          ProdOrderCapNeed.MODIFYALL("Allocated Time",0)
        ELSE BEGIN
          IF PostedSetupTime <> 0 THEN BEGIN
            ProdOrderCapNeed.SETRANGE("Time Type",ProdOrderCapNeed."Time Type"::Setup);
            IF ProdOrderCapNeed.FINDSET THEN
              REPEAT
                IF (ProdOrderCapNeed."Allocated Time" > PostedSetupTime) THEN
                  Qty := PostedSetupTime
                ELSE
                  Qty := ProdOrderCapNeed."Allocated Time";
                ProdOrderCapNeed."Allocated Time" :=
                  ProdOrderCapNeed."Allocated Time" - Qty;
                ProdOrderCapNeed.MODIFY;
                PostedSetupTime := PostedSetupTime - Qty;
              UNTIL (ProdOrderCapNeed.NEXT = 0) OR (PostedSetupTime = 0);
          END;

          IF PostedRunTime <> 0 THEN BEGIN
            ProdOrderCapNeed.SETRANGE("Time Type",ProdOrderCapNeed."Time Type"::Run);
            IF ProdOrderCapNeed.FINDSET THEN
              REPEAT
                IF (ProdOrderCapNeed."Allocated Time" > PostedRunTime) THEN
                  Qty := PostedRunTime
                ELSE
                  Qty := ProdOrderCapNeed."Allocated Time";
                ProdOrderCapNeed."Allocated Time" :=
                  ProdOrderCapNeed."Allocated Time" - Qty;
                ProdOrderCapNeed.MODIFY;
                PostedRunTime := PostedRunTime - Qty;
              UNTIL (ProdOrderCapNeed.NEXT = 0) OR (PostedRunTime = 0);
          END;
        END;
      END;
    END;

    LOCAL PROCEDURE UpdateProdOrderLine@38(VAR ProdOrderLine@1000 : Record 5406;ReTrack@1005 : Boolean);
    VAR
      ReservMgt@1002 : Codeunit 99000845;
      ApplyQtyBase@1001 : Decimal;
    BEGIN
      WITH ProdOrderLine DO BEGIN
        IF ItemJnlLine."Output Quantity (Base)" > "Remaining Qty. (Base)" THEN BEGIN
          ApplyQtyBase := "Remaining Qty. (Base)";
          ReserveProdOrderLine.AssignForPlanning(ProdOrderLine);
        END ELSE
          ApplyQtyBase := ItemJnlLine."Output Quantity (Base)";
        "Finished Qty. (Base)" := "Finished Qty. (Base)" + ItemJnlLine."Output Quantity (Base)";
        "Finished Quantity" := "Finished Qty. (Base)" / "Qty. per Unit of Measure";
        IF "Finished Qty. (Base)" < 0 THEN
          FIELDERROR("Finished Quantity",Text000);
        "Remaining Qty. (Base)" := "Quantity (Base)" - "Finished Qty. (Base)";
        IF "Remaining Qty. (Base)" < 0 THEN
          "Remaining Qty. (Base)" := 0;
        "Remaining Quantity" := "Remaining Qty. (Base)" / "Qty. per Unit of Measure";
        MODIFY;

        IF ReTrack THEN BEGIN
          ReservMgt.SetProdOrderLine(ProdOrderLine);
          ReservMgt.ClearSurplus;
          ReservMgt.AutoTrack("Remaining Qty. (Base)");
        END;
      END;
    END;

    LOCAL PROCEDURE InsertCapLedgEntry@23(VAR CapLedgEntry@1000 : Record 5832;Qty@1001 : Decimal;InvdQty@1002 : Decimal);
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF CapLedgEntryNo = 0 THEN BEGIN
          CapLedgEntry.LOCKTABLE;
          IF CapLedgEntry.FINDLAST THEN
            CapLedgEntryNo := CapLedgEntry."Entry No.";
        END;

        CapLedgEntryNo := CapLedgEntryNo + 1;

        CapLedgEntry.INIT;
        CapLedgEntry."Entry No." := CapLedgEntryNo;

        CapLedgEntry."Operation No." := "Operation No.";
        CapLedgEntry.Type := Type;
        CapLedgEntry."No." := "No.";
        CapLedgEntry.Description := Description;
        CapLedgEntry."Work Center No." := "Work Center No.";
        CapLedgEntry."Work Center Group Code" := "Work Center Group Code";
        CapLedgEntry.Subcontracting := Subcontracting;

        CapLedgEntry.Quantity := Qty;
        CapLedgEntry."Invoiced Quantity" := InvdQty;
        CapLedgEntry."Completely Invoiced" := CapLedgEntry."Invoiced Quantity" = CapLedgEntry.Quantity;

        CapLedgEntry."Setup Time" := "Setup Time";
        CapLedgEntry."Run Time" := "Run Time";
        CapLedgEntry."Stop Time" := "Stop Time";

        IF "Unit Cost Calculation" = "Unit Cost Calculation"::Time THEN BEGIN
          CapLedgEntry."Cap. Unit of Measure Code" := "Cap. Unit of Measure Code";
          CapLedgEntry."Qty. per Cap. Unit of Measure" := "Qty. per Cap. Unit of Measure";
        END;

        CapLedgEntry."Item No." := "Item No.";
        CapLedgEntry."Variant Code":= "Variant Code";
        CapLedgEntry."Output Quantity" := "Output Quantity";
        CapLedgEntry."Scrap Quantity" := "Scrap Quantity";
        CapLedgEntry."Unit of Measure Code" := "Unit of Measure Code";
        CapLedgEntry."Qty. per Unit of Measure" := "Qty. per Unit of Measure";

        CapLedgEntry."Prod. Order No." := "Prod. Order No.";
        CapLedgEntry."Prod. Order Line No." := "Prod. Order Line No.";
        CapLedgEntry."Routing No." := "Routing No.";
        CapLedgEntry."Routing Reference No." := "Routing Reference No.";
        CapLedgEntry."Operation No." := "Operation No.";

        CapLedgEntry."Posting Date" := "Posting Date";
        CapLedgEntry."Document Date" := "Document Date";
        CapLedgEntry."Document No." := "Document No.";
        CapLedgEntry."External Document No." := "External Document No.";

        CapLedgEntry."Starting Time" := "Starting Time";
        CapLedgEntry."Ending Time" := "Ending Time";
        CapLedgEntry."Concurrent Capacity" := "Concurrent Capacity";
        CapLedgEntry."Work Shift Code" := "Work Shift Code";

        CapLedgEntry."Stop Code" := "Stop Code";
        CapLedgEntry."Scrap Code" := "Scrap Code";
        CapLedgEntry."Last Output Line" := LastOperation;

        CapLedgEntry."Global Dimension 1 Code" := "Shortcut Dimension 1 Code";
        CapLedgEntry."Global Dimension 2 Code" := "Shortcut Dimension 2 Code";
        DimMgt.MoveJnlLineDimToLedgEntryDim(
          TempJnlLineDim,DATABASE::"Capacity Ledger Entry",CapLedgEntry."Entry No.");

        CapLedgEntry.INSERT;

        InsertItemReg(0,0,0,CapLedgEntry."Entry No.");
      END;
    END;

    LOCAL PROCEDURE InsertCapValueEntry@24(VAR CapLedgEntry@1001 : Record 5832;ValueEntryType@1003 : Option;ValuedQty@1005 : Decimal;InvdQty@1004 : Decimal;AdjdCost@1002 : Decimal);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF (InvdQty = 0) AND (AdjdCost = 0) THEN
          EXIT;

        ValueEntryNo := ValueEntryNo + 1;

        ValueEntry.INIT;
        ValueEntry."Entry No." := ValueEntryNo;
        ValueEntry."Capacity Ledger Entry No." := CapLedgEntry."Entry No.";
        ValueEntry."Entry Type" := ValueEntryType;
        ValueEntry."Item Ledger Entry Type" := ValueEntry."Item Ledger Entry Type"::" ";

        ValueEntry.Type := Type;
        ValueEntry."No." := "No.";
        ValueEntry.Description := Description;
        ValueEntry."Prod. Order No." := "Prod. Order No.";
        ValueEntry."Prod. Order Line No." := "Prod. Order Line No.";
        ValueEntry."Source Type" := "Source Type";
        ValueEntry."Source No." := GetSourceNo(ItemJnlLine);
        ValueEntry."Invoiced Quantity" := InvdQty;
        ValueEntry."Valued Quantity" := ValuedQty;

        ValueEntry."Cost Amount (Actual)" := AdjdCost;
        ValueEntry."Cost Amount (Actual) (ACY)" := ACYMgt.CalcACYAmt(AdjdCost,"Posting Date",FALSE);
        ValueEntry."Cost per Unit" :=
          CalcCostPerUnit(ValueEntry."Cost Amount (Actual)",ValueEntry."Valued Quantity",FALSE);
        ValueEntry."Cost per Unit (ACY)" :=
          CalcCostPerUnit(ValueEntry."Cost Amount (Actual) (ACY)",ValueEntry."Valued Quantity",TRUE);
        ValueEntry.Inventoriable := TRUE;

        TESTFIELD("Inventory Posting Group");
        ValueEntry."Inventory Posting Group" := "Inventory Posting Group";
        ValueEntry."Gen. Bus. Posting Group" := "Gen. Bus. Posting Group";
        ValueEntry."Gen. Prod. Posting Group" := "Gen. Prod. Posting Group";

        ValueEntry."Posting Date" := "Posting Date";
        ValueEntry."Valuation Date" := "Posting Date";
        ValueEntry."Source No." := GetSourceNo(ItemJnlLine);
        ValueEntry."Document Type" := "Document Type";
        IF ValueEntry."Expected Cost" OR ("Invoice No." = '') THEN
          ValueEntry."Document No." := "Document No."
        ELSE BEGIN
          ValueEntry."Document No." := "Invoice No.";
          IF "Document Type" IN
             ["Document Type"::"Purchase Receipt","Document Type"::"Purchase Return Shipment",
              "Document Type"::"Sales Shipment","Document Type"::"Sales Return Receipt",
              "Document Type"::"Service Shipment"]
          THEN
            ValueEntry."Document Type" := "Document Type" + 1;
        END;
        ValueEntry."Document Line No." := "Document Line No.";
        ValueEntry."Document Date" := "Document Date";
        ValueEntry."External Document No." := "External Document No.";
        ValueEntry."User ID" := USERID;
        ValueEntry."Source Code" := "Source Code";
        ValueEntry."Reason Code" := "Reason Code";
        ValueEntry."Journal Batch Name" := "Journal Batch Name";

        ValueEntry."Global Dimension 1 Code" := "Shortcut Dimension 1 Code";
        ValueEntry."Global Dimension 2 Code" := "Shortcut Dimension 2 Code";
        DimMgt.MoveJnlLineDimToLedgEntryDim(
          TempJnlLineDim,DATABASE::"Value Entry",ValueEntry."Entry No.");

        InvtPost.SetRunOnlyCheck(TRUE,NOT InvtSetup."Automatic Cost Posting",FALSE);
        IF InvtPost.BufferInvtPosting(ValueEntry) THEN
          InvtPost.PostInvtPostBufPerEntry(ValueEntry);

        ValueEntry.INSERT;

        UpdateAdjmtProp(ValueEntry,CapLedgEntry."Posting Date");

        InsertItemReg(0,0,ValueEntry."Entry No.",0);
        InsertPostValueEntryToGL(ValueEntry);
        IF Item."Item Tracking Code" <> '' THEN BEGIN
          TempValueEntryRelation.INIT;
          TempValueEntryRelation."Value Entry No." := ValueEntry."Entry No.";
          TempValueEntryRelation.INSERT;
        END;
        IF ("Item Shpt. Entry No." <> 0) AND
           (ValueEntryType = "Value Entry Type"::"Direct Cost")
        THEN BEGIN
          CapLedgEntry."Invoiced Quantity" := CapLedgEntry."Invoiced Quantity" + "Invoiced Quantity";
          IF Subcontracting THEN
            CapLedgEntry."Completely Invoiced" := CapLedgEntry."Invoiced Quantity" = CapLedgEntry."Output Quantity"
          ELSE
            CapLedgEntry."Completely Invoiced" := CapLedgEntry."Invoiced Quantity" = CapLedgEntry.Quantity;
          CapLedgEntry.MODIFY;
        END;
      END;
    END;

    LOCAL PROCEDURE ItemQtyPosting@17();
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF Quantity <> "Invoiced Quantity" THEN
          TESTFIELD("Invoiced Quantity",0);
        TESTFIELD("Item Shpt. Entry No.",0);

        InitItemLedgEntry(GlobalItemLedgEntry);
        InitValueEntry(GlobalValueEntry,GlobalItemLedgEntry);

        GlobalItemLedgEntry."Service Order No." := "Service Order No.";
        GlobalItemLedgEntry."Remaining Quantity" := GlobalItemLedgEntry.Quantity;
        GlobalItemLedgEntry.Open := GlobalItemLedgEntry."Remaining Quantity" <> 0;
        GlobalItemLedgEntry.Positive := GlobalItemLedgEntry."Remaining Quantity" > 0;
        IF GlobalItemLedgEntry."Entry Type" = GlobalItemLedgEntry."Entry Type"::Transfer THEN
          GlobalItemLedgEntry."Completely Invoiced" := TRUE;

        IF (GlobalItemLedgEntry.Quantity > 0) THEN
          IF (GlobalItemLedgEntry."Entry Type" <> GlobalItemLedgEntry."Entry Type"::Transfer) THEN
            ReserveItemJnlLine.TransferItemJnlToItemLedgEntry(
              ItemJnlLine,GlobalItemLedgEntry,ItemJnlLine."Quantity (Base)",TRUE);

        ApplyItemLedgEntry(GlobalItemLedgEntry,OldItemLedgEntry,GlobalValueEntry,FALSE);
        AutoTrack(GlobalItemLedgEntry);

        IF ("Entry Type" = "Entry Type"::Transfer) AND AverageTransfer THEN
          InsertTransferEntry(GlobalItemLedgEntry,OldItemLedgEntry,TotalAppliedQty);

        IF (NOT "Phys. Inventory") OR (Quantity <> 0) THEN BEGIN
          InsertItemLedgEntry(GlobalItemLedgEntry,FALSE);
          IF GlobalItemLedgEntry.Positive THEN
            InsertApplEntry(
              GlobalItemLedgEntry."Entry No.",GlobalItemLedgEntry."Entry No.",
              "Applies-from Entry",0,GlobalItemLedgEntry."Posting Date",
              GlobalItemLedgEntry.Quantity,TRUE);
        END;
      END;
    END;

    LOCAL PROCEDURE ItemValuePosting@22();
    VAR
      NegValueEntry@1000 : Record 5802;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF ("Value Entry Type" = "Value Entry Type"::"Direct Cost") AND
           ("Item Charge No." = '') AND
           NOT Adjustment
        THEN BEGIN
          IF (Quantity = 0) AND ("Invoiced Quantity" <> 0) THEN BEGIN
            IF (GlobalValueEntry."Invoiced Quantity" < 0) AND
               (Item."Costing Method" = Item."Costing Method"::Average)
            THEN
              ValuateAppliedAvgEntry(GlobalValueEntry,Item);
          END ELSE BEGIN
            IF (GlobalValueEntry."Valued Quantity" < 0) AND ("Entry Type" <> "Entry Type"::Transfer) THEN
              IF Item."Costing Method" = Item."Costing Method"::Average THEN
                ValuateAppliedAvgEntry(GlobalValueEntry,Item);
          END;
        END;

        InsertValueEntry(GlobalValueEntry,GlobalItemLedgEntry,FALSE);

        IF ("Value Entry Type" <> "Value Entry Type"::"Direct Cost") OR
           ("Item Charge No." <> '')
        THEN BEGIN
          IF ("Value Entry Type" <> "Value Entry Type"::Rounding) AND (NOT Adjustment) THEN BEGIN
            IF GlobalItemLedgEntry.Positive THEN
              GlobalItemLedgEntry.MODIFY;
            IF ((GlobalValueEntry."Valued Quantity" > 0) OR
                (("Applies-to Entry" <> 0) AND ("Entry Type" = "Entry Type"::Purchase))) AND
               (OverheadAmount <> 0)
            THEN
              InsertOHValueEntry(GlobalValueEntry,OverheadAmount,OverheadAmountACY);
            IF (Item."Costing Method" = Item."Costing Method"::Standard) AND
               ("Entry Type" = "Entry Type"::Purchase) AND
               (GlobalValueEntry."Entry Type" <> GlobalValueEntry."Entry Type"::Revaluation)
            THEN
              InsertVarValueEntry(
                GlobalValueEntry,
                -(GlobalValueEntry."Cost Amount (Actual)" + OverheadAmount),
                -(GlobalValueEntry."Cost Amount (Actual) (ACY)" + OverheadAmountACY));
          END;
        END ELSE BEGIN
          IF IsBalanceExpectedCostFromRev(ItemJnlLine) THEN
            InsertBalanceExpCostRevEntry(GlobalValueEntry);

          IF ((GlobalValueEntry."Valued Quantity" > 0) OR
              (("Applies-to Entry" <> 0) AND ("Entry Type" = "Entry Type"::Purchase))) AND
             (OverheadAmount <> 0)
          THEN
            InsertOHValueEntry(GlobalValueEntry,OverheadAmount,OverheadAmountACY);

          IF ((GlobalValueEntry."Valued Quantity" > 0) OR ("Applies-to Entry" <> 0)) AND
             ("Entry Type" = "Entry Type"::Purchase) AND
             (Item."Costing Method" = Item."Costing Method"::Standard) AND
              (ROUND(VarianceAmount,GLSetup."Amount Rounding Precision") <> 0) OR
              VarianceRequired
          THEN
            InsertVarValueEntry(GlobalValueEntry,VarianceAmount,VarianceAmountACY);
        END;
        IF (GlobalValueEntry."Valued Quantity" < 0) AND
           (GlobalItemLedgEntry.Quantity = GlobalItemLedgEntry."Invoiced Quantity")
        THEN
          UpdateItemApplnEntry(GlobalValueEntry."Item Ledger Entry No.","Posting Date");
      END;
    END;

    LOCAL PROCEDURE FlushOperation@33(ProdOrder@1000 : Record 5405;ProdOrderLine@1001 : Record 5406);
    VAR
      ProdOrderRtngLine@1002 : Record 5409;
      ProdOrderComp@1003 : Record 5407;
      OldItemJnlLine@1004 : Record 83;
      OldTempSplitItemJnlLine@1008 : TEMPORARY Record 83;
      OldSNRequired@1006 : Boolean;
      OldLotRequired@1005 : Boolean;
      TmpJnlLineDim@1009 : TEMPORARY Record 356;
      DimMgt@1010 : Codeunit 408;
      OldItemTrackingCode@1011 : Record 6502;
    BEGIN
      IF ItemJnlLine."Operation No." = '' THEN
        EXIT;

      OldItemJnlLine := ItemJnlLine;
      OldTempSplitItemJnlLine.RESET;
      OldTempSplitItemJnlLine.DELETEALL;
      TempSplitItemJnlLine.RESET;
      IF TempSplitItemJnlLine.FINDSET THEN
        REPEAT
          OldTempSplitItemJnlLine := TempSplitItemJnlLine;
          OldTempSplitItemJnlLine.INSERT;
        UNTIL TempSplitItemJnlLine.NEXT = 0;
      OldSNRequired := SNRequired;
      OldLotRequired := LotRequired;
      OldItemTrackingCode := ItemTrackingCode;

      ProdOrderRtngLine.GET(
        ProdOrderRtngLine.Status::Released,
        OldItemJnlLine."Prod. Order No.",
        OldItemJnlLine."Routing Reference No.",
        OldItemJnlLine."Routing No.",
        OldItemJnlLine."Operation No.");
      IF ProdOrderRtngLine."Routing Link Code" <> '' THEN BEGIN
        WITH ProdOrderComp DO BEGIN
          SETCURRENTKEY(Status,"Prod. Order No.","Routing Link Code","Flushing Method");
          SETRANGE("Flushing Method","Flushing Method"::Forward,"Flushing Method"::"Pick + Backward");
          SETRANGE("Routing Link Code",ProdOrderRtngLine."Routing Link Code");
          SETRANGE(Status,ProdOrderComp.Status::Released);
          SETRANGE("Prod. Order No.",OldItemJnlLine."Prod. Order No.");
          SETRANGE("Prod. Order Line No.",OldItemJnlLine."Prod. Order Line No.");
          IF FINDSET THEN BEGIN
            DimMgt.CopyJnlLineDimToJnlLineDim(TempJnlLineDim,TmpJnlLineDim);
            BlockRetrieveIT := TRUE;
            REPEAT
              PostFlushedConsump(
                ProdOrder,ProdOrderLine,ProdOrderComp,
                OldItemJnlLine."Output Quantity (Base)" + OldItemJnlLine."Scrap Quantity (Base)",
                OldItemJnlLine."Posting Date",OldItemJnlLine."Prod. Order No.");
            UNTIL NEXT = 0;
            TempJnlLineDim.DELETEALL;
            DimMgt.CopyJnlLineDimToJnlLineDim(TmpJnlLineDim,TempJnlLineDim);
            BlockRetrieveIT := FALSE;
          END;
        END;
      END;

      ItemJnlLine := OldItemJnlLine;
      TempSplitItemJnlLine.RESET;
      TempSplitItemJnlLine.DELETEALL;
      IF OldTempSplitItemJnlLine.FINDSET THEN
        REPEAT
          TempSplitItemJnlLine := OldTempSplitItemJnlLine;
          TempSplitItemJnlLine.INSERT;
        UNTIL OldTempSplitItemJnlLine.NEXT = 0;
      SNRequired := OldSNRequired;
      LotRequired := OldLotRequired;
      ItemTrackingCode := OldItemTrackingCode;
    END;

    LOCAL PROCEDURE PostFlushedConsump@32(ProdOrder@1000 : Record 5405;ProdOrderLine@1001 : Record 5406;ProdOrderComp@1002 : Record 5407;ActOutputQtyBase@1008 : Decimal;PostingDate@1006 : Date;DocumentNo@1003 : Code[20]);
    VAR
      CompItem@1004 : Record 27;
      OldTempTrackingSpecification@1009 : TEMPORARY Record 336;
      QtyToPost@1007 : Decimal;
      CalcBasedOn@1005 : 'Actual Output,Expected Output';
      PostItemJnlLine2@1013 : Boolean;
      DimsAreTaken@1010 : Boolean;
    BEGIN
      CompItem.GET(ProdOrderComp."Item No.");
      CompItem.TESTFIELD("Rounding Precision");

      IF ProdOrderComp."Flushing Method" IN
        [ProdOrderComp."Flushing Method"::Backward,ProdOrderComp."Flushing Method"::"Pick + Backward"]
      THEN
        QtyToPost :=
          CostCalcMgt.CalcActNeededQtyBase(ProdOrderLine,ProdOrderComp,ActOutputQtyBase)/ProdOrderComp."Qty. per Unit of Measure"
      ELSE
        QtyToPost := ProdOrderComp.GetNeededQty(CalcBasedOn::"Expected Output",TRUE);
      QtyToPost := ROUND(QtyToPost,CompItem."Rounding Precision",'>');

      IF QtyToPost = 0 THEN
        EXIT;

      WITH ItemJnlLine DO BEGIN
        INIT;
        "Line No." := 0;
        "Entry Type" := "Entry Type"::Consumption;
        VALIDATE("Posting Date",PostingDate);
        "Document No." := DocumentNo;
        "Source No." := ProdOrderLine."Item No.";
        "Prod. Order No." := ProdOrderLine."Prod. Order No.";
        VALIDATE("Prod. Order Line No.",ProdOrderLine."Line No.");
        VALIDATE("Prod. Order Comp. Line No.",ProdOrderComp."Line No.");
        VALIDATE("Item No.",ProdOrderComp."Item No.");
        VALIDATE("Unit of Measure Code",ProdOrderComp."Unit of Measure Code");
        Description := ProdOrderComp.Description;
        VALIDATE(Quantity,QtyToPost);
        VALIDATE("Unit Cost",ProdOrderComp."Unit Cost");
        "Location Code" := ProdOrderComp."Location Code";
        "Bin Code" := ProdOrderComp."Bin Code";
        "Variant Code" := ProdOrderComp."Variant Code";
        "Source Code" := SourceCodeSetup.Flushing;
        "Gen. Bus. Posting Group" := ProdOrder."Gen. Bus. Posting Group";
        "Gen. Prod. Posting Group" := CompItem."Gen. Prod. Posting Group";

        OldTempTrackingSpecification.RESET;
        OldTempTrackingSpecification.DELETEALL;
        TempTrackingSpecification.RESET;
        IF TempTrackingSpecification.FINDSET THEN
          REPEAT
            OldTempTrackingSpecification := TempTrackingSpecification;
            OldTempTrackingSpecification.INSERT;
          UNTIL TempTrackingSpecification.NEXT = 0;
        ReserveProdOrderComp.TransferPOCompToItemJnlLine(ProdOrderComp,ItemJnlLine,QtyToPost);
        SetupSplitJnlLine(ItemJnlLine,PostItemJnlLine2);
        WHILE SplitJnlLine(ItemJnlLine,PostItemJnlLine2) DO BEGIN
          IF SNRequired AND ("Serial No." = '') THEN
            ERROR(Text015,"Item No.");
          IF LotRequired AND ("Lot No." = '') THEN
            ERROR(Text016,"Item No.");

          IF NOT DimsAreTaken THEN BEGIN
            TempJnlLineDim.DELETEALL;
            ItemJnlLine.GetDim(TempJnlLineDim);
            DimsAreTaken := TRUE;
          END;
          ItemJnlCheckLine.RunCheck(ItemJnlLine,TempJnlLineDim);
          ProdOrderCompModified := TRUE;
          Quantity := "Quantity (Base)";
          "Invoiced Quantity" := "Invoiced Qty. (Base)";
          QtyPerUnitOfMeasure := "Qty. per Unit of Measure";

          "Unit Amount" := ROUND(
            "Unit Amount" / QtyPerUnitOfMeasure,GLSetup."Unit-Amount Rounding Precision");
          "Unit Cost" := ROUND(
            "Unit Cost" / QtyPerUnitOfMeasure,GLSetup."Unit-Amount Rounding Precision");
          "Unit Cost (ACY)" := ROUND(
            "Unit Cost (ACY)" / QtyPerUnitOfMeasure,Currency."Unit-Amount Rounding Precision");
          PostConsumption;
        END;

        TempTrackingSpecification.RESET;
        TempTrackingSpecification.DELETEALL;
        IF OldTempTrackingSpecification.FINDSET THEN
          REPEAT
            TempTrackingSpecification := OldTempTrackingSpecification;
            TempTrackingSpecification.INSERT;
          UNTIL OldTempTrackingSpecification.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE UpdateUnitCost@9(ValueEntry@1002 : Record 5802);
    VAR
      ItemCostMgt@1000 : Codeunit 5804;
      LastDirectCost@1001 : Decimal;
    BEGIN
      WITH ValueEntry DO BEGIN
        IF ("Valued Quantity" > 0) AND NOT ("Expected Cost" OR ItemJnlLine.Adjustment) THEN BEGIN
          Item.LOCKTABLE;
          IF NOT Item.FIND THEN
            EXIT;

          IF ("Item Ledger Entry Type" IN
              ["Item Ledger Entry Type"::Purchase,
               "Item Ledger Entry Type"::"Positive Adjmt.",
               "Item Ledger Entry Type"::Output]) AND
             ("Cost Amount (Actual)" + "Discount Amount" > 0) AND
             (ItemJnlLine."Value Entry Type" = ItemJnlLine."Value Entry Type"::"Direct Cost") AND
             (ItemJnlLine."Item Charge No." = '') AND
             ("Invoiced Quantity" > 0)
          THEN
            LastDirectCost :=
              ROUND(
                (ItemJnlLine.Amount + ItemJnlLine."Discount Amount") / "Invoiced Quantity",
                GLSetup."Unit-Amount Rounding Precision");
          IF "Drop Shipment" THEN BEGIN
            IF LastDirectCost <> 0 THEN BEGIN
               Item."Last Direct Cost" := LastDirectCost;
               Item.MODIFY;
            END;
          END ELSE BEGIN
            ItemCostMgt.SetProperties(FALSE,"Invoiced Quantity");
            ItemCostMgt.UpdateUnitCost(Item,"Location Code","Variant Code",LastDirectCost,0,TRUE,TRUE,FALSE,0);
          END;
        END;
      END;
    END;

    PROCEDURE UnApply@73(Application@1000 : Record 339);
    VAR
      ItemLedgEntry1@1001 : Record 32;
      ItemLedgEntry2@1002 : Record 32;
      ValueEntry@1003 : Record 5802;
      CostItemLedgEntry@1004 : Record 32;
      InventoryPeriod@1005 : Record 5814;
      SourceCodeSetup@1007 : Record 242;
      TestCode@1009 : Codeunit 21;
      HistoryEntry@1006 : Integer;
      Valuationdate@1008 : Date;
    BEGIN
      IF NOT InventoryPeriod.IsValidDate(Application."Posting Date") THEN
        InventoryPeriod.ShowError(Application."Posting Date");

      // If we can't get both entries then the application is not a real application or a date compression might have been done
      ItemLedgEntry1.GET(Application."Inbound Item Entry No.");
      ItemLedgEntry2.GET(Application."Outbound Item Entry No.");

      IF Application."Item Ledger Entry No." = Application."Inbound Item Entry No." THEN
        IF ItemLedgEntry1.Correction THEN
          ERROR(Text025);
      IF Application."Item Ledger Entry No." = Application."Outbound Item Entry No." THEN
        IF ItemLedgEntry2.Correction THEN
          ERROR(Text025);

      IF ItemLedgEntry1."Drop Shipment" AND ItemLedgEntry2."Drop Shipment" THEN
        ERROR(Text024);

      IF (ItemLedgEntry1."Job Purchase" AND (ItemLedgEntry1."Job No." <> '')) AND ItemLedgEntry2."Job Purchase" THEN
        ERROR(Text028);

      IF ItemLedgEntry2."Entry Type" =  ItemLedgEntry2."Entry Type" :: Transfer THEN
        ERROR(Text023);

      Application.TESTFIELD(Application."Transferred-from Entry No.",0);

      // We won't allow deletion of applications for deleted items
      Item.GET(ItemLedgEntry1."Item No.");
      CostItemLedgEntry.GET(Application.CostReceiver); // costreceiver

      IF ItemLedgEntry1."Applies-to Entry" = ItemLedgEntry2."Entry No." THEN
        ItemLedgEntry1."Applies-to Entry" := 0;

      IF ItemLedgEntry2."Applies-to Entry" = ItemLedgEntry1."Entry No." THEN
        ItemLedgEntry2."Applies-to Entry" := 0;

      // only if real/quantity application
      IF NOT Application.CostApplication THEN BEGIN
        ItemLedgEntry1."Remaining Quantity" := ItemLedgEntry1."Remaining Quantity" - Application.Quantity;
        ItemLedgEntry1.Open := ItemLedgEntry1."Remaining Quantity" <> 0;
        ItemLedgEntry1.MODIFY;

        ItemLedgEntry2."Remaining Quantity" := ItemLedgEntry2."Remaining Quantity" + Application.Quantity;
        ItemLedgEntry2.Open := ItemLedgEntry2."Remaining Quantity" <> 0;
        ItemLedgEntry2.MODIFY;
      END ELSE BEGIN
        ItemLedgEntry2."Shipped Qty. Not Returned" :=  ItemLedgEntry2."Shipped Qty. Not Returned" - ABS(Application.Quantity);
        IF ABS(ItemLedgEntry2."Shipped Qty. Not Returned") > ABS(ItemLedgEntry2.Quantity) THEN
          ItemLedgEntry2.FIELDERROR("Shipped Qty. Not Returned",Text004); // Assert - should never happen
        ItemLedgEntry2.MODIFY;

        // If cost application we need to insert a 0 application instead if there is none before
        IF Application.Quantity > 0 THEN
          IF NOT ZeroApplication(Application."Item Ledger Entry No.") THEN
            InsertApplEntry(
              Application."Item Ledger Entry No.",Application."Inbound Item Entry No.",
              0,0,Application."Posting Date",
              Application.Quantity,TRUE);
      END;

      IF Item."Costing Method" = Item."Costing Method"::Average THEN BEGIN
        IF Application.Fixed THEN BEGIN
          ValueEntry.SETCURRENTKEY("Item Ledger Entry No.");
          ValueEntry.SETRANGE("Item Ledger Entry No.",CostItemLedgEntry."Entry No.");
          ValueEntry.SETRANGE("Valued By Average Cost",FALSE);
          ValueEntry.MODIFYALL("Valued By Average Cost",TRUE);
        END;
      END;

      HistoryEntry := Application.InsertHistory;
      TouchEntry(Application."Inbound Item Entry No.");
      IF Application."Outbound Item Entry No."<>0 THEN
        TouchEntry(Application."Outbound Item Entry No.");
      Application.DELETE;

      Valuationdate := GetMaxAppliedValuationdate(CostItemLedgEntry);
      IF Valuationdate = 0D THEN
        Valuationdate := CostItemLedgEntry."Posting Date"
      ELSE
        Valuationdate := Max(CostItemLedgEntry."Posting Date",Valuationdate);

      SetValuationDateAllValueEntrie(CostItemLedgEntry."Entry No.",Valuationdate);

      UpdateLinkedValuationUnapply(Valuationdate,CostItemLedgEntry."Entry No.",CostItemLedgEntry.Positive);
    END;

    PROCEDURE ReApply@74(ItemLedgEntry@1000 : Record 32;ApplyWith@1001 : Integer);
    VAR
      ItemLedgEntry2@1002 : Record 32;
      ValueEntry@1003 : Record 5802;
      CostItemLedgEntry@1005 : Record 32;
      InventoryPeriod@1004 : Record 5814;
      SNInfoRequired@1006 : Boolean;
      LotInfoRequired@1007 : Boolean;
      TestCode@1008 : Codeunit 21;
      CostApplication@1009 : Boolean;
    BEGIN
      Item.GET(ItemLedgEntry."Item No.");

      IF NOT InventoryPeriod.IsValidDate(ItemLedgEntry."Posting Date") THEN
        InventoryPeriod.ShowError(ItemLedgEntry."Posting Date");

      ItemTrackingCode.Code := Item."Item Tracking Code";
      ItemTrackingMgt.GetItemTrackingSettings(
        ItemTrackingCode,ItemJnlLine."Entry Type",ItemJnlLine.Signed(ItemJnlLine."Quantity (Base)") > 0,
        SNRequired,LotRequired,SNInfoRequired,LotInfoRequired);

      TotalAppliedQty := 0;
      CostApplication := FALSE;
      IF ApplyWith <> 0 THEN BEGIN
        ItemLedgEntry2.GET(ApplyWith);
        IF ItemLedgEntry2.Quantity>0 THEN BEGIN
          // Switch around so ItemLedgEntry is positive and ItemLedgEntry2 is negative
          OldItemLedgEntry:=ItemLedgEntry;
          ItemLedgEntry:=ItemLedgEntry2;
          ItemLedgEntry2:=OldItemLedgEntry;
        END;
        IF NOT((ItemLedgEntry.Quantity>0) AND // not(Costprovider(ItemLedgEntry))
         ((ItemLedgEntry."Entry Type"=ItemLedgEntry2."Entry Type"::Purchase) OR
         (ItemLedgEntry."Entry Type"=ItemLedgEntry2."Entry Type"::"Positive Adjmt.") OR
         (ItemLedgEntry."Entry Type"=ItemLedgEntry2."Entry Type"::Output))
         )
        THEN
          CostApplication := TRUE;
        IF ((ItemLedgEntry."Remaining Quantity"<>0) AND (ItemLedgEntry2."Remaining Quantity"<>0)) THEN
          CostApplication:=FALSE;
        IF CostApplication THEN
          CostApply(ItemLedgEntry,ItemLedgEntry2)
        ELSE BEGIN
          CreateItemJNLLinefromEntry(ItemLedgEntry2,ItemLedgEntry2."Remaining Quantity",ItemJnlLine);
          IF ApplyWith=ItemLedgEntry2."Entry No." THEN
            ItemLedgEntry2."Applies-to Entry" := ItemLedgEntry."Entry No."
          ELSE
            ItemLedgEntry2."Applies-to Entry" := ApplyWith;
          ItemJnlLine."Applies-to Entry" := ItemLedgEntry2."Applies-to Entry";
          GlobalItemLedgEntry:=ItemLedgEntry2;
          ApplyItemLedgEntry(ItemLedgEntry2,OldItemLedgEntry,ValueEntry,FALSE);
          TouchItemEntryCost(ItemLedgEntry2,FALSE);
          ItemLedgEntry2.MODIFY;
          EnsureValueEntryLoaded(ValueEntry,ItemLedgEntry2);
          GetValuationDate(ValueEntry,ItemLedgEntry);
          UpdateLinkedValuationDate(ValueEntry."Valuation Date",GlobalItemLedgEntry."Entry No.",GlobalItemLedgEntry.Positive);
        END;
      END ELSE
      BEGIN  // ApplyWith is 0
        ItemLedgEntry."Applies-to Entry" := ApplyWith;
        CreateItemJNLLinefromEntry(ItemLedgEntry,ItemLedgEntry."Remaining Quantity",ItemJnlLine);
        ItemJnlLine."Applies-to Entry" := ItemLedgEntry."Applies-to Entry";
        GlobalItemLedgEntry:=ItemLedgEntry;
        ApplyItemLedgEntry(ItemLedgEntry,OldItemLedgEntry,ValueEntry,FALSE);
        TouchItemEntryCost(ItemLedgEntry,FALSE);
        ItemLedgEntry.MODIFY;
        EnsureValueEntryLoaded(ValueEntry,ItemLedgEntry);
        GetValuationDate(ValueEntry,ItemLedgEntry);
        UpdateLinkedValuationDate(ValueEntry."Valuation Date",GlobalItemLedgEntry."Entry No.",GlobalItemLedgEntry.Positive);
      END;
    END;

    PROCEDURE CostApply@72(VAR ItemLedgEntry@1000 : Record 32;ItemLedgEntry2@1001 : Record 32);
    VAR
      ApplyWith@1002 : Integer;
      ValueEntry@1004 : Record 5802;
    BEGIN
      IF ItemLedgEntry.Quantity > 0 THEN BEGIN
        GlobalItemLedgEntry := ItemLedgEntry;
        ApplyWith := ItemLedgEntry2."Entry No.";
      END
      ELSE BEGIN
        GlobalItemLedgEntry := ItemLedgEntry2;
        ApplyWith := ItemLedgEntry."Entry No.";
      END;
      IF NOT ItemApplnEntry.CheckIsCyclicalLoop(ApplyWith,GlobalItemLedgEntry) THEN BEGIN
        CreateItemJNLLinefromEntry(GlobalItemLedgEntry,GlobalItemLedgEntry.Quantity,ItemJnlLine);
        InsertApplEntry(
          GlobalItemLedgEntry."Entry No.",GlobalItemLedgEntry."Entry No.",
          ApplyWith,0,GlobalItemLedgEntry."Posting Date",
          GlobalItemLedgEntry.Quantity,TRUE);
        UpdateOutboundItemLedgEntry(ApplyWith);
        OldItemLedgEntry.GET(ApplyWith);
        EnsureValueEntryLoaded(ValueEntry,GlobalItemLedgEntry);
        ItemJnlLine."Applies-from Entry":=ApplyWith;
        GetAppliedFromValues(ValueEntry);
        SetValuationDateAllValueEntrie(GlobalItemLedgEntry."Entry No.",ValueEntry."Valuation Date");
        UpdateLinkedValuationDate(ValueEntry."Valuation Date",GlobalItemLedgEntry."Entry No.",GlobalItemLedgEntry.Positive);
      END;
    END;

    PROCEDURE ZeroApplication@75(EntryNo@1000 : Integer) : Boolean;
    VAR
      Application@1001 : Record 339;
    BEGIN
      Application.SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.");
      Application.SETRANGE("Item Ledger Entry No.",EntryNo);
      Application.SETRANGE("Inbound Item Entry No.",EntryNo);
      Application.SETRANGE("Outbound Item Entry No.",0);
      EXIT(NOT(Application.ISEMPTY));
    END;

    LOCAL PROCEDURE ApplyItemLedgEntry@1(VAR ItemLedgEntry@1000 : Record 32;VAR OldItemLedgEntry@1001 : Record 32;VAR ValueEntry@1002 : Record 5802;CausedByTransfer@1003 : Boolean);
    VAR
      Location@1012 : Record 14;
      ItemLedgEntry2@1004 : Record 32;
      ReservEntry@1005 : Record 337;
      ReservEntry2@1006 : Record 337;
      OldValueEntry@1106000000 : Record 5802;
      EntryFindMethod@1007 : Text[1];
      AppliedQty@1008 : Decimal;
      FirstReservation@1009 : Boolean;
      FirstApplication@1010 : Boolean;
      StartApplication@1011 : Boolean;
      UseReservationApplication@1014 : Boolean;
    BEGIN
      IF (ItemLedgEntry."Remaining Quantity" = 0) OR
         (ItemLedgEntry."Drop Shipment" AND (ItemLedgEntry."Applies-to Entry" = 0)) OR
         ((Item."Costing Method" = Item."Costing Method"::Specific) AND ItemLedgEntry.Positive)
      THEN
        EXIT;

      CLEAR(OldItemLedgEntry);
      FirstReservation := TRUE;
      FirstApplication := TRUE;
      StartApplication := FALSE;
      REPEAT
        ItemJnlLine.CALCFIELDS("Reserved Qty. (Base)");
        IF ItemJnlLine."Reserved Qty. (Base)" <> 0 THEN
          IF ItemLedgEntry."Applies-to Entry" <> 0 THEN
            ItemLedgEntry.FIELDERROR(
              "Applies-to Entry",Text99000000);

        IF NOT CausedByTransfer AND NOT PostponeReservationHandling THEN BEGIN

          IF Item."Costing Method" = Item."Costing Method"::Specific THEN
            ItemJnlLine.TESTFIELD("Serial No.");

          IF FirstReservation THEN BEGIN
            FirstReservation := FALSE;

            ReservEntry.RESET;
            ReservEntry.SETCURRENTKEY(
              "Source ID","Source Ref. No.","Source Type","Source Subtype",
              "Source Batch Name","Source Prod. Order Line","Reservation Status");
            ReservEntry.SETRANGE("Reservation Status",ReservEntry."Reservation Status"::Reservation);
            ReserveItemJnlLine.FilterReservFor(ReservEntry,ItemJnlLine);
          END;

          UseReservationApplication := ReservEntry.FINDFIRST;

          IF NOT UseReservationApplication THEN BEGIN // No reservations exist
            ReservEntry.SETRANGE(
              "Reservation Status",ReservEntry."Reservation Status"::Tracking,
              ReservEntry."Reservation Status"::Prospect);
            IF ReservEntry.FINDSET THEN
              REPEAT
                ReservEngineMgt.CloseReservEntry(ReservEntry,FALSE,FALSE);
              UNTIL ReservEntry.NEXT = 0;
            StartApplication := TRUE;
          END;

          IF UseReservationApplication THEN BEGIN
            ReservEntry2.GET(ReservEntry."Entry No.",NOT ReservEntry.Positive);
            IF ReservEntry2."Source Type" <> DATABASE::"Item Ledger Entry" THEN
              IF ItemLedgEntry.Quantity < 0 THEN
                ERROR(Text003,ReservEntry."Item No.");
            OldItemLedgEntry.GET(ReservEntry2."Source Ref. No.");
            IF ItemLedgEntry.Quantity < 0 THEN
              IF OldItemLedgEntry."Remaining Quantity" < ReservEntry2."Quantity (Base)" THEN
                ERROR(Text003,ReservEntry2."Item No.");

            OldItemLedgEntry.TESTFIELD("Item No.",ItemJnlLine."Item No.");
            OldItemLedgEntry.TESTFIELD("Variant Code",ItemJnlLine."Variant Code");
            OldItemLedgEntry.TESTFIELD("Location Code",ItemJnlLine."Location Code");
            ReservEngineMgt.CloseReservEntry(ReservEntry,FALSE,FALSE);
            OldItemLedgEntry.CALCFIELDS("Reserved Quantity");
            ItemJnlLine.CALCFIELDS("Reserved Qty. (Base)");
            AppliedQty := -ABS(ReservEntry."Quantity (Base)");
          END;
        END ELSE
          StartApplication := TRUE;

        IF StartApplication THEN BEGIN
          ItemLedgEntry.CALCFIELDS("Reserved Quantity");
          IF ItemLedgEntry."Applies-to Entry" <> 0 THEN BEGIN
            IF FirstApplication THEN BEGIN
              FirstApplication := FALSE;
              OldItemLedgEntry.GET(ItemLedgEntry."Applies-to Entry");
              OldItemLedgEntry.TESTFIELD("Item No.",ItemLedgEntry."Item No.");
              OldItemLedgEntry.TESTFIELD("Variant Code",ItemLedgEntry."Variant Code");

              OldItemLedgEntry.TESTFIELD(Positive,NOT ItemLedgEntry.Positive);
              OldItemLedgEntry.TESTFIELD("Location Code",ItemLedgEntry."Location Code");
              IF Location.GET(ItemLedgEntry."Location Code") THEN
                IF Location."Use As In-Transit" THEN
                  OldItemLedgEntry.TESTFIELD("Transfer Order No.",ItemLedgEntry."Transfer Order No.");

              IF ItemTrackingCode."SN Specific Tracking" OR ItemLedgEntry."Drop Shipment" THEN
                OldItemLedgEntry.TESTFIELD("Serial No.",ItemLedgEntry."Serial No.");
              IF ItemTrackingCode."Lot Specific Tracking" OR ItemLedgEntry."Drop Shipment" THEN
                OldItemLedgEntry.TESTFIELD("Lot No.",ItemLedgEntry."Lot No.");

              OldItemLedgEntry.CALCFIELDS("Reserved Quantity");
              IF  NOT ((OldItemLedgEntry.Open) AND
                (ABS(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity") >=
                 ABS(ItemLedgEntry."Remaining Quantity" - ItemLedgEntry."Reserved Quantity"))) THEN BEGIN
                IF  (ABS(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity") <=
                   ABS(ItemLedgEntry."Remaining Quantity" - ItemLedgEntry."Reserved Quantity"))
                THEN BEGIN
                  IF NOT MoveApplication(ItemLedgEntry,OldItemLedgEntry) THEN
                    OldItemLedgEntry.FIELDERROR("Remaining Quantity",Text004);
                END
                ELSE
                  OldItemLedgEntry.TESTFIELD(Open,TRUE);
              END;

              IF ABS(OldItemLedgEntry."Remaining Quantity") <= ABS(OldItemLedgEntry."Reserved Quantity") THEN
                ReservationPreventsApplication(ItemLedgEntry."Applies-to Entry",ItemLedgEntry."Item No.",OldItemLedgEntry);

              IF OldItemLedgEntry."Prod. Order No." <> '' THEN
                IF NOT AllowProdApplication(OldItemLedgEntry,ItemLedgEntry) THEN
                  ERROR(
                    Text022,
                    ItemLedgEntry."Entry Type",
                    OldItemLedgEntry."Entry Type",
                    OldItemLedgEntry."Item No.",
                    OldItemLedgEntry."Prod. Order No.")
            END ELSE
              EXIT;
          END ELSE BEGIN
            IF FirstApplication THEN BEGIN
              FirstApplication := FALSE;
              ItemLedgEntry2.SETCURRENTKEY(
                "Item No.",Open,"Variant Code",Positive,"Location Code","Posting Date");
              ItemLedgEntry2.SETRANGE("Item No.",ItemLedgEntry."Item No.");
              ItemLedgEntry2.SETRANGE(Open,TRUE);
              ItemLedgEntry2.SETRANGE("Variant Code",ItemLedgEntry."Variant Code");
              ItemLedgEntry2.SETRANGE(Positive,NOT ItemLedgEntry.Positive);
              ItemLedgEntry2.SETRANGE("Location Code",ItemLedgEntry."Location Code");

              IF ItemLedgEntry."Job Purchase" = TRUE THEN BEGIN
                ItemLedgEntry2.SETRANGE("Job No.",ItemLedgEntry."Job No.");
                ItemLedgEntry2.SETRANGE("Job Task No.",ItemLedgEntry."Job Task No.");
              END;
              IF ItemTrackingCode."SN Specific Tracking" THEN
                ItemLedgEntry2.SETRANGE("Serial No.",ItemLedgEntry."Serial No.");
              IF ItemTrackingCode."Lot Specific Tracking" THEN
                ItemLedgEntry2.SETRANGE("Lot No.",ItemLedgEntry."Lot No.");

              IF Location.GET(ItemLedgEntry."Location Code") THEN
                IF Location."Use As In-Transit" THEN
                  ItemLedgEntry2.SETRANGE("Transfer Order No.",ItemLedgEntry."Transfer Order No.");

              IF Item."Costing Method" = Item."Costing Method"::LIFO THEN
                EntryFindMethod := '+'
              ELSE
                EntryFindMethod := '-';
              IF NOT ItemLedgEntry2.FIND(EntryFindMethod) THEN
                EXIT;
            END ELSE
              CASE EntryFindMethod OF
                '-':
                  IF ItemLedgEntry2.NEXT = 0 THEN
                    EXIT;
                '+':
                  IF ItemLedgEntry2.NEXT(-1) = 0 THEN
                    EXIT;
              END;
            OldItemLedgEntry.COPY(ItemLedgEntry2)
          END;

          OldItemLedgEntry.CALCFIELDS("Reserved Quantity");

          IF ABS(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity") >
             ABS(ItemLedgEntry."Remaining Quantity" - ItemLedgEntry."Reserved Quantity")
          THEN
            AppliedQty := ItemLedgEntry."Remaining Quantity" - ItemLedgEntry."Reserved Quantity"
          ELSE
            AppliedQty := -(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity");

          IF ItemLedgEntry."Entry Type" = ItemLedgEntry."Entry Type"::Transfer THEN
            IF (OldItemLedgEntry."Entry No." > ItemLedgEntry."Entry No.") AND NOT ItemLedgEntry.Positive  THEN
              AppliedQty := 0;
          IF OldItemLedgEntry."Prod. Order No." <> '' THEN
            IF NOT AllowProdApplication(OldItemLedgEntry,ItemLedgEntry) THEN
              AppliedQty := 0;
          IF ItemJnlLine."Applies-from Entry" <> 0 THEN
            IF ItemApplnEntry.CheckIsCyclicalLoop(ItemJnlLine."Applies-from Entry",OldItemLedgEntry) THEN
              AppliedQty := 0;
          IF AppliedQty <> 0 THEN
            IF ItemLedgEntry.Positive THEN BEGIN
              IF ItemApplnEntry.CheckIsCyclicalLoop(ItemLedgEntry."Entry No.",OldItemLedgEntry) THEN
                AppliedQty := 0;
            END ELSE
              IF ItemApplnEntry.CheckIsCyclicalLoop(OldItemLedgEntry."Entry No.",ItemLedgEntry) THEN
                AppliedQty := 0;
        END;

        IF AppliedQty <> 0 THEN BEGIN
          IF NOT OldItemLedgEntry.Positive AND
             (OldItemLedgEntry."Remaining Quantity" = -AppliedQty) AND
             (OldItemLedgEntry."Entry No." = ItemLedgEntry."Applies-to Entry")
          THEN BEGIN
            OldValueEntry.SETCURRENTKEY("Item Ledger Entry No.");
            OldValueEntry.SETRANGE("Item Ledger Entry No.",OldItemLedgEntry."Entry No.");
            IF OldValueEntry.FIND('-') THEN
              REPEAT
                IF OldValueEntry."Valued By Average Cost" THEN BEGIN
                  OldValueEntry."Valued By Average Cost" := FALSE;
                  OldValueEntry.MODIFY;
                END;
              UNTIL OldValueEntry.NEXT = 0;
          END;

          OldItemLedgEntry."Remaining Quantity" := OldItemLedgEntry."Remaining Quantity" + AppliedQty;
          OldItemLedgEntry.Open := OldItemLedgEntry."Remaining Quantity" <> 0;

          IF ItemLedgEntry.Positive THEN BEGIN
            IF ItemLedgEntry."Posting Date" >= OldItemLedgEntry."Posting Date" THEN
              InsertApplEntry(
                OldItemLedgEntry."Entry No.",ItemLedgEntry."Entry No.",
              OldItemLedgEntry."Entry No.",0,ItemLedgEntry."Posting Date",-AppliedQty,FALSE)
            ELSE
              InsertApplEntry(
                OldItemLedgEntry."Entry No.",ItemLedgEntry."Entry No.",
                OldItemLedgEntry."Entry No.",0,OldItemLedgEntry."Posting Date",-AppliedQty,FALSE);

            IF ItemApplnEntry."Cost Application" THEN
              ItemLedgEntry."Applied Entry to Adjust" := TRUE;
          END ELSE BEGIN
            IF ItemTrackingCode."Strict Expiration Posting" AND (OldItemLedgEntry."Expiration Date" <> 0D) THEN
              IF ItemLedgEntry."Posting Date" > OldItemLedgEntry."Expiration Date" THEN
                IF (ItemLedgEntry."Entry Type" <> ItemLedgEntry."Entry Type"::"Negative Adjmt.") AND
                   NOT ItemJnlLine.IsReclass(ItemJnlLine)
                THEN
                  OldItemLedgEntry.FIELDERROR("Expiration Date",Text017);

            ItemLedgEntry."Expiration Date" := 0D; // No Expiration date on negative entries

            InsertApplEntry(
              ItemLedgEntry."Entry No.",OldItemLedgEntry."Entry No.",ItemLedgEntry."Entry No.",0,
              ItemLedgEntry."Posting Date",AppliedQty,TRUE);

            IF ItemApplnEntry."Cost Application" THEN
              OldItemLedgEntry."Applied Entry to Adjust" := TRUE;
          END;

          OldItemLedgEntry.MODIFY;
          AutoTrack(OldItemLedgEntry);

          EnsureValueEntryLoaded(ValueEntry,ItemLedgEntry);
          GetValuationDate(ValueEntry,OldItemLedgEntry);

          IF (ItemLedgEntry."Entry Type" = ItemLedgEntry."Entry Type"::Transfer) AND
             (AppliedQty < 0) AND
             NOT CausedByTransfer
          THEN BEGIN
            IF ItemLedgEntry."Completely Invoiced" THEN
              ItemLedgEntry."Completely Invoiced" := OldItemLedgEntry."Completely Invoiced";
            IF AverageTransfer THEN
              TotalAppliedQty := TotalAppliedQty + AppliedQty
            ELSE
              InsertTransferEntry(ItemLedgEntry,OldItemLedgEntry,AppliedQty);
          END;

          ItemLedgEntry."Remaining Quantity" := ItemLedgEntry."Remaining Quantity" - AppliedQty;
          ItemLedgEntry.Open := ItemLedgEntry."Remaining Quantity" <> 0;

          ItemLedgEntry.CALCFIELDS("Reserved Quantity");
          IF ItemLedgEntry."Remaining Quantity" + ItemLedgEntry."Reserved Quantity" = 0 THEN
            EXIT;
        END;
      UNTIL FALSE;
    END;

    PROCEDURE EnsureValueEntryLoaded@76(VAR ValueEntry@1000 : Record 5802;ItemLedgEntry@1001 : Record 32);
    BEGIN
      ValueEntry.SETCURRENTKEY("Item Ledger Entry No.");
      ValueEntry.SETRANGE("Item Ledger Entry No.",ItemLedgEntry."Entry No.");
      IF ValueEntry.FIND('-') THEN;
    END;

    LOCAL PROCEDURE AllowProdApplication@48(OldItemLedgEntry@1000 : Record 32;ItemLedgEntry@1001 : Record 32) : Boolean;
    BEGIN
      EXIT(
        (OldItemLedgEntry."Entry Type" = ItemLedgEntry."Entry Type") OR
        (OldItemLedgEntry."Prod. Order No." <> ItemLedgEntry."Prod. Order No.") OR
        ((OldItemLedgEntry."Prod. Order No." = ItemLedgEntry."Prod. Order No.") AND
          (OldItemLedgEntry."Prod. Order Line No." <> ItemLedgEntry."Prod. Order Line No.")));
    END;

    LOCAL PROCEDURE InsertTransferEntry@6(VAR ItemLedgEntry@1000 : Record 32;VAR OldItemLedgEntry@1001 : Record 32;VAR AppliedQty@1002 : Decimal);
    VAR
      NewItemLedgEntry@1003 : Record 32;
      NewValueEntry@1004 : Record 5802;
      ItemLedgEntry2@1005 : Record 32;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        InitItemLedgEntry(NewItemLedgEntry);
        NewItemLedgEntry."Applies-to Entry" := 0;

        NewItemLedgEntry.Quantity := -AppliedQty;
        NewItemLedgEntry."Invoiced Quantity" := NewItemLedgEntry.Quantity;

        NewItemLedgEntry."Remaining Quantity" := NewItemLedgEntry.Quantity;
        NewItemLedgEntry.Open := NewItemLedgEntry."Remaining Quantity" <> 0;
        NewItemLedgEntry.Positive := NewItemLedgEntry."Remaining Quantity" > 0;

        NewItemLedgEntry."Location Code" := "New Location Code";
        NewItemLedgEntry."Country/Region Code" := "Country/Region Code";
        InsertCountryCode(NewItemLedgEntry,ItemLedgEntry);

        NewItemLedgEntry."Serial No." := "New Serial No.";
        NewItemLedgEntry."Lot No." := "New Lot No.";

        NewItemLedgEntry."Expiration Date" := "New Item Expiration Date";

        IF Item."Item Tracking Code" <> '' THEN BEGIN
          TempItemEntryRelation."Item Entry No." := NewItemLedgEntry."Entry No."; // Save Entry No. in a global variable
          TempItemEntryRelation."Serial No." := NewItemLedgEntry."Serial No.";
          TempItemEntryRelation."Lot No." := NewItemLedgEntry."Lot No.";
          TempItemEntryRelation.INSERT;
        END;
        InitTransValueEntry(NewValueEntry,NewItemLedgEntry);

        IF AverageTransfer THEN BEGIN
          InsertApplEntry(
            NewItemLedgEntry."Entry No.",NewItemLedgEntry."Entry No.",ItemLedgEntry."Entry No.",
            0,NewItemLedgEntry."Posting Date",NewItemLedgEntry.Quantity,TRUE);
          NewItemLedgEntry."Completely Invoiced" := ItemLedgEntry."Completely Invoiced";
        END ELSE BEGIN
          InsertApplEntry(
            NewItemLedgEntry."Entry No.",NewItemLedgEntry."Entry No.",ItemLedgEntry."Entry No.",
            OldItemLedgEntry."Entry No.",NewItemLedgEntry."Posting Date",NewItemLedgEntry.Quantity,TRUE);
          NewItemLedgEntry."Completely Invoiced" := OldItemLedgEntry."Completely Invoiced";
        END;

        IF (NewItemLedgEntry.Quantity > 0) THEN
          ReserveItemJnlLine.TransferItemJnlToItemLedgEntry(ItemJnlLine,NewItemLedgEntry,
            NewItemLedgEntry."Remaining Quantity",TRUE);

        ApplyItemLedgEntry(NewItemLedgEntry,ItemLedgEntry2,NewValueEntry,TRUE);
        AutoTrack(NewItemLedgEntry);

        InsertItemLedgEntry(NewItemLedgEntry,TRUE);
        InsertValueEntry(NewValueEntry,NewItemLedgEntry,TRUE);

        UpdateUnitCost(NewValueEntry);
      END;
    END;

    LOCAL PROCEDURE InitItemLedgEntry@4(VAR ItemLedgEntry@1000 : Record 32);
    BEGIN
      ItemLedgEntryNo := ItemLedgEntryNo + 1;

      WITH ItemJnlLine DO BEGIN
        ItemLedgEntry.INIT;
        ItemLedgEntry."Entry No." := ItemLedgEntryNo;
        ItemLedgEntry."Item No." := "Item No.";
        ItemLedgEntry."Posting Date" := "Posting Date";
        ItemLedgEntry."Document Date" := "Document Date";
        ItemLedgEntry."Entry Type" := "Entry Type";
        ItemLedgEntry."Source No." := "Source No.";
        ItemLedgEntry."Document No." := "Document No.";
        ItemLedgEntry."Document Type" := "Document Type";
        ItemLedgEntry."Document Line No." := "Document Line No.";
        ItemLedgEntry."Transfer Order No." := "Transfer Order No.";
        ItemLedgEntry."External Document No." := "External Document No.";
        ItemLedgEntry.Description := Description;
        ItemLedgEntry."Location Code" := "Location Code";
        ItemLedgEntry."Applies-to Entry" := "Applies-to Entry";
        ItemLedgEntry."Source Type" := "Source Type";
        ItemLedgEntry."Transaction Type" := "Transaction Type";
        ItemLedgEntry."Transport Method" := "Transport Method";
        ItemLedgEntry."Country/Region Code" := "Country/Region Code";
        IF (ItemJnlLine."Entry Type" = ItemJnlLine."Entry Type"::Transfer) AND ("New Location Code" <> '') THEN BEGIN
          IF NewLocation.Code <> "New Location Code" THEN
            NewLocation.GET("New Location Code");
          ItemLedgEntry."Country/Region Code" := NewLocation."Country/Region Code";
        END;
        ItemLedgEntry."Entry/Exit Point" := "Entry/Exit Point";
        ItemLedgEntry.Area := Area;
        ItemLedgEntry."Transaction Specification" := "Transaction Specification";
        ItemLedgEntry."Drop Shipment" := "Drop Shipment";
        ItemLedgEntry."No. Series" := "Posting No. Series";
        IF ItemLedgEntry.Description = Item.Description THEN
          ItemLedgEntry.Description := '';
        ItemLedgEntry."Shipment Method Code" := "Shipment Method Code";
        ItemLedgEntry."Prod. Order No." := "Prod. Order No.";
        ItemLedgEntry."Prod. Order Line No." := "Prod. Order Line No.";
        ItemLedgEntry."Prod. Order Comp. Line No." := "Prod. Order Comp. Line No.";
        ItemLedgEntry."Variant Code" := "Variant Code";
        ItemLedgEntry."Unit of Measure Code" := "Unit of Measure Code";
        ItemLedgEntry."Qty. per Unit of Measure" := "Qty. per Unit of Measure";
        ItemLedgEntry."Derived from Blanket Order" := "Derived from Blanket Order";

        ItemLedgEntry."Cross-Reference No." := "Cross-Reference No.";
        ItemLedgEntry."Originally Ordered No." := "Originally Ordered No.";
        ItemLedgEntry."Originally Ordered Var. Code" := "Originally Ordered Var. Code";
        ItemLedgEntry."Out-of-Stock Substitution" := "Out-of-Stock Substitution";
        ItemLedgEntry."Item Category Code" := "Item Category Code";
        ItemLedgEntry.Nonstock := Nonstock;
        ItemLedgEntry."Purchasing Code" := "Purchasing Code";
        ItemLedgEntry."Return Reason Code" := "Return Reason Code";
        ItemLedgEntry."Product Group Code" := "Product Group Code";
        ItemLedgEntry."Job No." := "Job No.";
        ItemLedgEntry."Job Task No." := "Job Task No.";
        ItemLedgEntry."Job Purchase" := "Job Purchase";
        ItemLedgEntry."Serial No." := "Serial No.";
        ItemLedgEntry."Lot No." := "Lot No.";
        ItemLedgEntry."Warranty Date" := "Warranty Date";
        ItemLedgEntry."Expiration Date" := "Item Expiration Date";

        IF "Entry Type" IN
           ["Entry Type"::Sale,
            "Entry Type"::"Negative Adjmt.",
            "Entry Type"::Transfer,
            "Entry Type"::Consumption]
        THEN BEGIN
          ItemLedgEntry.Quantity := -Quantity;
          ItemLedgEntry."Invoiced Quantity" := -"Invoiced Quantity";
        END ELSE BEGIN
          ItemLedgEntry.Quantity := Quantity;
          ItemLedgEntry."Invoiced Quantity" := "Invoiced Quantity";
        END;
        IF (ItemLedgEntry.Quantity < 0) AND ("Entry Type" <> "Entry Type"::Transfer) THEN
          ItemLedgEntry."Shipped Qty. Not Returned" := ItemLedgEntry.Quantity;
      END;
    END;

    LOCAL PROCEDURE InsertItemLedgEntry@5(VAR ItemLedgEntry@1000 : Record 32;TransferItem@1002 : Boolean);
    VAR
      LedgEntryDim@1003 : Record 355;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF ItemLedgEntry.Open THEN BEGIN
          IF (((ItemLedgEntry."Entry Type" IN
            [ItemLedgEntry."Entry Type"::"Negative Adjmt.",
            ItemLedgEntry."Entry Type"::Consumption]) AND
            ("Source Type" = "Source Type"::Item)) OR
            (ItemLedgEntry."Entry Type" = ItemLedgEntry."Entry Type"::Transfer)) AND
            (ItemLedgEntry.Quantity < 0)
          THEN
            ERROR(Text005,ItemLedgEntry."Item No.");

          IF (ItemLedgEntry.Quantity < 0) AND
            (ItemTrackingCode."SN Specific Tracking" OR ItemTrackingCode."Lot Specific Tracking")
          THEN
            ERROR(Text018,"Serial No.","Lot No.","Item No.","Variant Code");

          IF (ItemLedgEntry.Quantity > 0) AND ItemTrackingCode."SN Specific Tracking" THEN
            IF "Entry Type" = "Entry Type"::Transfer THEN BEGIN
              IF ItemTrackingMgt.FindInInventory("Item No.","Variant Code","New Serial No.") THEN
                ERROR(Text014,"New Serial No.");
            END ELSE BEGIN
              IF ItemTrackingMgt.FindInInventory("Item No.","Variant Code","Serial No.") THEN
                ERROR(Text014,"Serial No.");
            END;

          IF (Item.Reserve = Item.Reserve::Always) AND
             (ItemLedgEntry.Quantity < 0)
          THEN
            ERROR(Text012,ItemLedgEntry."Item No.");
        END;

        IF TransferItem THEN BEGIN
          ItemLedgEntry."Global Dimension 1 Code" := "New Shortcut Dimension 1 Code";
          ItemLedgEntry."Global Dimension 2 Code" := "New Shortcut Dimension 2 Code";
          IF TempJnlLineDim.FINDSET THEN BEGIN
            REPEAT
              IF TempJnlLineDim."New Dimension Value Code" <> '' THEN BEGIN
                LedgEntryDim.INIT;
                LedgEntryDim."Table ID" := DATABASE::"Item Ledger Entry";
                LedgEntryDim."Entry No." := ItemLedgEntry."Entry No.";
                LedgEntryDim."Dimension Code" := TempJnlLineDim."Dimension Code";
                LedgEntryDim."Dimension Value Code" := TempJnlLineDim."New Dimension Value Code";
                LedgEntryDim.INSERT;
              END;
            UNTIL TempJnlLineDim.NEXT = 0;
          END;
        END ELSE BEGIN
          ItemLedgEntry."Global Dimension 1 Code" := "Shortcut Dimension 1 Code";
          ItemLedgEntry."Global Dimension 2 Code" := "Shortcut Dimension 2 Code";
          DimMgt.MoveJnlLineDimToLedgEntryDim(
            TempJnlLineDim,DATABASE::"Item Ledger Entry",ItemLedgEntry."Entry No.");
        END;

        IF NOT ("Entry Type" IN ["Entry Type"::Transfer,"Entry Type"::Output]) AND
           (ItemLedgEntry.Quantity = ItemLedgEntry."Invoiced Quantity")
        THEN
          ItemLedgEntry."Completely Invoiced" := TRUE;

        IF ("Value Entry Type" = "Value Entry Type"::"Direct Cost") AND ("Item Charge No." = '') AND
           ("Invoiced Quantity" <> 0) AND ("Posting Date" > ItemLedgEntry."Last Invoice Date")
        THEN
          ItemLedgEntry."Last Invoice Date" := "Posting Date";

        IF "Entry Type" = "Entry Type"::Consumption THEN
          ItemLedgEntry."Applied Entry to Adjust" := TRUE;

        IF "Job No." <> '' THEN BEGIN
          ItemLedgEntry."Job No." := "Job No.";
          ItemLedgEntry."Job Task No." := "Job Task No.";
        END;

        ItemLedgEntry.UpdateItemTracking;

        ItemLedgEntry.INSERT;

        InsertItemReg(ItemLedgEntry."Entry No.",0,0,0);
      END;
    END;

    LOCAL PROCEDURE InsertItemReg@7(ItemLedgEntryNo@1000 : Integer;PhysInvtEntryNo@1001 : Integer;ValueEntryNo@1002 : Integer;CapLedgEntryNo@1004 : Integer);
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF ItemReg."No." = 0 THEN BEGIN
          ItemReg.LOCKTABLE;
          IF ItemReg.FIND('+') THEN
            ItemReg."No." := ItemReg."No." + 1
          ELSE
            ItemReg."No." := 1;
          ItemReg.INIT;
          ItemReg."From Entry No." := ItemLedgEntryNo;
          ItemReg."To Entry No." := ItemLedgEntryNo;
          ItemReg."From Phys. Inventory Entry No." := PhysInvtEntryNo;
          ItemReg."To Phys. Inventory Entry No." := PhysInvtEntryNo;
          ItemReg."From Value Entry No." := ValueEntryNo;
          ItemReg."To Value Entry No." := ValueEntryNo;
          ItemReg."From Capacity Entry No." := CapLedgEntryNo;
          ItemReg."To Capacity Entry No." := CapLedgEntryNo;
          ItemReg."Creation Date" := TODAY;
          ItemReg."Source Code" := "Source Code";
          ItemReg."Journal Batch Name" := "Journal Batch Name";
          ItemReg."User ID" := USERID;
          ItemReg.INSERT;
        END ELSE BEGIN
          IF ((ItemLedgEntryNo < ItemReg."From Entry No.") AND (ItemLedgEntryNo <> 0)) OR
             ((ItemReg."From Entry No." = 0) AND (ItemLedgEntryNo > 0))
          THEN
            ItemReg."From Entry No." := ItemLedgEntryNo;
          IF ItemLedgEntryNo > ItemReg."To Entry No." THEN
            ItemReg."To Entry No." := ItemLedgEntryNo;

          IF ((PhysInvtEntryNo < ItemReg."From Phys. Inventory Entry No.") AND (PhysInvtEntryNo <> 0)) OR
             ((ItemReg."From Phys. Inventory Entry No." = 0) AND (PhysInvtEntryNo > 0))
          THEN
            ItemReg."From Phys. Inventory Entry No." := PhysInvtEntryNo;
          IF PhysInvtEntryNo > ItemReg."To Phys. Inventory Entry No." THEN
            ItemReg."To Phys. Inventory Entry No." := PhysInvtEntryNo;

          IF ((ValueEntryNo < ItemReg."From Value Entry No.") AND (ValueEntryNo <> 0)) OR
             ((ItemReg."From Value Entry No." = 0) AND (ValueEntryNo > 0))
          THEN
            ItemReg."From Value Entry No." := ValueEntryNo;
          IF ValueEntryNo > ItemReg."To Value Entry No." THEN
            ItemReg."To Value Entry No." := ValueEntryNo;
          IF ((CapLedgEntryNo < ItemReg."From Capacity Entry No.") AND (CapLedgEntryNo <> 0)) OR
             ((ItemReg."From Capacity Entry No." = 0) AND (CapLedgEntryNo > 0))
          THEN
            ItemReg."From Capacity Entry No." := CapLedgEntryNo;
          IF CapLedgEntryNo > ItemReg."To Capacity Entry No." THEN
            ItemReg."To Capacity Entry No." := CapLedgEntryNo;

          ItemReg.MODIFY;
        END;
      END;
    END;

    LOCAL PROCEDURE InsertPhysInventoryEntry@8();
    VAR
      PhysInvtLedgEntry@1000 : Record 281;
    BEGIN
      WITH ItemJnlLineOrigin DO BEGIN

        IF PhysInvtEntryNo = 0 THEN BEGIN
          PhysInvtLedgEntry.LOCKTABLE;
          IF PhysInvtLedgEntry.FINDLAST THEN
            PhysInvtEntryNo := PhysInvtLedgEntry."Entry No.";
        END;

        PhysInvtEntryNo := PhysInvtEntryNo + 1;

        PhysInvtLedgEntry.INIT;
        PhysInvtLedgEntry."Entry No." := PhysInvtEntryNo;
        PhysInvtLedgEntry."Item No." := "Item No.";
        PhysInvtLedgEntry."Posting Date" := "Posting Date";
        PhysInvtLedgEntry."Document Date" := "Document Date";
        PhysInvtLedgEntry."Entry Type" := "Entry Type";
        PhysInvtLedgEntry."Document No." := "Document No.";
        PhysInvtLedgEntry."External Document No." := "External Document No.";
        PhysInvtLedgEntry.Description := Description;
        PhysInvtLedgEntry."Location Code" := "Location Code";
        PhysInvtLedgEntry."Inventory Posting Group" := "Inventory Posting Group";
        PhysInvtLedgEntry."Unit Cost" := "Unit Cost";
        PhysInvtLedgEntry.Amount := Amount;
        PhysInvtLedgEntry."Salespers./Purch. Code" := "Salespers./Purch. Code";
        PhysInvtLedgEntry."Source Code" := "Source Code";
        PhysInvtLedgEntry."Global Dimension 1 Code" := "Shortcut Dimension 1 Code";
        PhysInvtLedgEntry."Global Dimension 2 Code" := "Shortcut Dimension 2 Code";
        PhysInvtLedgEntry."Journal Batch Name" := "Journal Batch Name";
        PhysInvtLedgEntry."Reason Code" := "Reason Code";
        PhysInvtLedgEntry."User ID" := USERID;
        PhysInvtLedgEntry."No. Series" := "Posting No. Series";
        IF PhysInvtLedgEntry.Description = Item.Description THEN
          PhysInvtLedgEntry.Description := '';
        PhysInvtLedgEntry."Variant Code" := "Variant Code";
        PhysInvtLedgEntry."Unit of Measure Code" := "Unit of Measure Code";

        PhysInvtLedgEntry.Quantity := Quantity;
        PhysInvtLedgEntry."Unit Amount" := "Unit Amount";
        PhysInvtLedgEntry."Qty. (Calculated)" := "Qty. (Calculated)";
        PhysInvtLedgEntry."Qty. (Phys. Inventory)" := "Qty. (Phys. Inventory)";
        PhysInvtLedgEntry."Last Item Ledger Entry No." := "Last Item Ledger Entry No.";

        PhysInvtLedgEntry."Phys Invt Counting Period Code" :=
          "Phys Invt Counting Period Code";
        PhysInvtLedgEntry."Phys Invt Counting Period Type" :=
          "Phys Invt Counting Period Type";

        PhysInvtLedgEntry.INSERT;

        DimMgt.MoveJnlLineDimToLedgEntryDim(
          TempJnlLineDim,DATABASE::"Phys. Inventory Ledger Entry",PhysInvtLedgEntry."Entry No.");
        InsertItemReg(0,PhysInvtLedgEntry."Entry No.",0,0);
      END;
    END;

    LOCAL PROCEDURE PostInventoryToGL@11(VAR ValueEntry@1000 : Record 5802);
    BEGIN
      WITH ValueEntry DO BEGIN
        IF CalledFromAdjustment AND NOT PostToGL THEN
          EXIT;
        InvtPost.SetRunOnlyCheck(TRUE,NOT PostToGL,FALSE);
        IF InvtPost.BufferInvtPosting(ValueEntry) THEN
          InvtPost.PostInvtPostBufPerEntry(ValueEntry);

        IF "Expected Cost" THEN BEGIN
          SetValueEntry(ValueEntry,"Cost Amount (Expected)","Cost Amount (Expected) (ACY)",FALSE);
          InvtPost.SetRunOnlyCheck(TRUE,TRUE,FALSE);
          IF InvtPost.BufferInvtPosting(ValueEntry) THEN
            InvtPost.PostInvtPostBufPerEntry(ValueEntry);
          SetValueEntry(ValueEntry,0,0,TRUE);
        END;
      END;
    END;

    LOCAL PROCEDURE SetValueEntry@65(VAR ValueEntry@1000 : Record 5802;CostAmtActual@1001 : Decimal;CostAmtActACY@1002 : Decimal;ExpectedCost@1003 : Boolean);
    BEGIN
      ValueEntry."Cost Amount (Actual)" := CostAmtActual;
      ValueEntry."Cost Amount (Actual) (ACY)" := CostAmtActACY;
      ValueEntry."Expected Cost" := ExpectedCost;
    END;

    LOCAL PROCEDURE InsertApplEntry@12(ItemLedgEntryNo@1001 : Integer;InboundItemEntry@1002 : Integer;OutboundItemEntry@1003 : Integer;TransferedFromEntryNo@1004 : Integer;PostingDate@1005 : Date;Quantity@1006 : Decimal;CostToApply@1007 : Boolean);
    VAR
      ApplItemLedgEntry@1009 : Record 32;
      OldItemApplnEntry@1008 : Record 339;
      ItemApplnEntryExists@1000 : Boolean;
      ItemApplHistoryEntry@1010 : Record 343;
    BEGIN
      IF ItemApplnEntryNo = 0 THEN BEGIN
        ItemApplnEntry.RESET;
        ItemApplnEntry.LOCKTABLE;
        IF ItemApplnEntry.FINDLAST THEN
        BEGIN
          ItemApplnEntryNo := ItemApplnEntry."Entry No.";
          ItemApplHistoryEntry.RESET;
          ItemApplHistoryEntry.LOCKTABLE;
          ItemApplHistoryEntry.SETCURRENTKEY("Entry No.");
          IF ItemApplHistoryEntry.FINDLAST THEN
             IF ItemApplHistoryEntry."Entry No." > ItemApplnEntryNo THEN
               ItemApplnEntryNo := ItemApplHistoryEntry."Entry No.";
        END
        ELSE
          ItemApplnEntryNo := 0;
      END;

      IF Quantity < 0 THEN BEGIN
        OldItemApplnEntry.SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.","Outbound Item Entry No.");
        OldItemApplnEntry.SETRANGE("Inbound Item Entry No.",InboundItemEntry);
        OldItemApplnEntry.SETRANGE("Item Ledger Entry No.",ItemLedgEntryNo);
        OldItemApplnEntry.SETRANGE("Outbound Item Entry No.",OutboundItemEntry);
        IF OldItemApplnEntry.FINDSET THEN BEGIN
          ItemApplnEntry := OldItemApplnEntry;
          ItemApplnEntry.Quantity := ItemApplnEntry.Quantity + Quantity;
          ItemApplnEntry."Last Modified Date" := CURRENTDATETIME;
          ItemApplnEntry."Last Modified By User" := USERID();
          ItemApplnEntry.MODIFY;
          ItemApplnEntryExists := TRUE;
        END;
      END;

      IF NOT ItemApplnEntryExists THEN BEGIN
        ItemApplnEntryNo := ItemApplnEntryNo + 1;
        ItemApplnEntry.INIT;
        ItemApplnEntry."Entry No." := ItemApplnEntryNo;
        ItemApplnEntry."Item Ledger Entry No." := ItemLedgEntryNo;
        ItemApplnEntry."Inbound Item Entry No." := InboundItemEntry;
        ItemApplnEntry."Outbound Item Entry No." := OutboundItemEntry;
        ItemApplnEntry."Transferred-from Entry No." := TransferedFromEntryNo;
        ItemApplnEntry.Quantity := Quantity;
        ItemApplnEntry."Posting Date" := PostingDate;
        ItemApplnEntry."Output Completely Invd. Date" := GetOutputComplInvcdDate(ItemApplnEntry);

        IF AverageTransfer THEN BEGIN
          IF Quantity > 0 THEN
            ItemApplnEntry."Cost Application" := TRUE;
        END ELSE
          CASE TRUE OF
            Item."Costing Method" <> Item."Costing Method"::Average:
              ItemApplnEntry."Cost Application" := TRUE;
            ItemJnlLine.Correction:
              BEGIN
                ApplItemLedgEntry.GET(ItemApplnEntry."Item Ledger Entry No.");
                ItemApplnEntry."Cost Application" :=
                  (ApplItemLedgEntry.Quantity > 0) OR (ApplItemLedgEntry."Applies-to Entry" <> 0);
              END;
            ELSE
              IF (ItemJnlLine."Applies-to Entry" <> 0) OR
                 (CostToApply AND ItemJnlLine.IsInbound)
              THEN
                ItemApplnEntry."Cost Application" := TRUE;
          END;

        ItemApplnEntry."Creation Date" := CURRENTDATETIME;
        ItemApplnEntry."Created By User" := USERID();
        ItemApplnEntry.INSERT;
      END;
    END;

    PROCEDURE UpdateItemApplnEntry@42(ItemLedgEntryNo@1000 : Integer;PostingDate@1002 : Date);
    VAR
      ItemApplnEntry@1001 : Record 339;
    BEGIN
      WITH ItemApplnEntry DO BEGIN
        IF NOT RECORDLEVELLOCKING THEN
          SETCURRENTKEY("Item Ledger Entry No.","Output Completely Invd. Date");
        SETRANGE("Item Ledger Entry No.",ItemLedgEntryNo);
        SETRANGE("Output Completely Invd. Date",0D);
        IF NOT ISEMPTY THEN
          MODIFYALL("Output Completely Invd. Date",PostingDate);
      END;
    END;

    LOCAL PROCEDURE GetOutputComplInvcdDate@57(ItemApplnEntry@1000 : Record 339) : Date;
    VAR
      OutbndItemLedgEntry@1001 : Record 32;
    BEGIN
      WITH ItemApplnEntry DO
        IF (Quantity > 0) THEN
          EXIT("Posting Date")
        ELSE
          IF OutbndItemLedgEntry.GET("Outbound Item Entry No.") THEN
            IF OutbndItemLedgEntry."Completely Invoiced" THEN
              EXIT(OutbndItemLedgEntry."Last Invoice Date");
    END;

    LOCAL PROCEDURE InitValueEntry@5800(VAR ValueEntry@1000 : Record 5802;ItemLedgEntry@1001 : Record 32);
    VAR
      CalcUnitCost@1003 : Boolean;
      CostAmt@1004 : Decimal;
      CostAmtACY@1005 : Decimal;
    BEGIN
      ValueEntryNo := ValueEntryNo + 1;

      WITH ItemJnlLine DO BEGIN
        ValueEntry.INIT;
        ValueEntry."Entry No." := ValueEntryNo;
        IF "Value Entry Type" = "Value Entry Type"::Variance THEN
          ValueEntry."Variance Type" := "Variance Type";
        ValueEntry."Item Ledger Entry No." := ItemLedgEntry."Entry No.";
        ValueEntry."Item No." := "Item No.";
        ValueEntry."Item Charge No." := "Item Charge No.";
        ValueEntry."Prod. Order No." := ItemLedgEntry."Prod. Order No.";
        ValueEntry."Prod. Order Line No." := ItemLedgEntry."Prod. Order Line No.";
        ValueEntry."Item Ledger Entry Type" := "Entry Type";
        ValueEntry."Posting Date" := "Posting Date";
        IF "Partial Revaluation" THEN
          ValueEntry."Partial Revaluation" := TRUE;

        IF (ItemLedgEntry.Quantity > 0) OR
           (ItemLedgEntry."Invoiced Quantity" > 0) OR
           (("Value Entry Type" = "Value Entry Type"::"Direct Cost") AND ("Item Charge No." = '')) OR
           ("Entry Type" = "Entry Type"::Output) OR
           Adjustment
        THEN
          ValueEntry.Inventoriable := TRUE;

        IF ((Quantity = 0) AND ("Invoiced Quantity" <> 0)) OR
           ("Value Entry Type" <> "Value Entry Type"::"Direct Cost") OR
           ("Item Charge No." <> '') OR Adjustment
        THEN BEGIN
          GetLastDirectCostValEntry(ValueEntry."Item Ledger Entry No.");
          IF ValueEntry.Inventoriable AND ("Item Charge No." = '') THEN
            ValueEntry."Valued By Average Cost" := DirCostValueEntry."Valued By Average Cost";
        END;

        CASE TRUE OF
          ((Quantity = 0) AND ("Invoiced Quantity" <> 0)) OR
          (("Value Entry Type" = "Value Entry Type"::"Direct Cost") AND ("Item Charge No." <> '')) OR
          Adjustment OR ("Value Entry Type" = "Value Entry Type"::Rounding):
            ValueEntry."Valuation Date" := DirCostValueEntry."Valuation Date";
          ("Value Entry Type" = "Value Entry Type"::Revaluation):
            IF "Posting Date" < DirCostValueEntry."Valuation Date" THEN
              ValueEntry."Valuation Date" := DirCostValueEntry."Valuation Date"
            ELSE
              ValueEntry."Valuation Date" := "Posting Date";
          (ItemLedgEntry.Quantity > 0) AND ("Applies-from Entry" <> 0):
            GetAppliedFromValues(ValueEntry);
          ELSE
            ValueEntry."Valuation Date" := "Posting Date";
        END;

        IF Description = Item.Description THEN
          ValueEntry.Description := ''
        ELSE
          ValueEntry.Description := Description;
        ValueEntry."Source Code" := "Source Code";
        ValueEntry."Source Type" := "Source Type";
        ValueEntry."Source No." := GetSourceNo(ItemJnlLine);
        IF ("Value Entry Type" = "Value Entry Type"::"Direct Cost") AND ("Item Charge No." = '') THEN
          ValueEntry."Inventory Posting Group" := "Inventory Posting Group"
        ELSE
          ValueEntry."Inventory Posting Group" := DirCostValueEntry."Inventory Posting Group";
        ValueEntry."Source Posting Group" := "Source Posting Group";
        ValueEntry."Salespers./Purch. Code" := "Salespers./Purch. Code";
        ValueEntry."Location Code" := ItemLedgEntry."Location Code";
        ValueEntry."Variant Code" := ItemLedgEntry."Variant Code";
        ValueEntry."Journal Batch Name" := "Journal Batch Name";
        ValueEntry."User ID" := USERID;
        ValueEntry."Drop Shipment" := "Drop Shipment";
        ValueEntry."Reason Code" := "Reason Code";
        ValueEntry."Return Reason Code" := "Return Reason Code";
        ValueEntry."External Document No." := "External Document No.";
        ValueEntry."Document Date" := "Document Date";
        ValueEntry."Gen. Bus. Posting Group" := "Gen. Bus. Posting Group";
        ValueEntry."Gen. Prod. Posting Group" := "Gen. Prod. Posting Group";
        ValueEntry."Discount Amount" := "Discount Amount";
        ValueEntry."Entry Type" := "Value Entry Type";
        IF "Job No." <> '' THEN BEGIN
          ValueEntry."Job No." := "Job No.";
          ValueEntry."Job Task No." := "Job Task No.";
        END;
        IF "Invoiced Quantity" <> 0 THEN BEGIN
          ValueEntry."Valued Quantity" := "Invoiced Quantity";
          IF ("Value Entry Type" = "Value Entry Type"::"Direct Cost") AND
             ("Item Charge No." = '')
          THEN
            IF ("Entry Type" <> "Entry Type"::Output) OR
               (ItemLedgEntry."Invoiced Quantity" = 0)
            THEN
              ValueEntry."Invoiced Quantity" := "Invoiced Quantity";
          ValueEntry."Expected Cost" := FALSE;
        END ELSE BEGIN
          ValueEntry."Valued Quantity" := Quantity;
          ValueEntry."Expected Cost" := "Value Entry Type" <> "Value Entry Type"::Revaluation;
        END;

        ValueEntry."Document Type" := "Document Type";
        IF (ValueEntry."Expected Cost") OR ("Invoice No." = '') THEN
          ValueEntry."Document No." := "Document No."
        ELSE BEGIN
          ValueEntry."Document No." := "Invoice No.";
          IF "Document Type" IN [
            "Document Type"::"Purchase Receipt","Document Type"::"Purchase Return Shipment",
            "Document Type"::"Sales Shipment","Document Type"::"Sales Return Receipt",
            "Document Type"::"Service Shipment"]
          THEN
            ValueEntry."Document Type" := "Document Type" + 1;
        END;
        ValueEntry."Document Line No." := "Document Line No.";

        IF Adjustment THEN BEGIN
          ValueEntry."Invoiced Quantity" := 0;
          ValueEntry."Applies-to Entry" := "Applies-to Value Entry";
          ValueEntry.Adjustment := TRUE;
        END;

        IF "Value Entry Type" <> "Value Entry Type"::Rounding THEN BEGIN
          IF ("Entry Type" = "Entry Type"::Output) AND
             ("Value Entry Type" <> "Value Entry Type"::Revaluation)
          THEN BEGIN
            CostAmt := Amount;
            CostAmtACY := "Amount (ACY)";
          END ELSE BEGIN
            ValueEntry."Cost per Unit" := RetrieveCostPerUnit;
            IF GLSetup."Additional Reporting Currency" <> '' THEN
              ValueEntry."Cost per Unit (ACY)" := RetrieveCostPerUnitACY(ValueEntry."Cost per Unit");

            IF (ValueEntry."Valued Quantity" > 0) AND
               (ValueEntry."Item Ledger Entry Type" = ValueEntry."Item Ledger Entry Type"::Purchase) AND
               (ValueEntry."Entry Type" = ValueEntry."Entry Type"::"Direct Cost")
            THEN BEGIN
              IF Item."Costing Method" = Item."Costing Method"::Standard THEN
                "Unit Cost" := ValueEntry."Cost per Unit";
              CalcPosShares(
                CostAmt,OverheadAmount,VarianceAmount,CostAmtACY,OverheadAmountACY,VarianceAmountACY,
                CalcUnitCost,(Item."Costing Method" = Item."Costing Method"::Standard) AND
                (NOT ValueEntry."Expected Cost"),ValueEntry."Expected Cost");
              IF (OverheadAmount <> 0) OR
                 (ROUND(VarianceAmount,GLSetup."Amount Rounding Precision") <> 0) OR
                 CalcUnitCost OR ValueEntry."Expected Cost"
              THEN BEGIN
                ValueEntry."Cost per Unit" :=
                  CalcCostPerUnit(CostAmt,ValueEntry."Valued Quantity",FALSE);

                IF GLSetup."Additional Reporting Currency" <> '' THEN
                  ValueEntry."Cost per Unit (ACY)" :=
                    CalcCostPerUnit(CostAmtACY,ValueEntry."Valued Quantity",TRUE);
              END;
            END ELSE BEGIN
              IF NOT Adjustment AND ("Item Charge No." = '') THEN BEGIN
                CostAmt :=
                  ValueEntry."Cost per Unit" * ValueEntry."Valued Quantity";
                CostAmtACY :=
                  ValueEntry."Cost per Unit (ACY)" * ValueEntry."Valued Quantity";
              END ELSE BEGIN
                CostAmt := Amount;
                CostAmtACY := "Amount (ACY)";
              END
            END;
            IF ("Invoiced Quantity" < 0) AND ("Applies-to Entry" <> 0) AND
               ("Entry Type" = "Entry Type"::Purchase) AND ("Item Charge No." = '') AND
               (ValueEntry."Entry Type" = ValueEntry."Entry Type"::"Direct Cost")
            THEN
              CalcPurchCorrShares(OverheadAmount,OverheadAmountACY,VarianceAmount,VarianceAmountACY);
          END
        END ELSE BEGIN
          CostAmt := "Unit Cost";
          CostAmtACY := "Unit Cost (ACY)";
        END;

        IF (ValueEntry."Entry Type" <> ValueEntry."Entry Type"::Revaluation) AND NOT Adjustment THEN
          IF (ValueEntry."Item Ledger Entry Type" IN
              [ValueEntry."Item Ledger Entry Type"::Sale,
               ValueEntry."Item Ledger Entry Type"::"Negative Adjmt.",
               ValueEntry."Item Ledger Entry Type"::Consumption]) OR
             ((ValueEntry."Item Ledger Entry Type" = ValueEntry."Item Ledger Entry Type"::Transfer) AND
              ("Value Entry Type" = "Value Entry Type"::"Direct Cost") AND ("Item Charge No." = ''))
          THEN BEGIN
            ValueEntry."Valued Quantity" := -ValueEntry."Valued Quantity";
            ValueEntry."Invoiced Quantity" := -ValueEntry."Invoiced Quantity";
            IF ValueEntry."Item Ledger Entry Type" = ValueEntry."Item Ledger Entry Type"::Transfer THEN
              ValueEntry."Discount Amount" := 0
            ELSE
              ValueEntry."Discount Amount" := -ValueEntry."Discount Amount";

            IF "Value Entry Type" <> "Value Entry Type"::Rounding THEN BEGIN
              CostAmt := -CostAmt;
              CostAmtACY := -CostAmtACY;
            END;
          END;

        IF NOT Adjustment THEN
          IF (Item."Inventory Value Zero") OR
             (("Entry Type" = "Entry Type"::Transfer) AND
              (ValueEntry."Valued Quantity" < 0) AND NOT AverageTransfer) OR
             (("Entry Type" = "Entry Type"::Sale) AND
              ("Item Charge No." <> ''))
          THEN BEGIN
            CostAmt := 0;
            CostAmtACY := 0;
            ValueEntry."Cost per Unit" := 0;
            ValueEntry."Cost per Unit (ACY)" := 0;
          END;

        CASE TRUE OF
          (ValueEntry."Expected Cost" = FALSE) AND (ValueEntry.Inventoriable = TRUE) AND
          IsInterimRevaluation:
            BEGIN
              ValueEntry."Cost Amount (Expected)" := ROUND(CostAmt * "Applied Amount" / Amount);
              ValueEntry."Cost Amount (Expected) (ACY)" := ROUND(CostAmtACY * "Applied Amount" / Amount,
                Currency."Amount Rounding Precision");

              CostAmt := ROUND(CostAmt);
              CostAmtACY := ROUND(CostAmtACY,Currency."Amount Rounding Precision");
              ValueEntry."Cost Amount (Actual)" := CostAmt - ValueEntry."Cost Amount (Expected)" ;
              ValueEntry."Cost Amount (Actual) (ACY)" := CostAmtACY - ValueEntry."Cost Amount (Expected) (ACY)";
            END;
          (ValueEntry."Expected Cost" = FALSE) AND (ValueEntry.Inventoriable = TRUE):
            BEGIN
              IF NOT Adjustment AND ("Value Entry Type" = "Value Entry Type"::"Direct Cost") THEN
                CASE "Entry Type" OF
                  "Entry Type"::Sale:
                    ValueEntry."Sales Amount (Actual)" := Amount;
                  "Entry Type"::Purchase:
                    ValueEntry."Purchase Amount (Actual)" := Amount;
                END;
              ValueEntry."Cost Amount (Actual)" := CostAmt;
              ValueEntry."Cost Amount (Actual) (ACY)" := CostAmtACY;

              IF (GLSetup."Payment Discount Type" = GLSetup."Payment Discount Type"::"Calc. Pmt. Disc. on Lines") THEN
                //END;
                IF (ValueEntry."Discount Amount" <> 0) AND (ItemJnlLine."Item Charge No." = '') THEN BEGIN
                  ValueEntry."Cost Amount (Actual)" := ValueEntry."Cost Amount (Actual)" + ItemJnlLine."Pmt. Discount Amount";
                  ValueEntry."Purchase Amount (Actual)" := ValueEntry."Purchase Amount (Actual)" + ItemJnlLine."Pmt. Discount Amount";
                END;
            END;
          (ValueEntry."Expected Cost" = TRUE) AND (ValueEntry.Inventoriable = TRUE):
            BEGIN
              IF NOT Adjustment THEN
                CASE "Entry Type" OF
                  "Entry Type"::Sale:
                    ValueEntry."Sales Amount (Expected)" := Amount;
                  "Entry Type"::Purchase:
                      ValueEntry."Purchase Amount (Expected)" := Amount;
                END;
              ValueEntry."Cost Amount (Expected)" := CostAmt;
              ValueEntry."Cost Amount (Expected) (ACY)" := CostAmtACY;
            END;
          (ValueEntry."Expected Cost" = FALSE) AND (ValueEntry.Inventoriable = FALSE):
            BEGIN
              IF "Entry Type" = "Entry Type"::Sale THEN BEGIN
                ValueEntry."Sales Amount (Actual)" := Amount;
                ValueEntry."Cost per Unit" := 0;
                ValueEntry."Cost per Unit (ACY)" := 0;
              END ELSE BEGIN
                IF "Entry Type" = "Entry Type"::Purchase THEN
                  ValueEntry."Purchase Amount (Actual)" := Amount;
                ValueEntry."Cost Amount (Non-Invtbl.)" := CostAmt;
                ValueEntry."Cost Amount (Non-Invtbl.)(ACY)" := CostAmtACY;
              END;
            END;
        END;

        RoundAmtValueEntry(ValueEntry);

      END;
    END;

    LOCAL PROCEDURE InsertValueEntry@5801(VAR ValueEntry@1000 : Record 5802;VAR ItemLedgEntry@1001 : Record 32;TransferItem@1002 : Boolean);
    VAR
      LedgEntryDim@1003 : Record 355;
      InvdValueEntry@1005 : Record 5802;
      InvoicedQty@1004 : Decimal;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF TransferItem THEN BEGIN
          ValueEntry."Global Dimension 1 Code" := "New Shortcut Dimension 1 Code";
          ValueEntry."Global Dimension 2 Code" := "New Shortcut Dimension 2 Code";
          IF TempJnlLineDim.FINDSET THEN BEGIN
            REPEAT
              IF TempJnlLineDim."New Dimension Value Code" <> '' THEN BEGIN
                LedgEntryDim.INIT;
                LedgEntryDim."Table ID" := DATABASE::"Value Entry";
                LedgEntryDim."Entry No." := ValueEntry."Entry No.";
                LedgEntryDim."Dimension Code" := TempJnlLineDim."Dimension Code";
                LedgEntryDim."Dimension Value Code" := TempJnlLineDim."New Dimension Value Code";
                LedgEntryDim.INSERT;
              END;
            UNTIL TempJnlLineDim.NEXT = 0;
          END;
        END ELSE BEGIN
          IF (GlobalValueEntry."Entry Type" = GlobalValueEntry."Entry Type"::"Direct Cost") AND
             (GlobalValueEntry."Item Charge No." <> '') AND
             (ValueEntry."Entry Type" = ValueEntry."Entry Type"::Variance)
          THEN BEGIN
            GetLastDirectCostValEntry(ValueEntry."Item Ledger Entry No.");
            ValueEntry."Gen. Prod. Posting Group" := DirCostValueEntry."Gen. Prod. Posting Group";
            MoveValEntryDimToValEntryDim(ValueEntry,DirCostValueEntry);
          END ELSE BEGIN
            ValueEntry."Global Dimension 1 Code" := "Shortcut Dimension 1 Code";
            ValueEntry."Global Dimension 2 Code" := "Shortcut Dimension 2 Code";
            DimMgt.MoveJnlLineDimToLedgEntryDim(
              TempJnlLineDim,DATABASE::"Value Entry",ValueEntry."Entry No.");
          END;
        END;
        RoundAmtValueEntry(ValueEntry);

        IF ValueEntry."Entry Type" = ValueEntry."Entry Type"::Rounding THEN BEGIN
          ValueEntry."Valued Quantity" := ItemLedgEntry.Quantity;
          ValueEntry."Invoiced Quantity" := 0;
          ValueEntry."Cost per Unit" := 0;
          ValueEntry."Sales Amount (Actual)" := 0;
          ValueEntry."Purchase Amount (Actual)" := 0;
          ValueEntry."Cost per Unit (ACY)" := 0;
          ValueEntry."Item Ledger Entry Quantity" := 0;
        END ELSE BEGIN
          IF IsFirstValueEntry(ValueEntry."Item Ledger Entry No.") THEN
            ValueEntry."Item Ledger Entry Quantity" := ValueEntry."Valued Quantity"
          ELSE
            ValueEntry."Item Ledger Entry Quantity" := 0;
          IF ValueEntry."Cost per Unit" = 0 THEN BEGIN
            ValueEntry."Cost per Unit" :=
              CalcCostPerUnit(ValueEntry."Cost Amount (Actual)",ValueEntry."Valued Quantity",FALSE);
            ValueEntry."Cost per Unit (ACY)" :=
              CalcCostPerUnit(ValueEntry."Cost Amount (Actual) (ACY)",ValueEntry."Valued Quantity",TRUE);
          END ELSE BEGIN
            ValueEntry."Cost per Unit" := ROUND(
              ValueEntry."Cost per Unit",GLSetup."Unit-Amount Rounding Precision");
            ValueEntry."Cost per Unit (ACY)" := ROUND(
              ValueEntry."Cost per Unit (ACY)",Currency."Unit-Amount Rounding Precision");
            IF ("Source Currency Code" = GLSetup."Additional Reporting Currency") THEN
              IF ValueEntry."Expected Cost" THEN
                ValueEntry."Cost per Unit" :=
                  CalcCostPerUnit(ValueEntry."Cost Amount (Expected)",ValueEntry."Valued Quantity",FALSE)
              ELSE
                IF ValueEntry."Entry Type" = ValueEntry."Entry Type"::Revaluation THEN
                  ValueEntry."Cost per Unit" :=
                    CalcCostPerUnit(ValueEntry."Cost Amount (Actual)" + ValueEntry."Cost Amount (Expected)",
                      ValueEntry."Valued Quantity",FALSE)
                ELSE
                  ValueEntry."Cost per Unit" :=
                    CalcCostPerUnit(ValueEntry."Cost Amount (Actual)",ValueEntry."Valued Quantity",FALSE);
          END;
          IF UpdateItemLedgEntry(ValueEntry,ItemLedgEntry) THEN
            ItemLedgEntry.MODIFY;
        END;

        IF ((ValueEntry."Entry Type" = ValueEntry."Entry Type"::"Direct Cost") AND
            (ValueEntry."Item Charge No." = '')) AND
           (((Quantity = 0) AND ("Invoiced Quantity" <> 0)) OR
            (Adjustment AND NOT ValueEntry."Expected Cost"))
        THEN BEGIN
          IF ValueEntry."Invoiced Quantity" = 0 THEN BEGIN
            IF InvdValueEntry.GET(ValueEntry."Applies-to Entry") THEN
              InvoicedQty := InvdValueEntry."Invoiced Quantity"
            ELSE
              InvoicedQty := ValueEntry."Valued Quantity";
          END ELSE
            InvoicedQty := ValueEntry."Invoiced Quantity";
          CalcExpectedCost(
            ItemLedgEntry."Entry No.",
            InvoicedQty,
            ItemLedgEntry.Quantity,
            ValueEntry."Cost Amount (Expected)",
            ValueEntry."Cost Amount (Expected) (ACY)",
            ValueEntry."Sales Amount (Expected)",
            ValueEntry."Purchase Amount (Expected)",
            ItemLedgEntry.Quantity = ItemLedgEntry."Invoiced Quantity");

          IF (InvdValueEntry."Cost Amount (Expected)" <> 0) AND (ValueEntry."Cost Amount (Expected)" <> 0) THEN
            ValueEntry."Cost Amount (Expected)" :=
             ValueEntry."Cost Amount (Expected)" - InvdValueEntry."Cost Amount (Expected)";
          IF (InvdValueEntry."Cost Amount (Expected) (ACY)" <> 0) AND (ValueEntry."Cost Amount (Expected) (ACY)" <> 0) THEN
            ValueEntry."Cost Amount (Expected) (ACY)" :=
              ValueEntry."Cost Amount (Expected) (ACY)" - InvdValueEntry."Cost Amount (Expected) (ACY)";
        END;

        IF ValueEntry.Inventoriable THEN
          PostInventoryToGL(ValueEntry);

        ValueEntry.INSERT;

        UpdateAdjmtProp(ValueEntry,ItemLedgEntry."Posting Date");

        InsertItemReg(0,0,ValueEntry."Entry No.",0);
        InsertPostValueEntryToGL(ValueEntry);
        IF Item."Item Tracking Code" <> '' THEN BEGIN
          TempValueEntryRelation.INIT;
          TempValueEntryRelation."Value Entry No." := ValueEntry."Entry No.";
          TempValueEntryRelation.INSERT;
        END;
      END;
    END;

    LOCAL PROCEDURE InsertOHValueEntry@5812(ValueEntry@1000 : Record 5802;OverheadAmount@1001 : Decimal;OverheadAmountACY@1002 : Decimal);
    BEGIN
      IF Item."Inventory Value Zero" THEN
        EXIT;

      ValueEntryNo := ValueEntryNo + 1;

      ValueEntry."Entry No." := ValueEntryNo;
      ValueEntry."Item Charge No." := '';
      ValueEntry."Entry Type" := ValueEntry."Entry Type"::"Indirect Cost";
      ValueEntry.Description := '';
      ValueEntry."Cost per Unit" := 0;
      ValueEntry."Cost per Unit (ACY)" := 0;
      ValueEntry."Cost Posted to G/L" := 0;
      ValueEntry."Cost Posted to G/L (ACY)" := 0;
      ValueEntry."Invoiced Quantity" := 0;
      ValueEntry."Sales Amount (Actual)" := 0;
      ValueEntry."Sales Amount (Expected)" := 0;
      ValueEntry."Purchase Amount (Actual)" := 0;
      ValueEntry."Purchase Amount (Expected)" := 0;
      ValueEntry."Discount Amount" := 0;
      ValueEntry."Cost Amount (Actual)" := OverheadAmount;
      ValueEntry."Cost Amount (Expected)" := 0;
      ValueEntry."Cost Amount (Expected) (ACY)" := 0;

      IF GLSetup."Additional Reporting Currency" <> '' THEN
        ValueEntry."Cost Amount (Actual) (ACY)" :=
          ROUND(OverheadAmountACY,Currency."Amount Rounding Precision");

      InsertValueEntry(ValueEntry,GlobalItemLedgEntry,FALSE);
    END;

    LOCAL PROCEDURE InsertVarValueEntry@5808(ValueEntry@1000 : Record 5802;VarianceAmount@1001 : Decimal;VarianceAmountACY@1002 : Decimal);
    BEGIN
      IF (NOT ValueEntry.Inventoriable) OR Item."Inventory Value Zero" THEN
        EXIT;
      IF (VarianceAmount = 0) AND (VarianceAmountACY = 0) THEN
        EXIT;

      ValueEntryNo := ValueEntryNo + 1;

      ValueEntry."Entry No." := ValueEntryNo;
      ValueEntry."Item Charge No." := '';
      ValueEntry."Entry Type" := ValueEntry."Entry Type"::Variance;
      ValueEntry.Description := '';
      ValueEntry."Cost Posted to G/L" := 0;
      ValueEntry."Cost Posted to G/L (ACY)" := 0;
      ValueEntry."Invoiced Quantity" := 0;
      ValueEntry."Sales Amount (Actual)" := 0;
      ValueEntry."Sales Amount (Expected)" := 0;
      ValueEntry."Purchase Amount (Actual)" := 0;
      ValueEntry."Purchase Amount (Expected)" := 0;
      ValueEntry."Discount Amount" := 0;
      ValueEntry."Cost Amount (Actual)" := VarianceAmount;
      ValueEntry."Cost Amount (Expected)" := 0;
      ValueEntry."Cost Amount (Expected) (ACY)" := 0;
      ValueEntry."Variance Type" := ValueEntry."Variance Type"::Purchase;

      IF GLSetup."Additional Reporting Currency" <> '' THEN BEGIN
        IF ROUND(VarianceAmount,GLSetup."Amount Rounding Precision") =
           ROUND(-GlobalValueEntry."Cost Amount (Actual)",GLSetup."Amount Rounding Precision")
        THEN
          ValueEntry."Cost Amount (Actual) (ACY)" := -GlobalValueEntry."Cost Amount (Actual) (ACY)"
        ELSE
          ValueEntry."Cost Amount (Actual) (ACY)" :=
            ROUND(VarianceAmountACY,Currency."Amount Rounding Precision");
      END;

      ValueEntry."Cost per Unit" :=
        CalcCostPerUnit(ValueEntry."Cost Amount (Actual)",ValueEntry."Valued Quantity",FALSE);
      ValueEntry."Cost per Unit (ACY)" :=
        CalcCostPerUnit(ValueEntry."Cost Amount (Actual) (ACY)",ValueEntry."Valued Quantity",TRUE);

      InsertValueEntry(ValueEntry,GlobalItemLedgEntry,FALSE);
    END;

    LOCAL PROCEDURE UpdateItemLedgEntry@5805(ValueEntry@1000 : Record 5802;VAR ItemLedgEntry@1001 : Record 32) ModifyEntry : Boolean;
    BEGIN
      WITH ItemLedgEntry DO BEGIN
        IF NOT (ValueEntry."Entry Type" IN
                [ValueEntry."Entry Type"::Variance,
                 ValueEntry."Entry Type"::"Indirect Cost",
                 ValueEntry."Entry Type"::Rounding])
        THEN BEGIN
          IF ValueEntry.Inventoriable AND NOT ItemJnlLine.Adjustment THEN
            UpdateAvgCostAdjmtEntryPoint(ItemLedgEntry,ValueEntry."Valuation Date");

          IF Positive AND (Quantity <> "Remaining Quantity") AND NOT "Applied Entry to Adjust" THEN BEGIN
            "Applied Entry to Adjust" := TRUE;
            ModifyEntry := TRUE;
          END;

          IF (ValueEntry."Entry Type" = ValueEntry."Entry Type"::"Direct Cost") AND
             (ItemJnlLine."Item Charge No." = '') AND
             (ItemJnlLine.Quantity = 0) AND (ValueEntry."Invoiced Quantity" <> 0)
          THEN BEGIN
            IF ValueEntry."Invoiced Quantity" <> 0 THEN BEGIN
              "Invoiced Quantity" := "Invoiced Quantity" + ValueEntry."Invoiced Quantity";
              ModifyEntry := TRUE;
            END;

            IF ("Entry Type" <> "Entry Type"::Output) AND
               ("Invoiced Quantity" = Quantity) AND
               NOT "Completely Invoiced"
            THEN BEGIN
              "Completely Invoiced" := TRUE;
              ModifyEntry := TRUE;
            END;

            IF "Last Invoice Date" < ValueEntry."Posting Date" THEN BEGIN
              "Last Invoice Date" := ValueEntry."Posting Date";
              ModifyEntry := TRUE;
            END;
          END;
          IF ItemJnlLine."Applies-from Entry" <> 0 THEN
            UpdateOutboundItemLedgEntry(ItemJnlLine."Applies-from Entry");
        END;
      END;

      EXIT(ModifyEntry);
    END;

    LOCAL PROCEDURE UpdateAvgCostAdjmtEntryPoint@5820(OldItemLedgEntry@1000 : Record 32;ValuationDate@1001 : Date);
    VAR
      AvgCostAdjmtEntryPoint@1002 : Record 5804;
      ValueEntry@1004 : Record 5802;
    BEGIN
      WITH AvgCostAdjmtEntryPoint DO BEGIN
        ValueEntry."Item No." := OldItemLedgEntry."Item No.";
        ValueEntry."Valuation Date" := ValuationDate;
        ValueEntry."Location Code" := OldItemLedgEntry."Location Code";
        ValueEntry."Variant Code" := OldItemLedgEntry."Variant Code";

        LOCKTABLE;
        UpdateValuationDate(ValueEntry);
      END;
    END;

    LOCAL PROCEDURE UpdateOutboundItemLedgEntry@5825(OutboundItemEntryNo@1000 : Integer);
    VAR
      OutboundItemLedgEntry@1001 : Record 32;
    BEGIN
      WITH OutboundItemLedgEntry DO BEGIN
        GET(OutboundItemEntryNo);
        IF Quantity > 0 THEN
          FIELDERROR(Quantity);
        IF GlobalItemLedgEntry.Quantity < 0 THEN
          GlobalItemLedgEntry.FIELDERROR(Quantity);

        "Shipped Qty. Not Returned" := "Shipped Qty. Not Returned" + ABS(ItemJnlLine.Quantity);
        IF "Shipped Qty. Not Returned" > 0 THEN
          FIELDERROR("Shipped Qty. Not Returned",Text004);
        "Applied Entry to Adjust" := TRUE;
        MODIFY;
      END;
    END;

    LOCAL PROCEDURE InitTransValueEntry@5803(VAR ValueEntry@1000 : Record 5802;ItemLedgEntry@1001 : Record 32);
    VAR
      AdjCostInvoicedLCY@1002 : Decimal;
      AdjCostInvoicedACY@1003 : Decimal;
      DiscountAmount@1004 : Decimal;
    BEGIN
      WITH GlobalValueEntry DO BEGIN
        InitValueEntry(ValueEntry,ItemLedgEntry);
        ValueEntry."Valued Quantity" := ItemLedgEntry.Quantity;
        ValueEntry."Invoiced Quantity" := ValueEntry."Valued Quantity";
        ValueEntry."Location Code" := ItemLedgEntry."Location Code";
        ValueEntry."Valuation Date" := "Valuation Date";
        IF AverageTransfer THEN BEGIN
          ValuateAppliedAvgEntry(GlobalValueEntry,Item);
          ValueEntry."Cost Amount (Actual)" := -"Cost Amount (Actual)";
          ValueEntry."Cost Amount (Actual) (ACY)" := -"Cost Amount (Actual) (ACY)";
          ValueEntry."Cost per Unit" := 0;
          ValueEntry."Cost per Unit (ACY)" := 0;
          ValueEntry."Valued By Average Cost" := NOT ItemLedgEntry.Positive;
        END ELSE BEGIN
          CalcAdjustedCost(
            OldItemLedgEntry,ValueEntry."Valued Quantity",
            AdjCostInvoicedLCY,AdjCostInvoicedACY,DiscountAmount);
          ValueEntry."Cost Amount (Actual)" := AdjCostInvoicedLCY;
          ValueEntry."Cost Amount (Actual) (ACY)" := AdjCostInvoicedACY;
          ValueEntry."Cost per Unit" := 0;
          ValueEntry."Cost per Unit (ACY)" := 0;

          "Cost Amount (Actual)" := "Cost Amount (Actual)" - ValueEntry."Cost Amount (Actual)";
          IF GLSetup."Additional Reporting Currency" <> '' THEN
            "Cost Amount (Actual) (ACY)" :=
              CurrExchRate.ExchangeAmtLCYToFCY(
                ValueEntry."Posting Date",GLSetup."Additional Reporting Currency",
                ROUND("Cost Amount (Actual)",GLSetup."Amount Rounding Precision"),
                CurrExchRate.ExchangeRate(
                  ValueEntry."Posting Date",GLSetup."Additional Reporting Currency"));
        END;

        "Discount Amount" := 0;
        ValueEntry."Discount Amount" := 0;
        "Cost per Unit" := 0;
        "Cost per Unit (ACY)" := 0;
      END;
    END;

    LOCAL PROCEDURE ValuateAppliedAvgEntry@5807(VAR ValueEntry@1000 : Record 5802;Item@1001 : Record 27);
    BEGIN
      WITH ValueEntry DO BEGIN
        IF (ItemJnlLine."Applies-to Entry" = 0) AND
           ("Item Ledger Entry Type" <> "Item Ledger Entry Type"::Output)
        THEN BEGIN
          IF (ItemJnlLine.Quantity = 0) AND (ItemJnlLine."Invoiced Quantity" <> 0) THEN BEGIN
            GetLastDirectCostValEntry("Item Ledger Entry No.");
            "Valued By Average Cost" := DirCostValueEntry."Valued By Average Cost";
          END ELSE
            "Valued By Average Cost" := TRUE;

          IF Item."Inventory Value Zero" THEN BEGIN
            "Cost per Unit" := 0;
            "Cost per Unit (ACY)" := 0;
          END ELSE BEGIN
            IF "Item Ledger Entry Type" = "Item Ledger Entry Type"::Transfer THEN BEGIN
              IF SKUExists AND (InvtSetup."Average Cost Calc. Type" <> InvtSetup."Average Cost Calc. Type"::Item) THEN
                "Cost per Unit" := SKU."Unit Cost"
              ELSE
                "Cost per Unit" := Item."Unit Cost";
            END ELSE
              "Cost per Unit" := ItemJnlLine."Unit Cost";

            IF GLSetup."Additional Reporting Currency" <> '' THEN BEGIN
              IF (ItemJnlLine."Source Currency Code" = GLSetup."Additional Reporting Currency") AND
                 ("Item Ledger Entry Type" <> "Item Ledger Entry Type"::Transfer)
              THEN
                "Cost per Unit (ACY)" := ItemJnlLine."Unit Cost (ACY)"
              ELSE
                "Cost per Unit (ACY)" :=
                  ROUND(
                    CurrExchRate.ExchangeAmtLCYToFCY(
                      "Posting Date",GLSetup."Additional Reporting Currency","Cost per Unit",
                      CurrExchRate.ExchangeRate(
                        "Posting Date",GLSetup."Additional Reporting Currency")),
                        Currency."Unit-Amount Rounding Precision");
            END;
          END;
          IF "Expected Cost" THEN BEGIN
            "Cost Amount (Expected)" := "Valued Quantity" * "Cost per Unit";
            "Cost Amount (Expected) (ACY)" := "Valued Quantity" * "Cost per Unit (ACY)";
          END ELSE BEGIN
            "Cost Amount (Actual)" := "Valued Quantity" * "Cost per Unit";
            "Cost Amount (Actual) (ACY)" := "Valued Quantity" * "Cost per Unit (ACY)";
          END;
        END;
      END;
    END;

    LOCAL PROCEDURE CalcAdjustedCost@5804(PosItemLedgEntry@1000 : Record 32;AppliedQty@1001 : Decimal;VAR AdjustedCostLCY@1002 : Decimal;VAR AdjustedCostACY@1003 : Decimal;VAR DiscountAmount@1004 : Decimal);
    VAR
      PosValueEntry@1005 : Record 5802;
    BEGIN
      AdjustedCostLCY := 0;
      AdjustedCostACY := 0;
      DiscountAmount := 0;
      WITH PosValueEntry DO BEGIN
        SETCURRENTKEY("Item Ledger Entry No.");
        SETRANGE("Item Ledger Entry No.",PosItemLedgEntry."Entry No.");
        FINDSET;
        REPEAT
          IF "Partial Revaluation" THEN BEGIN
            AdjustedCostLCY := AdjustedCostLCY +
              "Cost Amount (Actual)" / "Valued Quantity" * PosItemLedgEntry.Quantity;
            AdjustedCostACY := AdjustedCostACY +
              "Cost Amount (Actual) (ACY)" / "Valued Quantity" * PosItemLedgEntry.Quantity;
          END ELSE BEGIN
            AdjustedCostLCY := AdjustedCostLCY + "Cost Amount (Actual)" + "Cost Amount (Expected)";
            AdjustedCostACY := AdjustedCostACY + "Cost Amount (Actual) (ACY)" + "Cost Amount (Expected) (ACY)";
            DiscountAmount := DiscountAmount - "Discount Amount";
          END;
        UNTIL NEXT = 0;

        AdjustedCostLCY := AdjustedCostLCY  * AppliedQty / PosItemLedgEntry.Quantity;
        AdjustedCostACY := AdjustedCostACY * AppliedQty / PosItemLedgEntry.Quantity;
        DiscountAmount := DiscountAmount * AppliedQty / PosItemLedgEntry.Quantity;
      END;
    END;

    PROCEDURE GetMaxValuationDate@70(ItemLedgerEntry@1000 : Record 32) : Date;
    VAR
      ValueEntry@1001 : Record 5802;
    BEGIN
      ValueEntry.SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
      ValueEntry.SETRANGE("Item Ledger Entry No.",ItemLedgerEntry."Entry No.");
      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::Revaluation);
      IF NOT ValueEntry.FIND('+') THEN BEGIN
        ValueEntry.SETRANGE("Entry Type");
        ValueEntry.FIND('+');
      END;
      EXIT(ValueEntry."Valuation Date");
    END;

    LOCAL PROCEDURE GetValuationDate@5813(VAR ValueEntry@1000 : Record 5802;OldItemLedgEntry@1001 : Record 32);
    VAR
      OldValueEntry@1002 : Record 5802;
    BEGIN
      WITH OldItemLedgEntry DO BEGIN
        OldValueEntry.SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        OldValueEntry.SETRANGE("Item Ledger Entry No.","Entry No.");
        OldValueEntry.SETRANGE("Entry Type",OldValueEntry."Entry Type"::Revaluation);
        IF NOT OldValueEntry.FINDLAST THEN BEGIN
          OldValueEntry.SETRANGE("Entry Type");
          OldValueEntry.FINDLAST;
        END;
        IF Positive THEN BEGIN
          IF (ValueEntry."Posting Date" < OldValueEntry."Valuation Date") OR
             (ItemJnlLine."Applies-to Entry" <> 0)
          THEN BEGIN
            ValueEntry."Valuation Date" := OldValueEntry."Valuation Date";
            SetValuationDateAllValueEntrie(ValueEntry."Item Ledger Entry No.",OldValueEntry."Valuation Date");
          END ELSE
          BEGIN
            ValueEntry."Valuation Date" := ValueEntry."Posting Date";
            SetValuationDateAllValueEntrie(ValueEntry."Item Ledger Entry No.",ValueEntry."Posting Date");
          END
        END ELSE
          IF OldValueEntry."Valuation Date" < ValueEntry."Valuation Date" THEN BEGIN
            UpdateAvgCostAdjmtEntryPoint(OldItemLedgEntry,OldValueEntry."Valuation Date");
            OldValueEntry.MODIFYALL("Valuation Date",ValueEntry."Valuation Date");
            UpdateLinkedValuationDate(ValueEntry."Valuation Date","Entry No.",Positive);
          END;
      END;
    END;

    LOCAL PROCEDURE UpdateLinkedValuationDate@52(FromValuationDate@1000 : Date;FromItemledgEntryNo@1003 : Integer;FromInbound@1001 : Boolean);
    VAR
      ToItemApplnEntry@1004 : Record 339;
      ToValueEntry2@1005 : Record 5802;
    BEGIN
      WITH ToItemApplnEntry DO BEGIN
        IF FromInbound THEN BEGIN
          SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.","Outbound Item Entry No.");
          SETRANGE("Inbound Item Entry No.",FromItemledgEntryNo);
          SETFILTER("Outbound Item Entry No.",'<>%1',0);
        END ELSE BEGIN
          SETCURRENTKEY("Outbound Item Entry No.","Item Ledger Entry No.");
          SETRANGE("Outbound Item Entry No.",FromItemledgEntryNo);
        END;
        SETFILTER("Item Ledger Entry No.",'<>%1',FromItemledgEntryNo);
        IF FINDSET THEN BEGIN
          REPEAT
            IF FromInbound OR ("Inbound Item Entry No." <> 0) THEN BEGIN
              GetLastDirectCostValEntry("Inbound Item Entry No.");
              IF DirCostValueEntry."Valuation Date" < FromValuationDate THEN BEGIN
                UpdateValuationDate(FromValuationDate,"Item Ledger Entry No.",FromInbound);
                UpdateLinkedValuationDate(FromValuationDate,"Item Ledger Entry No.",NOT FromInbound);
              END;
            END;
          UNTIL NEXT = 0;
        END;
      END;
    END;

    LOCAL PROCEDURE UpdateLinkedValuationUnapply@77(FromValuationDate@1000 : Date;FromItemLedgEntryNo@1001 : Integer;FromInbound@1002 : Boolean);
    VAR
      ToItemApplnEntry@1003 : Record 339;
      ToValueEntry2@1004 : Record 5802;
      ValuationDate@1005 : Date;
      ItemLedgerEntry@1006 : Record 32;
    BEGIN
      WITH ToItemApplnEntry DO BEGIN
        IF FromInbound THEN BEGIN
          SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.","Outbound Item Entry No.");
          SETRANGE("Inbound Item Entry No.",FromItemLedgEntryNo);
          SETFILTER("Outbound Item Entry No.",'<>%1',0);
        END ELSE BEGIN
          SETCURRENTKEY("Outbound Item Entry No.","Item Ledger Entry No.");
          SETRANGE("Outbound Item Entry No.",FromItemLedgEntryNo);
        END;
        SETFILTER("Item Ledger Entry No.",'<>%1',FromItemLedgEntryNo);
        IF FIND('-') THEN BEGIN
          REPEAT
            IF FromInbound OR ("Inbound Item Entry No." <> 0) THEN BEGIN
              GetLastDirectCostValEntry("Inbound Item Entry No.");
              IF DirCostValueEntry."Valuation Date" < FromValuationDate THEN BEGIN
                UpdateValuationDate(FromValuationDate,"Item Ledger Entry No.",FromInbound);
                UpdateLinkedValuationUnapply(FromValuationDate,"Item Ledger Entry No.",NOT FromInbound);
              END
              ELSE
              BEGIN
                ItemLedgerEntry.GET("Inbound Item Entry No.");
                FromValuationDate := GetMaxAppliedValuationdate(ItemLedgerEntry);
                IF FromValuationDate < DirCostValueEntry."Valuation Date" THEN BEGIN
                  UpdateValuationDate(FromValuationDate,ItemLedgerEntry."Entry No.",FromInbound);
                  UpdateLinkedValuationUnapply(FromValuationDate,ItemLedgerEntry."Entry No.",NOT FromInbound);
                END;
              END;
            END;
          UNTIL NEXT = 0;
        END;
      END;
    END;

    PROCEDURE UpdateValuationDate@79(FromValuationDate@1002 : Date;FromItemLedgEntryNo@1001 : Integer;FromInbound@1000 : Boolean);
    VAR
      ToValueEntry2@1003 : Record 5802;
    BEGIN
      ToValueEntry2.SETCURRENTKEY("Item Ledger Entry No.");
      ToValueEntry2.SETRANGE("Item Ledger Entry No.",FromItemLedgEntryNo);
      ToValueEntry2.FIND('-');
      IF FromInbound THEN
        ToValueEntry2.MODIFYALL("Valuation Date",FromValuationDate)
      ELSE
        REPEAT
          IF ToValueEntry2."Entry Type" = ToValueEntry2."Entry Type"::Revaluation THEN BEGIN
            IF ToValueEntry2."Valuation Date" < FromValuationDate THEN BEGIN
              ToValueEntry2."Valuation Date" := FromValuationDate;
              ToValueEntry2.MODIFY;
            END;
          END ELSE BEGIN
            ToValueEntry2."Valuation Date" := FromValuationDate;
            ToValueEntry2.MODIFY;
          END;
        UNTIL ToValueEntry2.NEXT = 0;
    END;

    PROCEDURE CreateItemJNLLinefromEntry@78(ItemLedgEntry@1000 : Record 32;NewQuantity@1002 : Decimal;VAR ItemJnlLine@1001 : Record 83);
    BEGIN
      CLEAR(ItemJnlLine);
      WITH ItemJnlLine DO BEGIN
        "Entry Type":=ItemLedgEntry."Entry Type"; // no mapping needed
        Quantity:=NewQuantity;
        "Item No.":=ItemLedgEntry."Item No.";
        "Serial No.":=ItemLedgEntry."Serial No.";
        "Lot No.":=ItemLedgEntry."Lot No.";
      END;
    END;

    LOCAL PROCEDURE GetAppliedFromValues@53(VAR ValueEntry@1000 : Record 5802);
    VAR
      NegValueEntry@1002 : Record 5802;
    BEGIN
      WITH NegValueEntry DO BEGIN
        SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        SETRANGE("Item Ledger Entry No.",ItemJnlLine."Applies-from Entry");
        SETRANGE("Entry Type","Entry Type"::Revaluation);
        IF NOT FINDLAST THEN BEGIN
          SETRANGE("Entry Type");
          FINDLAST;
        END;

        IF "Valuation Date" > ValueEntry."Posting Date" THEN
          ValueEntry."Valuation Date" := "Valuation Date"
        ELSE
          ValueEntry."Valuation Date" := ItemJnlLine."Posting Date";
      END;
    END;

    LOCAL PROCEDURE RoundAmtValueEntry@5806(VAR ValueEntry@1000 : Record 5802);
    BEGIN
      WITH ValueEntry DO BEGIN
        "Sales Amount (Actual)" := ROUND("Sales Amount (Actual)");
        "Sales Amount (Expected)" := ROUND("Sales Amount (Expected)");
        "Purchase Amount (Actual)" := ROUND("Purchase Amount (Actual)");
        "Purchase Amount (Expected)" := ROUND("Purchase Amount (Expected)");
        "Discount Amount" := ROUND("Discount Amount");
        "Cost Amount (Actual)" := ROUND("Cost Amount (Actual)");
        "Cost Amount (Expected)" := ROUND("Cost Amount (Expected)");
        "Cost Amount (Non-Invtbl.)" := ROUND("Cost Amount (Non-Invtbl.)");
        "Cost Amount (Actual) (ACY)" := ROUND("Cost Amount (Actual) (ACY)",Currency."Amount Rounding Precision");
        "Cost Amount (Expected) (ACY)" := ROUND("Cost Amount (Expected) (ACY)",Currency."Amount Rounding Precision");
        "Cost Amount (Non-Invtbl.)(ACY)" := ROUND("Cost Amount (Non-Invtbl.)(ACY)",Currency."Amount Rounding Precision");
      END;
    END;

    LOCAL PROCEDURE RetrieveCostPerUnit@5819() : Decimal;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF (Item."Costing Method" = Item."Costing Method"::Standard) AND
           ("Value Entry Type" = "Value Entry Type"::"Direct Cost") AND
           ("Item Charge No." = '') AND
           ("Applies-from Entry" = 0) AND
           NOT Adjustment
        THEN BEGIN
          IF SKUExists THEN
            EXIT(SKU."Unit Cost")
          ELSE
            EXIT(Item."Unit Cost");
        END ELSE
          EXIT("Unit Cost");
      END;
    END;

    LOCAL PROCEDURE RetrieveCostPerUnitACY@5824(CostPerUnit@1000 : Decimal) : Decimal;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF Adjustment OR ("Source Currency Code" = GLSetup."Additional Reporting Currency") AND
           ((Item."Costing Method" <> Item."Costing Method"::Standard) OR
            (("Discount Amount" = 0) AND ("Indirect Cost %" = 0) AND ("Overhead Rate" = 0)))
        THEN
          EXIT("Unit Cost (ACY)")
        ELSE
          EXIT(ROUND(CurrExchRate.ExchangeAmtLCYToFCY(
                "Posting Date",GLSetup."Additional Reporting Currency",
                CostPerUnit,CurrExchRate.ExchangeRate(
                  "Posting Date",GLSetup."Additional Reporting Currency")),
              Currency."Unit-Amount Rounding Precision"));
      END;
    END;

    LOCAL PROCEDURE CalcCostPerUnit@5815(Cost@1000 : Decimal;Quantity@1001 : Decimal;IsACY@1002 : Boolean) : Decimal;
    VAR
      RndgPrec@1003 : Decimal;
    BEGIN
      GetGLSetup;

      IF IsACY THEN
        RndgPrec := Currency."Unit-Amount Rounding Precision"
      ELSE
        RndgPrec := GLSetup."Unit-Amount Rounding Precision";

      IF Quantity <> 0 THEN
        EXIT(ROUND(Cost / Quantity,RndgPrec))
      ELSE
        EXIT(0);
    END;

    LOCAL PROCEDURE CalcPosShares@5823(VAR DirCost@1000 : Decimal;VAR OvhdCost@1001 : Decimal;VAR PurchVar@1002 : Decimal;VAR DirCostACY@1008 : Decimal;VAR OvhdCostACY@1003 : Decimal;VAR PurchVarACY@1004 : Decimal;VAR CalcUnitCost@1005 : Boolean;CalcPurchVar@1006 : Boolean;Expected@1007 : Boolean);
    VAR
      CostCalcMgt@1009 : Codeunit 5836;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF Expected THEN BEGIN
          DirCost := "Unit Cost" * Quantity;
          PurchVar := 0;
          PurchVarACY := 0;
          OvhdCost := 0;
          OvhdCostACY := 0;
        END ELSE BEGIN
          OvhdCost :=
            ROUND(
              CostCalcMgt.CalcOvhdCost(
                Amount,"Indirect Cost %","Overhead Rate","Invoiced Quantity"),
                GLSetup."Amount Rounding Precision");
          DirCost := Amount;
          IF CalcPurchVar THEN
            PurchVar := "Unit Cost" * "Invoiced Quantity" - DirCost - OvhdCost
          ELSE BEGIN
            PurchVar := 0;
            PurchVarACY := 0;
          END;
        END;

        IF GLSetup."Additional Reporting Currency" <> '' THEN BEGIN
          DirCostACY := ACYMgt.CalcACYAmt(DirCost,"Posting Date",FALSE);
          OvhdCostACY := ACYMgt.CalcACYAmt(OvhdCost,"Posting Date",FALSE);
          "Unit Cost (ACY)" :=
            ROUND(
              CurrExchRate.ExchangeAmtLCYToFCY(
                "Posting Date",GLSetup."Additional Reporting Currency","Unit Cost",
                CurrExchRate.ExchangeRate(
                  "Posting Date",GLSetup."Additional Reporting Currency")),
              Currency."Unit-Amount Rounding Precision");
          PurchVarACY := "Unit Cost (ACY)" * "Invoiced Quantity" - DirCostACY - OvhdCostACY;
        END;
        CalcUnitCost := (DirCost <> 0) AND ("Unit Cost" = 0);
      END;
    END;

    LOCAL PROCEDURE CalcPurchCorrShares@5826(VAR OverheadAmount@1001 : Decimal;VAR OverheadAmountACY@1002 : Decimal;VAR VarianceAmount@1003 : Decimal;VAR VarianceAmountACY@1004 : Decimal);
    VAR
      OldItemLedgEntry@1000 : Record 32;
      OldValueEntry@1005 : Record 5802;
      CostAmt@1007 : Decimal;
      CostAmtACY@1006 : Decimal;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        OldValueEntry.SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        OldValueEntry.SETRANGE("Item Ledger Entry No.","Applies-to Entry");
        OldValueEntry.SETRANGE("Entry Type",OldValueEntry."Entry Type"::"Indirect Cost");
        IF OldValueEntry.FINDSET THEN
          REPEAT
            IF NOT OldValueEntry."Partial Revaluation" THEN BEGIN
              CostAmt := CostAmt + OldValueEntry."Cost Amount (Actual)";
              CostAmtACY := CostAmtACY + OldValueEntry."Cost Amount (Actual) (ACY)";
            END;
          UNTIL OldValueEntry.NEXT = 0;
        IF (CostAmt <> 0) OR (CostAmtACY <> 0) THEN BEGIN
          OldItemLedgEntry.GET("Applies-to Entry");
          OverheadAmount := ROUND(
              CostAmt / OldItemLedgEntry."Invoiced Quantity" * "Invoiced Quantity",
              GLSetup."Amount Rounding Precision");
          OverheadAmountACY := ROUND(
              CostAmtACY / OldItemLedgEntry."Invoiced Quantity" * "Invoiced Quantity",
              Currency."Unit-Amount Rounding Precision");
          IF Item."Costing Method" = Item."Costing Method"::Standard THEN BEGIN
            VarianceAmount := -OverheadAmount;
            VarianceAmountACY := -OverheadAmountACY;
          END ELSE BEGIN
            VarianceAmount := 0;
            VarianceAmountACY := 0;
          END;
        END ELSE
          IF Item."Costing Method" = Item."Costing Method"::Standard THEN BEGIN
            OldValueEntry.SETRANGE("Entry Type",OldValueEntry."Entry Type"::Variance);
            VarianceRequired := OldValueEntry.FINDFIRST;
          END;
      END;
    END;

    LOCAL PROCEDURE GetLastDirectCostValEntry@5817(ItemLedgEntryNo@1000 : Decimal);
    VAR
      Found@1001 : Boolean;
    BEGIN
      IF ItemLedgEntryNo = DirCostValueEntry."Item Ledger Entry No." THEN
        EXIT;
      DirCostValueEntry.RESET;
      DirCostValueEntry.SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
      DirCostValueEntry.SETRANGE("Item Ledger Entry No.",ItemLedgEntryNo);
      DirCostValueEntry.SETRANGE("Entry Type",DirCostValueEntry."Entry Type"::"Direct Cost");
      DirCostValueEntry.SETFILTER("Item Charge No.",'%1','');
      Found := DirCostValueEntry.FINDLAST;
      DirCostValueEntry.SETRANGE("Item Charge No.");
      IF NOT Found THEN
        DirCostValueEntry.FINDLAST;
    END;

    LOCAL PROCEDURE IsFirstValueEntry@54(ItemLedgEntryNo@1001 : Integer) : Boolean;
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      ValueEntry.SETCURRENTKEY("Item Ledger Entry No.");
      ValueEntry.SETRANGE("Item Ledger Entry No.",ItemLedgEntryNo);
      EXIT(ValueEntry.ISEMPTY);
    END;

    LOCAL PROCEDURE CalcExpectedCost@60(ItemLedgEntryNo@1003 : Integer;InvoicedQty@1006 : Decimal;Quantity@1005 : Decimal;VAR ExpectedCost@1001 : Decimal;VAR ExpectedCostACY@1002 : Decimal;VAR ExpectedSalesAmt@1007 : Decimal;VAR ExpectedPurchAmt@1008 : Decimal;CalcReminder@1004 : Boolean);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      ExpectedCost := 0;
      ExpectedCostACY := 0;
      ExpectedSalesAmt := 0;
      ExpectedPurchAmt := 0;

      WITH ValueEntry DO BEGIN
        SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        SETRANGE("Item Ledger Entry No.",ItemLedgEntryNo);
        SETFILTER("Entry Type",'<>%1',"Entry Type"::Revaluation);
        IF FINDSET AND "Expected Cost" THEN
          IF CalcReminder THEN BEGIN
            CALCSUMS(
              "Cost Amount (Expected)","Cost Amount (Expected) (ACY)",
              "Sales Amount (Expected)","Purchase Amount (Expected)");
            ExpectedCost :=  -"Cost Amount (Expected)";
            ExpectedCostACY := -"Cost Amount (Expected) (ACY)";
            IF NOT CalledFromAdjustment THEN BEGIN
              ExpectedSalesAmt := -"Sales Amount (Expected)";
              ExpectedPurchAmt := -"Purchase Amount (Expected)";
            END
          END ELSE BEGIN
            REPEAT
              IF "Expected Cost" THEN BEGIN
                ExpectedCost := ExpectedCost + "Cost Amount (Expected)";
                ExpectedCostACY := ExpectedCostACY + "Cost Amount (Expected) (ACY)";
                IF NOT CalledFromAdjustment THEN BEGIN
                  ExpectedSalesAmt := ExpectedSalesAmt + "Sales Amount (Expected)";
                  ExpectedPurchAmt := ExpectedPurchAmt + "Purchase Amount (Expected)";
                END;
              END;
            UNTIL NEXT = 0;
            ExpectedCost :=
              CalcExpCostToBalance(ExpectedCost,InvoicedQty,Quantity,GLSetup."Amount Rounding Precision");
            ExpectedCostACY :=
              CalcExpCostToBalance(ExpectedCostACY,InvoicedQty,Quantity,Currency."Amount Rounding Precision");
            IF NOT CalledFromAdjustment THEN BEGIN
              ExpectedSalesAmt :=
                CalcExpCostToBalance(ExpectedSalesAmt,InvoicedQty,Quantity,GLSetup."Amount Rounding Precision");
              ExpectedPurchAmt :=
                CalcExpCostToBalance(ExpectedPurchAmt,InvoicedQty,Quantity,GLSetup."Amount Rounding Precision");
            END;
          END;
      END;
    END;

    LOCAL PROCEDURE CalcExpCostToBalance@55(ExpectedCost@1000 : Decimal;InvoicedQty@1001 : Decimal;Quantity@1002 : Decimal;RoundPrecision@1003 : Decimal) : Decimal;
    BEGIN
      EXIT(-ROUND(InvoicedQty / Quantity * ExpectedCost,RoundPrecision));
    END;

    LOCAL PROCEDURE MoveValEntryDimToValEntryDim@5818(VAR ToValueEntry@1000 : Record 5802;FromValueEntry@1001 : Record 5802);
    VAR
      ToLedgEntryDim@1002 : Record 355;
      FromLedgEntryDim@1003 : Record 355;
    BEGIN
      ToValueEntry."Global Dimension 1 Code" := FromValueEntry."Global Dimension 1 Code";
      ToValueEntry."Global Dimension 2 Code" := FromValueEntry."Global Dimension 2 Code";

      FromLedgEntryDim.SETRANGE("Table ID",DATABASE::"Value Entry");
      FromLedgEntryDim.SETRANGE("Entry No.",FromValueEntry."Entry No.");
      IF FromLedgEntryDim.FINDSET THEN
        REPEAT
          ToLedgEntryDim := FromLedgEntryDim;
          ToLedgEntryDim."Entry No." := ToValueEntry."Entry No.";
          ToLedgEntryDim.INSERT;
        UNTIL FromLedgEntryDim.NEXT = 0;
    END;

    LOCAL PROCEDURE AutoTrack@5850(VAR ItemLedgEntryRec@1000 : Record 32);
    VAR
      ReservMgt@1001 : Codeunit 99000845;
    BEGIN
      IF Item."Order Tracking Policy" = Item."Order Tracking Policy"::None THEN BEGIN
        // Ensure that Item Tracking is not left on the item ledger entry:
        ReservMgt.SetItemLedgEntry(ItemLedgEntryRec);
        ReservMgt.SetItemTrackingHandling(1);
        ReservMgt.ClearSurplus;
        EXIT;
      END;

      ReservMgt.SetItemLedgEntry(ItemLedgEntryRec);
      ReservMgt.SetItemTrackingHandling(1);
      ReservMgt.DeleteReservEntries(FALSE,ItemLedgEntryRec."Remaining Quantity");
      ReservMgt.ClearSurplus;
      ReservMgt.AutoTrack(ItemLedgEntryRec."Remaining Quantity");
    END;

    PROCEDURE SetPostponeReservationHandling@2(Postpone@1000 : Boolean);
    BEGIN
      // Used when posting Transfer Order receipts
      PostponeReservationHandling := Postpone;
    END;

    LOCAL PROCEDURE SetupSplitJnlLine@20(VAR ItemJnlLine2@1000 : Record 83;VAR PostItemJnlLine@1016 : Boolean);
    VAR
      LateBindingMgt@1013 : Codeunit 6502;
      Factor@1002 : Decimal;
      FloatingFactor@1007 : Decimal;
      NonDistrQuantity@1006 : Decimal;
      NonDistrAmount@1012 : Decimal;
      NonDistrAmountACY@1011 : Decimal;
      NonDistrDiscountAmount@1005 : Decimal;
      SignFactor@1003 : Integer;
      SumOfEntries@1085 : Decimal;
      CalcWarrantyDate@1014 : Date;
      CalcExpirationDate@1015 : Date;
      Invoice@1004 : Boolean;
      SNInfoRequired@1008 : Boolean;
      ExistingExpirationDate@1010 : Date;
      LotInfoRequired@1009 : Boolean;
      EntriesExist@1000000000 : Boolean;
      SumLot@1001 : Decimal;
    BEGIN
      ItemJnlLineOrigin := ItemJnlLine2;
      TempSplitItemJnlLine.RESET;
      TempSplitItemJnlLine.DELETEALL;

      GetGLSetup;
      GetInvtSetup;

      IF Item.GET(ItemJnlLine2."Item No.") THEN BEGIN
        IF NOT CalledFromAdjustment THEN
          Item.TESTFIELD(Blocked,FALSE);
      END ELSE
        Item.INIT;

      DisableItemTracking := NOT ItemJnlLine2.ItemPosting;

      ItemTrackingCode.Code := Item."Item Tracking Code";
      ItemTrackingMgt.GetItemTrackingSettings(
        ItemTrackingCode,ItemJnlLine."Entry Type",ItemJnlLine.Signed(ItemJnlLine."Quantity (Base)") > 0,
        SNRequired,LotRequired,SNInfoRequired,LotInfoRequired);

      IF Item."Costing Method" = Item."Costing Method"::Specific THEN BEGIN
        Item.TESTFIELD(Item."Item Tracking Code");
        ItemTrackingCode.TESTFIELD("SN Specific Tracking",TRUE);
      END;

      Invoice := ItemJnlLine2."Invoiced Qty. (Base)" <> 0;

      IF (ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) AND
        PostponeReservationHandling
      THEN
        SignFactor := 1
      ELSE
        SignFactor := ItemJnlLine2.Signed(1);

      IF (NOT ItemJnlLine2.Correction OR IsServUndoConsumption) AND
        (ItemJnlLine2."Quantity (Base)" <> 0) AND
        ItemTrackingMgt.RetrieveItemTracking(ItemJnlLine2,TempTrackingSpecification)
      THEN BEGIN
        IF DisableItemTracking THEN BEGIN
          IF NOT TempTrackingSpecification.ISEMPTY THEN
            ERROR(Text021,ItemJnlLine2.FIELDCAPTION("Operation No."),ItemJnlLine2."Operation No.");
        END ELSE BEGIN
          IF TempTrackingSpecification.ISEMPTY THEN
            ERROR(Text100);
          ItemJnlLine2.TESTFIELD(ItemJnlLine2."Serial No.",'');
          ItemJnlLine2.TESTFIELD(ItemJnlLine2."Lot No.",'');
          ItemJnlLine2.TESTFIELD(ItemJnlLine2."New Serial No.",'');
          ItemJnlLine2.TESTFIELD(ItemJnlLine2."New Lot No.",'');

          IF FORMAT(ItemTrackingCode."Warranty Date Formula") <> '' THEN
            CalcWarrantyDate := CALCDATE(ItemTrackingCode."Warranty Date Formula",ItemJnlLine2."Document Date");
          IF FORMAT(Item."Expiration Calculation") <> '' THEN
            CalcExpirationDate := CALCDATE(Item."Expiration Calculation",ItemJnlLine2."Document Date");

          IF (SignFactor * ItemJnlLine2.Quantity < 0) THEN // Demand
            IF ItemTrackingCode."SN Specific Tracking" OR ItemTrackingCode."Lot Specific Tracking" THEN
              LateBindingMgt.ReallocateTrkgSpecification(TempTrackingSpecification);

          TempTrackingSpecification.CALCSUMS(
            "Qty. to Handle (Base)","Qty. to Invoice (Base)","Qty. to Handle","Qty. to Invoice");
          TempTrackingSpecification.TestFieldError(TempTrackingSpecification.FIELDCAPTION("Qty. to Handle (Base)"),
            TempTrackingSpecification."Qty. to Handle (Base)",SignFactor * ItemJnlLine2."Quantity (Base)");

          IF Invoice THEN
            TempTrackingSpecification.TestFieldError(TempTrackingSpecification.FIELDCAPTION("Qty. to Invoice (Base)"),
              TempTrackingSpecification."Qty. to Invoice (Base)",SignFactor * ItemJnlLine2."Invoiced Qty. (Base)");

          NonDistrQuantity := ItemJnlLine2.Quantity;
          NonDistrAmount := ItemJnlLine2.Amount;
          NonDistrAmountACY := ItemJnlLine2."Amount (ACY)";
          NonDistrDiscountAmount := ItemJnlLine2."Discount Amount";

          TempTrackingSpecification.FINDSET;
          REPEAT
            IF ItemTrackingCode."Man. Warranty Date Entry Reqd." THEN
              TempTrackingSpecification.TESTFIELD("Warranty Date");

            ExistingExpirationDate :=
              ItemTrackingMgt.ExistingExpirationDate(
                TempTrackingSpecification."Item No.",
                TempTrackingSpecification."Variant Code",
                TempTrackingSpecification."Lot No.",
                TempTrackingSpecification."Serial No.",
                TRUE,
                EntriesExist);

            IF NOT EntriesExist THEN
              ItemTrackingMgt.TestExpDateOnTrackingSpec(TempTrackingSpecification);
            IF (ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) THEN
              IF TempTrackingSpecification."Expiration Date" = 0D THEN
                TempTrackingSpecification."Expiration Date" := ExistingExpirationDate;

            // Supply
            IF (SignFactor * ItemJnlLine2.Quantity > 0) THEN BEGIN        // Only expiration dates on supply.

              IF NOT (ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) THEN
                IF ItemTrackingCode."Man. Expir. Date Entry Reqd." THEN
                  IF NOT TempTrackingSpecification.Correction THEN
                    TempTrackingSpecification.TESTFIELD("Expiration Date");

              IF CalcExpirationDate <> 0D THEN
                IF ExistingExpirationDate <> 0D THEN
                  CalcExpirationDate := ExistingExpirationDate;

              IF (ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) THEN
                IF TempTrackingSpecification."New Expiration Date" = 0D THEN
                  TempTrackingSpecification."New Expiration Date" := ExistingExpirationDate;

              IF TempTrackingSpecification."Expiration Date" = 0D THEN
                TempTrackingSpecification."Expiration Date" := CalcExpirationDate;

              IF EntriesExist THEN
                TempTrackingSpecification.TESTFIELD("Expiration Date",ExistingExpirationDate);

            END ELSE BEGIN  // Demand
              IF (ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) THEN BEGIN

                ExistingExpirationDate :=
                  ItemTrackingMgt.ExistingExpirationDateAndQty(
                    TempTrackingSpecification."Item No.",
                    TempTrackingSpecification."Variant Code",
                    TempTrackingSpecification."New Lot No.",
                    TempTrackingSpecification."New Serial No.",
                    SumOfEntries);

                IF ItemJnlLine2."Transfer Order No." <> '' THEN
                  IF TempTrackingSpecification."New Expiration Date" = 0D THEN
                    TempTrackingSpecification."New Expiration Date" := ExistingExpirationDate;

                IF (TempTrackingSpecification."New Lot No." <> '') AND (ItemJnlLine2."Transfer Order No." = '') THEN BEGIN
                  IF TempTrackingSpecification."New Serial No." <> '' THEN
                    SumLot := SignFactor * ItemTrackingMgt.SumNewLotOnTrackingSpec(TempTrackingSpecification)
                  ELSE
                    SumLot := SignFactor * TempTrackingSpecification."Quantity (Base)";
                  IF (SumOfEntries > 0) AND
                     ((SumOfEntries <> SumLot) OR (TempTrackingSpecification."New Lot No." <> TempTrackingSpecification."Lot No."))
                  THEN
                    TempTrackingSpecification.TESTFIELD("New Expiration Date",ExistingExpirationDate);
                  ItemTrackingMgt.TestExpDateOnTrackingSpecNew(TempTrackingSpecification);
                END;
              END;
            END;

            CheckItemTrackingInfo(ItemJnlLine2,TempTrackingSpecification,SNInfoRequired,LotInfoRequired);

            IF (ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) AND (ItemJnlLine2."Transfer Order No." = '') THEN
              IF ItemTrackingCode."Man. Expir. Date Entry Reqd." THEN
                TempTrackingSpecification.TESTFIELD("New Expiration Date");

            IF TempTrackingSpecification."Warranty Date" = 0D THEN
              TempTrackingSpecification."Warranty Date" := CalcWarrantyDate;

            TempSplitItemJnlLine := ItemJnlLine2;
            Factor := TempTrackingSpecification."Qty. to Handle (Base)" / ItemJnlLine2."Quantity (Base)";
            WITH TempSplitItemJnlLine DO BEGIN
              "Quantity (Base)" := SignFactor * TempTrackingSpecification."Qty. to Handle (Base)";
              Quantity := SignFactor * TempTrackingSpecification."Qty. to Handle";
              IF Invoice THEN BEGIN
                "Invoiced Quantity" := SignFactor * TempTrackingSpecification."Qty. to Invoice";
                "Invoiced Qty. (Base)" := SignFactor * TempTrackingSpecification."Qty. to Invoice (Base)";
              END;

              IF ItemJnlLine2."Output Quantity" <> 0 THEN BEGIN
                "Output Quantity (Base)" := "Quantity (Base)";
                "Output Quantity" := Quantity;
              END;

              IF ItemJnlLine2."Phys. Inventory" THEN
                "Qty. (Phys. Inventory)" := "Qty. (Calculated)" + SignFactor * "Quantity (Base)";

              FloatingFactor := Quantity / NonDistrQuantity;
              IF FloatingFactor < 1 THEN BEGIN
                Amount := ROUND(NonDistrAmount * FloatingFactor,GLSetup."Amount Rounding Precision");
                "Amount (ACY)" := ROUND(NonDistrAmountACY * FloatingFactor,Currency."Amount Rounding Precision");
                "Discount Amount" := ROUND(NonDistrDiscountAmount * FloatingFactor,GLSetup."Amount Rounding Precision");
                NonDistrAmount := NonDistrAmount - Amount;
                NonDistrAmountACY := NonDistrAmountACY - "Amount (ACY)";
                NonDistrDiscountAmount := NonDistrDiscountAmount - "Discount Amount";
                NonDistrQuantity := NonDistrQuantity - Quantity;
                "Setup Time" := 0;
                "Run Time" := 0;
                "Stop Time" := 0;
                "Setup Time (Base)" := 0;
                "Run Time (Base)" := 0;
                "Stop Time (Base)" := 0;
                "Starting Time" := 0T;
                "Ending Time" := 0T;
                "Scrap Quantity" := 0;
                "Scrap Quantity (Base)" := 0;
                "Concurrent Capacity" := 0;
              END ELSE BEGIN // the last record
                Amount := NonDistrAmount;
                "Amount (ACY)" := NonDistrAmountACY;
                "Discount Amount" := NonDistrDiscountAmount;
              END;

              "Serial No." := TempTrackingSpecification."Serial No.";
              "Lot No." := TempTrackingSpecification."Lot No.";
              "New Serial No." := TempTrackingSpecification."New Serial No.";
              "New Lot No." := TempTrackingSpecification."New Lot No.";
              "Item Expiration Date" := TempTrackingSpecification."Expiration Date";
              "New Item Expiration Date" := TempTrackingSpecification."New Expiration Date";

              IF NOT PostItemJnlLine THEN
                PostItemJnlLine :=
                  ("Serial No." <> "New Serial No.") OR
                  ("Lot No." <> "New Lot No.") OR
                  ("Item Expiration Date" <> "New Item Expiration Date");

              "Warranty Date" := TempTrackingSpecification."Warranty Date";

              "Line No." := TempTrackingSpecification."Entry No.";

              IF TempTrackingSpecification.Correction OR "Drop Shipment" OR IsServUndoConsumption THEN
                "Applies-to Entry" := TempTrackingSpecification."Appl.-to Item Entry";
              "Applies-from Entry" := TempTrackingSpecification."Appl.-from Item Entry";
              INSERT;
            END;
          UNTIL TempTrackingSpecification.NEXT = 0;
        END;
      END ELSE BEGIN
        TempSplitItemJnlLine := ItemJnlLine2;
        TempSplitItemJnlLine.INSERT;
      END;
    END;

    LOCAL PROCEDURE SplitJnlLine@15(VAR ItemJnlLine2@1000 : Record 83;PostItemJnlLine@1003 : Boolean) : Boolean;
    VAR
      FreeEntryNo@1005 : Integer;
      JnlLineNo@1001 : Integer;
      SignFactor@1002 : Integer;
    BEGIN
      IF (ItemJnlLine2."Quantity (Base)" <> 0) AND
         ((ItemJnlLine2."Serial No." <> '') OR (ItemJnlLine2."Lot No." <> ''))
      THEN BEGIN
        IF (ItemJnlLine2."Entry Type" IN
            [ItemJnlLine2."Entry Type"::Sale,
             ItemJnlLine2."Entry Type"::"Negative Adjmt.",
             ItemJnlLine2."Entry Type"::Consumption]) OR
           ((ItemJnlLine2."Entry Type" = ItemJnlLine2."Entry Type"::Transfer) AND
           NOT PostponeReservationHandling)
        THEN
          SignFactor := -1
        ELSE
          SignFactor := 1;

        TempTrackingSpecification.SETRANGE("Serial No.",ItemJnlLine2."Serial No.");
        TempTrackingSpecification.SETRANGE("Lot No.",ItemJnlLine2."Lot No.");
        IF TempTrackingSpecification.FINDFIRST THEN BEGIN
          FreeEntryNo := TempTrackingSpecification."Entry No.";
          TempTrackingSpecification.DELETE;
          ItemJnlLine2.TESTFIELD("Serial No.",TempTrackingSpecification."Serial No.");
          ItemJnlLine2.TESTFIELD("Lot No.",TempTrackingSpecification."Lot No.");
          TempTrackingSpecification."Quantity (Base)" := SignFactor * ItemJnlLine2."Quantity (Base)";
          TempTrackingSpecification."Quantity Handled (Base)" := SignFactor * ItemJnlLine2."Quantity (Base)";
          TempTrackingSpecification."Quantity actual Handled (Base)" := SignFactor * ItemJnlLine2."Quantity (Base)";
          TempTrackingSpecification."Quantity Invoiced (Base)" := SignFactor * ItemJnlLine2."Invoiced Qty. (Base)";
          TempTrackingSpecification."Qty. to Invoice (Base)" :=
            SignFactor * (ItemJnlLine2."Quantity (Base)" - ItemJnlLine2."Invoiced Qty. (Base)");
          TempTrackingSpecification."Qty. to Handle (Base)" := 0;
          TempTrackingSpecification."Qty. to Handle" := 0;
          TempTrackingSpecification."Qty. to Invoice" :=
            SignFactor * (ItemJnlLine2.Quantity - ItemJnlLine2."Invoiced Quantity");
          TempTrackingSpecification."Appl.-to Item Entry" := GlobalItemLedgEntry."Entry No.";
          TempTrackingSpecification."Transfer Item Entry No." := TempItemEntryRelation."Item Entry No.";
          IF PostItemJnlLine THEN
            TempTrackingSpecification."Entry No." := TempTrackingSpecification."Appl.-to Item Entry";
          InsertTempTrkgSpecification(FreeEntryNo);
        END ELSE
          IF ItemJnlLine2."Item Charge No." = '' THEN
            IF NOT ItemJnlLine2.Correction THEN // Undo quantity posting.
              ERROR(Text011);
      END;

      IF TempSplitItemJnlLine.FINDFIRST THEN BEGIN
        JnlLineNo := ItemJnlLine2."Line No.";
        ItemJnlLine2 := TempSplitItemJnlLine;
        ItemJnlLine2."Line No." := JnlLineNo;
        TempSplitItemJnlLine.DELETE;
        EXIT(TRUE);
      END ELSE BEGIN
        IF ItemJnlLine."Phys. Inventory" THEN
          InsertPhysInventoryEntry;
        EXIT(FALSE);
      END
    END;

    PROCEDURE CollectTrackingSpecification@16(VAR TargetTrackingSpecification@1001 : TEMPORARY Record 336) @1000 : Boolean;
    BEGIN
      TempTrackingSpecification.RESET;
      TargetTrackingSpecification.RESET;
      TargetTrackingSpecification.DELETEALL;

      IF NOT TempTrackingSpecification.FINDSET THEN
        EXIT(FALSE)
      ELSE
        REPEAT
          TargetTrackingSpecification := TempTrackingSpecification;
          TargetTrackingSpecification.INSERT;
        UNTIL TempTrackingSpecification.NEXT = 0;

      TempTrackingSpecification.DELETEALL;

      EXIT(TRUE);
    END;

    PROCEDURE CollectValueEntryRelation@10(VAR TargetValueEntryRelation@1001 : TEMPORARY Record 6508;RowId@1002 : Text[100]) @1000 : Boolean;
    BEGIN
      TempValueEntryRelation.RESET;
      TargetValueEntryRelation.RESET;

      IF NOT TempValueEntryRelation.FINDSET THEN
        EXIT(FALSE)
      ELSE
        REPEAT
          TargetValueEntryRelation := TempValueEntryRelation;
          TargetValueEntryRelation."Source RowId" := RowId;
          TargetValueEntryRelation.INSERT;
        UNTIL TempValueEntryRelation.NEXT = 0;

      TempValueEntryRelation.DELETEALL;

      EXIT(TRUE);
    END;

    PROCEDURE CollectItemEntryRelation@19(VAR TargetItemEntryRelation@1001 : TEMPORARY Record 6507) @1000 : Boolean;
    BEGIN
      TempItemEntryRelation.RESET;
      TargetItemEntryRelation.RESET;

      IF NOT TempItemEntryRelation.FINDSET THEN
        EXIT(FALSE)
      ELSE
        REPEAT
          TargetItemEntryRelation := TempItemEntryRelation;
          TargetItemEntryRelation.INSERT;
        UNTIL TempItemEntryRelation.NEXT = 0;

      TempItemEntryRelation.DELETEALL;

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE GetGLSetup@14();
    BEGIN
      IF NOT GLSetupRead THEN BEGIN
        GLSetup.GET;
        IF GLSetup."Additional Reporting Currency" <> '' THEN BEGIN
          Currency.GET(GLSetup."Additional Reporting Currency");
          Currency.TESTFIELD("Unit-Amount Rounding Precision");
          Currency.TESTFIELD("Amount Rounding Precision");
        END;
      END;
      GLSetupRead := TRUE;
    END;

    LOCAL PROCEDURE GetMfgSetup@35();
    BEGIN
      IF NOT MfgSetupRead THEN
        MfgSetup.GET;
      MfgSetupRead := TRUE;
    END;

    LOCAL PROCEDURE GetInvtSetup@36();
    BEGIN
      IF NOT InvtSetupRead THEN BEGIN
        InvtSetup.GET;
        SourceCodeSetup.GET;
      END;
      InvtSetupRead := TRUE;
    END;

    LOCAL PROCEDURE UndoQuantityPosting@18();
    VAR
      OldItemLedgEntry@1001 : Record 32;
      OldItemLedgEntry2@1004 : Record 32;
      NewItemLedgEntry@1002 : Record 32;
      OldValueEntry@1003 : Record 5802;
      OldValueEntry2@1005 : Record 5802;
      NewValueEntry@1000 : Record 5802;
    BEGIN
      IF ItemJnlLine."Applies-to Entry" <> 0 THEN BEGIN
        OldItemLedgEntry.GET(ItemJnlLine."Applies-to Entry");
        IF NOT OldItemLedgEntry.Positive THEN
          ItemJnlLine."Applies-from Entry" := ItemJnlLine."Applies-to Entry";
      END ELSE
        OldItemLedgEntry.GET(ItemJnlLine."Applies-from Entry");

      IF Item.GET(OldItemLedgEntry."Item No.") THEN
        Item.TESTFIELD(Blocked,FALSE);

      ItemJnlLine."Item No." := OldItemLedgEntry."Item No.";

      InitCorrItemLedgEntry(OldItemLedgEntry,NewItemLedgEntry);
      InsertItemReg(NewItemLedgEntry."Entry No.",0,0,0);
      GlobalItemLedgEntry := NewItemLedgEntry;

      UpdateOldItemLedgEntry(OldItemLedgEntry,NewItemLedgEntry."Posting Date");
      UpdateItemApplnEntry(OldItemLedgEntry."Entry No.",NewItemLedgEntry."Posting Date");

      OldValueEntry.SETCURRENTKEY("Item Ledger Entry No.");
      OldValueEntry.SETRANGE("Item Ledger Entry No.",OldItemLedgEntry."Entry No.");
      IF IsServUndoConsumption THEN
        OldValueEntry.SETFILTER("Item Ledger Entry Type",'<>%1',OldValueEntry."Item Ledger Entry Type"::"Negative Adjmt.");
      OldValueEntry.FINDFIRST;
      OldValueEntry2.SETCURRENTKEY("Item Ledger Entry No.");
      OldValueEntry2.COPY(OldValueEntry);
      IF OldValueEntry2.FINDSET THEN REPEAT
        IF OldValueEntry."Entry No." <> OldValueEntry2."Entry No." THEN BEGIN
          OldValueEntry."Cost Amount (Expected)" := OldValueEntry."Cost Amount (Expected)" + OldValueEntry2."Cost Amount (Expected)";
          OldItemLedgEntry."Cost Amount (Expected) (ACY)" :=
            OldItemLedgEntry."Cost Amount (Expected) (ACY)" + OldItemLedgEntry2."Cost Amount (Expected) (ACY)";
        END;
      UNTIL OldValueEntry2.NEXT = 0;

      IF NOT IsServUndoConsumption THEN
        InsertCorrValueEntry(
          OldValueEntry,NewValueEntry,OldItemLedgEntry,OldValueEntry."Document Line No.",1,TRUE);
      InsertCorrValueEntry(
        OldValueEntry,NewValueEntry,NewItemLedgEntry,ItemJnlLine."Document Line No.",-1,FALSE);
      InsertCorrValueEntry(
        OldValueEntry,NewValueEntry,NewItemLedgEntry,ItemJnlLine."Document Line No.",-1,TRUE);

      IF (GlobalItemLedgEntry.Quantity > 0) THEN
        ReserveItemJnlLine.TransferItemJnlToItemLedgEntry(
          ItemJnlLine,GlobalItemLedgEntry,ItemJnlLine."Quantity (Base)",TRUE);
      ApplyItemLedgEntry(NewItemLedgEntry,OldItemLedgEntry2,NewValueEntry,FALSE);
      AutoTrack(NewItemLedgEntry);

      NewItemLedgEntry.MODIFY;
      UpdateAdjmtProp(NewValueEntry,NewItemLedgEntry."Posting Date");

      IF NewItemLedgEntry.Positive THEN BEGIN
        UpdateOrigAppliedFromEntry(OldItemLedgEntry."Entry No.");
        InsertApplEntry(
          NewItemLedgEntry."Entry No.",NewItemLedgEntry."Entry No.",
          OldItemLedgEntry."Entry No.",0,NewItemLedgEntry."Posting Date",
          -OldItemLedgEntry.Quantity,FALSE);
      END;
    END;

    LOCAL PROCEDURE InitCorrItemLedgEntry@37(OldItemLedgEntry@1001 : Record 32;VAR NewItemLedgEntry@1002 : Record 32);
    VAR
      EntriesExist@1000 : Boolean;
    BEGIN
      IF ItemLedgEntryNo = 0 THEN
        ItemLedgEntryNo := GlobalItemLedgEntry."Entry No.";

      ItemLedgEntryNo := ItemLedgEntryNo + 1;
      NewItemLedgEntry := OldItemLedgEntry;
      ItemTrackingMgt.RetrieveAppliedExpirationDate(NewItemLedgEntry);
      NewItemLedgEntry."Entry No." := ItemLedgEntryNo;
      NewItemLedgEntry.Quantity := -OldItemLedgEntry.Quantity;
      NewItemLedgEntry."Remaining Quantity" := -OldItemLedgEntry.Quantity;
      IF NewItemLedgEntry.Quantity > 0 THEN
        NewItemLedgEntry."Shipped Qty. Not Returned" := 0
      ELSE
        NewItemLedgEntry."Shipped Qty. Not Returned" := NewItemLedgEntry.Quantity;
      NewItemLedgEntry."Invoiced Quantity" := NewItemLedgEntry.Quantity;
      NewItemLedgEntry.Positive := NewItemLedgEntry."Remaining Quantity" > 0;
      NewItemLedgEntry.Open := NewItemLedgEntry."Remaining Quantity" <> 0;
      NewItemLedgEntry."Completely Invoiced" := TRUE;
      NewItemLedgEntry."Last Invoice Date" := NewItemLedgEntry."Posting Date";
      NewItemLedgEntry.Correction := TRUE;
      NewItemLedgEntry."Document Line No." := ItemJnlLine."Document Line No.";
      IF OldItemLedgEntry.Positive THEN
        NewItemLedgEntry."Applies-to Entry" := OldItemLedgEntry."Entry No."
      ELSE
        NewItemLedgEntry."Applies-to Entry" := 0;
      NewItemLedgEntry.INSERT;

      IF NewItemLedgEntry."Item Tracking" <> NewItemLedgEntry."Item Tracking"::None THEN
        ItemTrackingMgt.ExistingExpirationDate(
          NewItemLedgEntry."Item No.",
          NewItemLedgEntry."Variant Code",
          NewItemLedgEntry."Lot No.",
          NewItemLedgEntry."Serial No.",
          TRUE,
          EntriesExist);

      MoveLedgEntryDimToLedgEntryDim(NewItemLedgEntry."Entry No.",OldItemLedgEntry."Entry No.");
    END;

    LOCAL PROCEDURE UpdateOldItemLedgEntry@40(VAR OldItemLedgEntry@1000 : Record 32;LastInvoiceDate@1001 : Date);
    BEGIN
      OldItemLedgEntry."Completely Invoiced" := TRUE;
      OldItemLedgEntry."Last Invoice Date" := LastInvoiceDate;
      OldItemLedgEntry."Invoiced Quantity" := OldItemLedgEntry.Quantity;
      OldItemLedgEntry."Shipped Qty. Not Returned" := 0;
      OldItemLedgEntry.MODIFY;
    END;

    LOCAL PROCEDURE InsertCorrValueEntry@34(OldValueEntry@1005 : Record 5802;VAR NewValueEntry@1000 : Record 5802;ItemLedgEntry@1003 : Record 32;DocumentLineNo@1006 : Integer;Sign@1001 : Integer;Invoiced@1004 : Boolean);
    BEGIN
      ValueEntryNo := ValueEntryNo + 1;

      NewValueEntry := OldValueEntry;
      NewValueEntry."Entry No." := ValueEntryNo;
      NewValueEntry."Item Ledger Entry No." := ItemLedgEntry."Entry No.";
      NewValueEntry."Valued Quantity" := Sign * OldValueEntry."Valued Quantity";
      NewValueEntry."Document Line No." := DocumentLineNo;
      IF Invoiced THEN BEGIN
        NewValueEntry."Item Ledger Entry Quantity" := 0;
        NewValueEntry."Cost Amount (Expected)" := -Sign * OldValueEntry."Cost Amount (Expected)";
        NewValueEntry."Cost Amount (Expected) (ACY)" := -Sign * OldValueEntry."Cost Amount (Expected) (ACY)";
        NewValueEntry."Cost Amount (Actual)" := Sign * OldValueEntry."Cost Amount (Expected)";
        NewValueEntry."Cost Amount (Actual) (ACY)" := Sign * OldValueEntry."Cost Amount (Expected) (ACY)";
        NewValueEntry."Purchase Amount (Expected)" := -Sign * OldValueEntry."Purchase Amount (Expected)";
        NewValueEntry."Sales Amount (Expected)" := -Sign * OldValueEntry."Sales Amount (Expected)";
        NewValueEntry."Invoiced Quantity" := Sign * OldValueEntry."Valued Quantity";
        NewValueEntry."Expected Cost" := FALSE;
      END ELSE BEGIN
        NewValueEntry."Item Ledger Entry Quantity" := Sign * OldValueEntry."Item Ledger Entry Quantity";
        NewValueEntry."Cost Amount (Expected)" := -OldValueEntry."Cost Amount (Expected)";
        NewValueEntry."Cost Amount (Expected) (ACY)" := -OldValueEntry."Cost Amount (Expected) (ACY)";
        NewValueEntry."Cost Amount (Actual)" := 0;
        NewValueEntry."Cost Amount (Actual) (ACY)" := 0;
        NewValueEntry."Sales Amount (Expected)" := -OldValueEntry."Sales Amount (Expected)";
        NewValueEntry."Purchase Amount (Expected)" := -OldValueEntry."Purchase Amount (Expected)";
      END;

      NewValueEntry."Purchase Amount (Actual)" := 0;
      NewValueEntry."Sales Amount (Actual)" := 0;
      NewValueEntry."Cost Amount (Non-Invtbl.)" := Sign * OldValueEntry."Cost Amount (Non-Invtbl.)";
      NewValueEntry."Cost Amount (Non-Invtbl.)(ACY)" := Sign * OldValueEntry."Cost Amount (Non-Invtbl.)(ACY)";
      NewValueEntry."Cost Posted to G/L" := 0;
      NewValueEntry."Cost Posted to G/L (ACY)" := 0;
      NewValueEntry."Expected Cost Posted to G/L" := 0;
      NewValueEntry."Exp. Cost Posted to G/L (ACY)" := 0;
      MoveValEntryDimToValEntryDim(NewValueEntry,OldValueEntry);
      IF NewValueEntry.Inventoriable THEN
        PostInventoryToGL(NewValueEntry);

      NewValueEntry.INSERT;

      UpdateAdjmtProp(NewValueEntry,ItemLedgEntry."Posting Date");

      InsertItemReg(0,0,NewValueEntry."Entry No.",0);
      InsertPostValueEntryToGL(NewValueEntry);
    END;

    LOCAL PROCEDURE MoveLedgEntryDimToLedgEntryDim@39(ToLedgerEntryNo@1001 : Integer;FromLedgerEntryNo@1004 : Integer);
    VAR
      FromLedgerEntryDim@1002 : Record 355;
      ToLedgerEntryDim@1003 : Record 355;
    BEGIN
      FromLedgerEntryDim.SETRANGE("Table ID", DATABASE::"Item Ledger Entry");
      FromLedgerEntryDim.SETRANGE("Entry No.",FromLedgerEntryNo);

      IF FromLedgerEntryDim.FINDSET THEN
        REPEAT
          ToLedgerEntryDim := FromLedgerEntryDim;
          ToLedgerEntryDim."Entry No." := ToLedgerEntryNo;
          ToLedgerEntryDim.INSERT;
        UNTIL FromLedgerEntryDim.NEXT = 0;
    END;

    LOCAL PROCEDURE UpdateOrigAppliedFromEntry@41(OldItemLedgEntryNo@1007 : Integer);
    VAR
      ItemApplEntry@1004 : Record 339;
      ItemLedgEntry@1005 : Record 32;
    BEGIN
      ItemApplEntry.SETCURRENTKEY("Outbound Item Entry No.","Item Ledger Entry No.");
      ItemApplEntry.SETRANGE("Outbound Item Entry No.",OldItemLedgEntryNo);
      ItemApplEntry.SETFILTER("Item Ledger Entry No.",'<>%1',OldItemLedgEntryNo);
      IF ItemApplEntry.FINDSET THEN
        REPEAT
          IF ItemLedgEntry.GET(ItemApplEntry."Inbound Item Entry No.") AND
             NOT ItemLedgEntry."Applied Entry to Adjust"
          THEN BEGIN
            ItemLedgEntry."Applied Entry to Adjust" := TRUE;
            ItemLedgEntry.MODIFY;
          END;
        UNTIL ItemApplEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE GetLocation@7300(LocationCode@1000 : Code[10]);
    BEGIN
      IF LocationCode = '' THEN
        Location.INIT
      ELSE
        IF Location.Code <> LocationCode THEN
          Location.GET(LocationCode);
    END;

    PROCEDURE CheckItemTracking@21();
    BEGIN
      IF SNRequired AND (ItemJnlLine."Serial No." = '') THEN
        ERROR(Text015,ItemJnlLine."Item No.");
      IF LotRequired AND (ItemJnlLine."Lot No." = '') THEN
        ERROR(Text016,ItemJnlLine."Item No.");
      IF (ItemJnlLine."Entry Type" = ItemJnlLine."Entry Type"::Transfer) THEN BEGIN
        IF SNRequired THEN
          ItemJnlLine.TESTFIELD("New Serial No.");
        IF LotRequired THEN
          ItemJnlLine.TESTFIELD("New Lot No.");
      END;
    END;

    LOCAL PROCEDURE CheckItemTrackingInfo@44(VAR ItemJnlLine2@1000 : Record 83;VAR TrackingSpecification@1001 : Record 336;SNInfoRequired@1005 : Boolean;LotInfoRequired@1004 : Boolean);
    VAR
      SerialNoInfo@1003 : Record 6504;
      LotNoInfo@1002 : Record 6505;
    BEGIN
      IF SNInfoRequired THEN BEGIN
        SerialNoInfo.GET(
          ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."Serial No.");
        SerialNoInfo.TESTFIELD(Blocked,FALSE);
        IF TrackingSpecification."New Serial No." <> '' THEN BEGIN
          SerialNoInfo.GET(
            ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."New Serial No.");
          SerialNoInfo.TESTFIELD(Blocked,FALSE);

        END;
      END ELSE BEGIN
        IF SerialNoInfo.GET(
            ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."Serial No.")
        THEN
          SerialNoInfo.TESTFIELD(Blocked,FALSE);
        IF TrackingSpecification."New Serial No." <> '' THEN BEGIN
          IF SerialNoInfo.GET(
            ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."New Serial No.")
          THEN
            SerialNoInfo.TESTFIELD(Blocked,FALSE);
        END;
      END;

      IF LotInfoRequired THEN BEGIN
        LotNoInfo.GET(
          ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."Lot No.");
        LotNoInfo.TESTFIELD(Blocked,FALSE);
        IF TrackingSpecification."New Lot No." <> '' THEN BEGIN
          LotNoInfo.GET(
            ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."New Lot No.");
          LotNoInfo.TESTFIELD(Blocked,FALSE);
        END;
      END ELSE BEGIN
        IF LotNoInfo.GET(
            ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."Lot No.")
        THEN
          LotNoInfo.TESTFIELD(Blocked,FALSE);
        IF TrackingSpecification."New Lot No." <> '' THEN BEGIN
          IF LotNoInfo.GET(
            ItemJnlLine2."Item No.",ItemJnlLine2."Variant Code",TrackingSpecification."New Lot No.")
          THEN
            LotNoInfo.TESTFIELD(Blocked,FALSE);
        END;
      END;
    END;

    LOCAL PROCEDURE InsertTempTrkgSpecification@46(FreeEntryNo@1000 : Integer);
    VAR
      TempTrackingSpecification2@1001 : TEMPORARY Record 336;
    BEGIN
      IF NOT TempTrackingSpecification.INSERT THEN BEGIN
        TempTrackingSpecification2 := TempTrackingSpecification;
        TempTrackingSpecification.GET(TempTrackingSpecification2."Appl.-to Item Entry");
        TempTrackingSpecification.DELETE;
        TempTrackingSpecification."Entry No." := FreeEntryNo;
        TempTrackingSpecification.INSERT;
        TempTrackingSpecification := TempTrackingSpecification2;
        TempTrackingSpecification.INSERT;
      END;
    END;

    LOCAL PROCEDURE IsNotInternalWhseMovement@43(ItemJnlLine@1000 : Record 83) : Boolean;
    BEGIN
      WITH ItemJnlLine DO BEGIN
        IF ("Entry Type" = "Entry Type"::Transfer) AND
           ("Location Code" = "New Location Code") AND
           ("Value Entry Type" = "Value Entry Type"::"Direct Cost") AND
           NOT Adjustment
        THEN
          EXIT(FALSE)
        ELSE
          EXIT(TRUE)
      END;
    END;

    PROCEDURE SetCalledFromInvtPutawayPick@47(NewCalledFromInvtPutawayPick@1000 : Boolean);
    BEGIN
      CalledFromInvtPutawayPick := NewCalledFromInvtPutawayPick;
    END;

    PROCEDURE SetCalledFromAdjustment@49(NewCalledFromAdjustment@1000 : Boolean;NewPostToGL@1001 : Boolean);
    BEGIN
      CalledFromAdjustment := NewCalledFromAdjustment;
      PostToGL := NewPostToGL;
    END;

    PROCEDURE NextOperationExist@50(ProdOrderRtngLine@1000 : Record 5409) : Boolean;
    VAR
      ProdOrderRtngLine2@1001 : Record 5409;
    BEGIN
      ProdOrderRtngLine2 := ProdOrderRtngLine;

      ProdOrderRtngLine2.RESET;
      ProdOrderRtngLine2.SETRANGE(Status,ProdOrderRtngLine.Status);
      ProdOrderRtngLine2.SETRANGE("Prod. Order No.",ProdOrderRtngLine."Prod. Order No.");
      ProdOrderRtngLine2.SETRANGE("Routing No.",ProdOrderRtngLine."Routing No.");
      ProdOrderRtngLine2.SETRANGE("Routing Reference No.",ProdOrderRtngLine."Routing Reference No.");
      EXIT(ProdOrderRtngLine2.FIND('>'));
    END;

    PROCEDURE GetPostItemJnlLine@51() : Boolean;
    BEGIN
      EXIT(PostItemJnlLine);
    END;

    LOCAL PROCEDURE UpdateAdjmtProp@58(ValueEntry@1000 : Record 5802;OriginalPostingDate@1003 : Date);
    BEGIN
      WITH ValueEntry DO
        SetAdjmtProp("Item No.","Item Ledger Entry Type",Adjustment,"Prod. Order No.",
        "Prod. Order Line No.",OriginalPostingDate,"Valuation Date");
    END;

    PROCEDURE SetAdjmtProp@64(ItemNo@1001 : Code[20];ItemLedgEntryType@1005 : Option;Adjustment@1000 : Boolean;ProdOrderNo@1004 : Code[20];ProdOrderLineNo@1006 : Integer;OriginalPostingDate@1002 : Date;ValuationDate@1003 : Date);
    VAR
      Item@1010 : Record 27;
      ValueEntry@1011 : Record 5802;
      ProdOrderLine@1009 : Record 5406;
      ModifyItem@1008 : Boolean;
      ModifyProdOrderLine@1007 : Boolean;
    BEGIN
      IF NOT (Adjustment OR
              (ItemLedgEntryType = ValueEntry."Item Ledger Entry Type"::" "))
      THEN
        WITH Item DO
          IF GET(ItemNo) AND ("Allow Online Adjustment" OR "Cost is Adjusted") THEN BEGIN
            LOCKTABLE;
            IF "Cost is Adjusted" THEN BEGIN
              "Cost is Adjusted" := FALSE;
              ModifyItem := TRUE;
            END;
            IF "Allow Online Adjustment" THEN BEGIN
              IF "Costing Method" = "Costing Method"::Average THEN
                "Allow Online Adjustment" := AllowAdjmtOnPosting(ValuationDate)
              ELSE
                "Allow Online Adjustment" := AllowAdjmtOnPosting(OriginalPostingDate);
              ModifyItem := ModifyItem OR NOT "Allow Online Adjustment";
            END;
            IF ModifyItem THEN
              MODIFY;
          END;

      IF NOT ((ProdOrderNo = '') OR
              (ItemLedgEntryType = ValueEntry."Item Ledger Entry Type"::Output))
      THEN
        WITH ProdOrderLine DO
          IF (TRUE IN [GET(Status::Finished,ProdOrderNo,ProdOrderLineNo),
                       GET(Status::Released,ProdOrderNo,ProdOrderLineNo)]) AND
             ("Allow Online Adjustment" OR "Cost is Adjusted")
          THEN BEGIN
            LOCKTABLE;
            IF "Cost is Adjusted" THEN BEGIN
              "Cost is Adjusted" := FALSE;
              ModifyProdOrderLine := TRUE;
            END;
            IF "Allow Online Adjustment" THEN BEGIN
              "Allow Online Adjustment" := AllowAdjmtOnPosting(OriginalPostingDate);
              ModifyProdOrderLine := ModifyProdOrderLine OR NOT "Allow Online Adjustment";
            END;
            IF ModifyProdOrderLine THEN
              MODIFY;
          END;
    END;

    LOCAL PROCEDURE AllowAdjmtOnPosting@56(TheDate@1000 : Date) : Boolean;
    BEGIN
      GetInvtSetup;

      WITH InvtSetup DO
        CASE "Automatic Cost Adjustment" OF
          "Automatic Cost Adjustment"::Never:
            EXIT(FALSE);
          "Automatic Cost Adjustment"::Day:
            EXIT(TheDate >= CALCDATE('<-1D>',WORKDATE));
          "Automatic Cost Adjustment"::Week:
            EXIT(TheDate >= CALCDATE('<-1W>',WORKDATE));
          "Automatic Cost Adjustment"::Month:
            EXIT(TheDate >= CALCDATE('<-1M>',WORKDATE));
          "Automatic Cost Adjustment"::Quarter:
            EXIT(TheDate >= CALCDATE('<-1Q>',WORKDATE));
          "Automatic Cost Adjustment"::Year:
            EXIT(TheDate >= CALCDATE('<-1Y>',WORKDATE));
          ELSE
            EXIT(TRUE);
        END;
    END;

    PROCEDURE InsertBalanceExpCostRevEntry@62(ValueEntry@1000 : Record 5802);
    VAR
      ValueEntry2@1001 : Record 5802;
      ValueEntry3@1004 : Record 5802;
      RevExpCostToBalance@1002 : Decimal;
      RevExpCostToBalanceACY@1003 : Decimal;
    BEGIN
      IF GlobalItemLedgEntry.Quantity - (GlobalItemLedgEntry."Invoiced Quantity" - ValueEntry."Invoiced Quantity") = 0 THEN
        EXIT;
      WITH ValueEntry2 DO BEGIN
        SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        SETRANGE("Item Ledger Entry No.",ValueEntry."Item Ledger Entry No.");
        SETRANGE("Entry Type","Entry Type"::Revaluation);
        SETRANGE("Applies-to Entry",0);
        IF FINDSET THEN
          REPEAT
            CalcRevExpCostToBalance(ValueEntry2,ValueEntry."Invoiced Quantity",RevExpCostToBalance,RevExpCostToBalanceACY);
            IF (RevExpCostToBalance <> 0) OR (RevExpCostToBalanceACY <> 0) THEN BEGIN
              ValueEntryNo := ValueEntryNo + 1;
              ValueEntry3 := ValueEntry;
              ValueEntry3."Entry No." := ValueEntryNo;
              ValueEntry3."Item Charge No." := '';
              ValueEntry3."Entry Type" := ValueEntry."Entry Type"::Revaluation;
              ValueEntry3."Valuation Date" := "Valuation Date";
              ValueEntry3.Description := '';
              ValueEntry3."Applies-to Entry" := "Entry No.";
              ValueEntry3."Cost Amount (Expected)" := RevExpCostToBalance;
              ValueEntry3."Cost Amount (Expected) (ACY)" := RevExpCostToBalanceACY;
              ValueEntry3."Valued Quantity" := ValueEntry2."Valued Quantity";
              ValueEntry3."Cost per Unit" := CalcCostPerUnit(RevExpCostToBalance,ValueEntry."Valued Quantity",FALSE);
              ValueEntry3."Cost per Unit (ACY)" := CalcCostPerUnit(RevExpCostToBalanceACY,ValueEntry."Valued Quantity",TRUE);
              ValueEntry3."Cost Posted to G/L" := 0;
              ValueEntry3."Cost Posted to G/L (ACY)" := 0;
              ValueEntry3."Expected Cost Posted to G/L" := 0;
              ValueEntry3."Exp. Cost Posted to G/L (ACY)" := 0;
              ValueEntry3."Invoiced Quantity" := 0;
              ValueEntry3."Sales Amount (Actual)" := 0;
              ValueEntry3."Purchase Amount (Actual)" := 0;
              ValueEntry3."Discount Amount" := 0;
              ValueEntry3."Cost Amount (Actual)" := 0;
              ValueEntry3."Cost Amount (Actual) (ACY)" := 0;
              ValueEntry3."Sales Amount (Expected)" := 0;
              ValueEntry3."Purchase Amount (Expected)" := 0;
              InsertValueEntry(ValueEntry3,GlobalItemLedgEntry,FALSE);
            END;
          UNTIL NEXT = 0;
      END;
    END;

    PROCEDURE IsBalanceExpectedCostFromRev@59(ItemJnlLine2@1000 : Record 83) : Boolean;
    BEGIN
      WITH ItemJnlLine2 DO
        EXIT((Item."Costing Method" = Item."Costing Method"::Standard) AND
             (((Quantity = 0) AND ("Invoiced Quantity" <> 0)) OR
             (Adjustment AND NOT GlobalValueEntry."Expected Cost")));
    END;

    PROCEDURE CalcRevExpCostToBalance@61(ValueEntry@1000 : Record 5802;InvdQty@1001 : Decimal;VAR RevExpCostToBalance@1002 : Decimal;VAR RevExpCostToBalanceACY@1003 : Decimal);
    VAR
      ValueEntry2@1004 : Record 5802;
      OldExpectedQty@1005 : Decimal;
    BEGIN
      WITH ValueEntry2 DO BEGIN
        RevExpCostToBalance := -ValueEntry."Cost Amount (Expected)";
        RevExpCostToBalanceACY := -ValueEntry."Cost Amount (Expected) (ACY)";
        OldExpectedQty := GlobalItemLedgEntry.Quantity;
        SETCURRENTKEY("Item Ledger Entry No.","Entry Type");
        SETRANGE("Item Ledger Entry No.",ValueEntry."Item Ledger Entry No.");
        IF GlobalItemLedgEntry.Quantity <> GlobalItemLedgEntry."Invoiced Quantity" THEN BEGIN
          SETRANGE("Entry Type","Entry Type"::"Direct Cost");
          SETFILTER("Entry No.",'<%1',ValueEntry."Entry No.");
          SETRANGE("Item Charge No.",'');
          IF FINDSET THEN
            REPEAT
              OldExpectedQty := OldExpectedQty - "Invoiced Quantity";
            UNTIL NEXT = 0;

          RevExpCostToBalance := ROUND(RevExpCostToBalance * InvdQty / OldExpectedQty,GLSetup."Amount Rounding Precision");
          RevExpCostToBalanceACY := ROUND(RevExpCostToBalanceACY * InvdQty / OldExpectedQty,Currency."Amount Rounding Precision");
        END ELSE BEGIN
          SETRANGE("Entry Type","Entry Type"::Revaluation);
          SETRANGE("Applies-to Entry",ValueEntry."Entry No.");
          IF FINDSET THEN
            REPEAT
              RevExpCostToBalance := RevExpCostToBalance - "Cost Amount (Expected)";
              RevExpCostToBalanceACY :=  RevExpCostToBalanceACY - "Cost Amount (Expected) (ACY)";
            UNTIL NEXT = 0;
        END;
      END;
    END;

    PROCEDURE IsInterimRevaluation@63() : Boolean;
    BEGIN
      WITH ItemJnlLine DO
        EXIT(("Value Entry Type" = "Value Entry Type"::Revaluation) AND (Quantity <> 0));
    END;

    LOCAL PROCEDURE InsertPostValueEntryToGL@96(ValueEntry@1000 : Record 5802);
    VAR
      PostValueEntryToGL@1001 : Record 5811;
    BEGIN
      IF IsPostToGL(ValueEntry) THEN BEGIN
        PostValueEntryToGL."Value Entry No." := ValueEntry."Entry No.";
        PostValueEntryToGL."Item No." := ValueEntry."Item No.";
        PostValueEntryToGL."Posting Date" := ValueEntry."Posting Date";
        PostValueEntryToGL.INSERT;
      END;
    END;

    LOCAL PROCEDURE IsPostToGL@66(ValueEntry@1000 : Record 5802) : Boolean;
    BEGIN
      GetInvtSetup;
      WITH ValueEntry DO
        EXIT(
          Inventoriable AND NOT PostToGL AND
          ((NOT "Expected Cost") OR InvtSetup."Expected Cost Posting to G/L") AND
          (("Cost Amount (Actual)" <> 0) OR ("Cost Amount (Actual) (ACY)" <> 0) OR
           ("Cost Amount (Expected)" <> 0) OR ("Cost Amount (Expected) (ACY)" <> 0)));
    END;

    PROCEDURE UTlocalCall@145(localFunctionName@1000 : Text[30];VAR param@1001 : ARRAY [20] OF Variant;VAR return@1002 : Variant);
    VAR
      ValueEntry@1003 : Record 5802;
      ValueEntry2@1004 : Record 5802;
    BEGIN
      CASE localFunctionName OF
        'IsAvgCostException':
          BEGIN
            ValueEntry := param[1];
            IF param[2].ISRECORD THEN
              ItemJnlLine := param[2];
            IF param[3].ISRECORD THEN
              InvtSetup := param[3];
            IF param[4].ISRECORD THEN BEGIN
              ValueEntry2 := param[4];
              ValueEntry2.INSERT;
            END;
            return := FALSE; //ValueEntry.IsAvgCostException;
          END;
        ELSE
          ERROR('Local function %1 is not included for test.',localFunctionName);
      END;
    END;

    PROCEDURE MoveApplication@90(VAR ItemLedgEntry@1001 : Record 32;VAR OldItemLedgEntry@1000 : Record 32) : Boolean;
    VAR
      Application@1002 : Record 339;
      Enough@1004 : Boolean;
      FixedApplication@1003 : Boolean;
    BEGIN
      WITH ItemLedgEntry DO BEGIN
        FixedApplication := FALSE;
        OldItemLedgEntry.TESTFIELD(Positive,TRUE);

        IF (OldItemLedgEntry."Remaining Quantity" < ABS(Quantity)) AND
           (OldItemLedgEntry."Remaining Quantity" < OldItemLedgEntry.Quantity)
        THEN  BEGIN
          Enough:=FALSE;
          Application.RESET;
          Application.SETCURRENTKEY("Inbound Item Entry No.");
          Application.SETRANGE("Inbound Item Entry No.","Applies-to Entry");
          Application.SETFILTER("Outbound Item Entry No.",'<>0');

          IF Application.FINDSET THEN BEGIN
            REPEAT
              IF NOT Application.Fixed THEN BEGIN
                UnApply(Application);
                OldItemLedgEntry.GET(OldItemLedgEntry."Entry No.");
                OldItemLedgEntry.CALCFIELDS("Reserved Quantity");
                Enough :=
                  ABS(OldItemLedgEntry."Remaining Quantity" - OldItemLedgEntry."Reserved Quantity") >=
                  ABS("Remaining Quantity");
              END ELSE
                FixedApplication := TRUE;
            UNTIL (Application.NEXT = 0) OR Enough;
          END ELSE
            EXIT(FALSE); // no applications found that could be undone
          IF NOT Enough AND FixedApplication THEN
            ERROR(Text027);
          EXIT(Enough);
        END;
        EXIT(TRUE);
      END;
    END;

    PROCEDURE RedoApplications@91();
    VAR
      TouchedItemLedgEntry@1005 : Record 32;
      Dialog@1001 : Dialog;
      Count@1002 : Integer;
      t@1003 : Integer;
    BEGIN
      TouchedItemLedgerEntries.SETCURRENTKEY("Item No.",Open,"Variant Code",Positive,"Location Code","Posting Date");
      IF TouchedItemLedgerEntries.FIND('-') THEN BEGIN
        Dialog.OPEN(Text01+
                  '@1@@@@@@@@@@@@@@@@@@@@@@@');
        Count := TouchedItemLedgerEntries.COUNT;
        t := 0;
        REPEAT
          t := t + 1;
          Dialog.UPDATE(1,ROUND(t*10000 / Count,1));
          TouchedItemLedgEntry.GET(TouchedItemLedgerEntries."Entry No.");
          IF TouchedItemLedgEntry."Remaining Quantity"<>0 THEN
          BEGIN
            ReApply(TouchedItemLedgEntry,0);
            TouchedItemLedgEntry.GET(TouchedItemLedgerEntries."Entry No.");
          END;
        UNTIL TouchedItemLedgerEntries.NEXT = 0;
        TouchedItemLedgerEntries.DELETEALL;
        Dialog.CLOSE;
      END;
    END;

    PROCEDURE CostAdjust@92();
    VAR
      TempItem@1000 : Record 27;
      InvtSetup@1001 : Record 313;
      InvtAdjmt@1003 : Codeunit 5895;
      InventoryPeriod@1002 : Record 5814;
      Opendate@1004 : Date;
    BEGIN
      InvtSetup.GET;
      InventoryPeriod.IsValidDate(Opendate);
      IF InvtSetup."Automatic Cost Adjustment" <>
         InvtSetup."Automatic Cost Adjustment"::Never
      THEN BEGIN
        IF Opendate <> 0D THEN Opendate := CALCDATE('<+1D>',Opendate);
        InvtAdjmt.SetProperties(TRUE,InvtSetup."Automatic Cost Posting");
        InvtAdjmt.MakeMultiLevelAdjmt;
      END;
    END;

    PROCEDURE TouchEntry@68(EntryNo@1000 : Integer);
    VAR
      TouchedItemLedgEntry@1002 : Record 32;
    BEGIN
      TouchedItemLedgEntry.GET(EntryNo);
      TouchedItemLedgerEntries := TouchedItemLedgEntry;
      IF NOT TouchedItemLedgerEntries.INSERT THEN ;
    END;

    PROCEDURE TouchItemEntryCost@69(VAR ItemLedgerEntry@1000 : Record 32;IsAdjustment@1006 : Boolean);
    VAR
      Item@1001 : Record 27;
      ProdOrder@1002 : Record 5405;
      ProdOrderLine@1003 : Record 5406;
      ValueEntry@1004 : Record 5802;
      AvgCostAdjmtEntryPoint@1005 : Record 5804;
    BEGIN
      ItemLedgerEntry."Applied Entry to Adjust" := TRUE;
      WITH ItemLedgerEntry DO
        SetAdjmtProp("Item No.",ItemLedgerEntry."Entry Type",IsAdjustment,"Prod. Order No.",
        "Prod. Order Line No.","Posting Date","Posting Date");

      IF NOT IsAdjustment THEN BEGIN
        EnsureValueEntryLoaded(ValueEntry,ItemLedgerEntry);
        AvgCostAdjmtEntryPoint.UpdateValuationDate(ValueEntry);
      END;
    END;

    PROCEDURE AnyTouchedEntries@67() : Boolean;
    BEGIN
      EXIT(TouchedItemLedgerEntries.FIND('-'))
    END;

    PROCEDURE GetMaxAppliedValuationdate@93(ItemLedgerEntry@1000 : Record 32) : Date;
    VAR
      ValueEntry@1001 : Record 5802;
      FromInbound@1002 : Boolean;
      MaxDate@1003 : Date;
      NewDate@1005 : Date;
      ToItemApplnEntry@1004 : Record 339;
      FromItemledgEntryNo@1006 : Integer;
    BEGIN
      FromInbound := ItemLedgerEntry.Positive;
      FromItemledgEntryNo := ItemLedgerEntry."Entry No.";
      WITH ToItemApplnEntry DO BEGIN
        IF FromInbound THEN BEGIN
          SETCURRENTKEY("Inbound Item Entry No.","Item Ledger Entry No.","Outbound Item Entry No.");
          SETRANGE("Inbound Item Entry No.",FromItemledgEntryNo);
          SETFILTER("Outbound Item Entry No.",'<>%1',0);
          SETFILTER(ToItemApplnEntry.Quantity,'>%1',0);
        END ELSE BEGIN
          SETCURRENTKEY("Outbound Item Entry No.","Item Ledger Entry No.");
          SETRANGE("Outbound Item Entry No.",FromItemledgEntryNo);
          SETFILTER(ToItemApplnEntry.Quantity,'<%1',0);
        END;
        IF FINDSET THEN BEGIN
          MaxDate := 0D;
          REPEAT
            IF FromInbound THEN
              ItemLedgerEntry.GET("Outbound Item Entry No.")
            ELSE
              ItemLedgerEntry.GET("Inbound Item Entry No.");
            NewDate := GetMaxValuationDate(ItemLedgerEntry);
            MaxDate := Max(NewDate,MaxDate);
          UNTIL NEXT = 0
        END;
      END;
      EXIT(MaxDate);
    END;

    PROCEDURE Max@94(Date1@1000 : Date;Date2@1001 : Date) : Date;
    BEGIN
      IF Date1 > Date2 THEN
        EXIT(Date1);
      EXIT(Date2);
    END;

    PROCEDURE SetValuationDateAllValueEntrie@95(ItemLedgerEntryNo@1000 : Integer;ValuationDate@1001 : Date);
    VAR
      ValueEntry@1002 : Record 5802;
    BEGIN
      WITH ValueEntry DO BEGIN
        RESET;
        SETCURRENTKEY("Item Ledger Entry No.");
        SETRANGE("Item Ledger Entry No.",ItemLedgerEntryNo);
        IF FINDSET THEN REPEAT
          IF ("Posting Date" <> "Valuation Date")
          OR (ValueEntry."Valuation Date"<ValuationDate) THEN BEGIN
            "Valuation Date" := ValuationDate;
            MODIFY;
          END;
        UNTIL NEXT = 0;
      END;
    END;

    PROCEDURE SetServUndoConsumption@71(Value@1000 : Boolean);
    BEGIN
      IsServUndoConsumption := Value;
    END;

    PROCEDURE SetProdOrderCompModified@45(ProdOrderCompIsModified@1000 : Boolean);
    BEGIN
      ProdOrderCompModified := ProdOrderCompIsModified;
    END;

    LOCAL PROCEDURE IsNonInvtChargeItemJnlLine@80() : Boolean;
    VAR
      ItemLedgEntry@1000 : Record 32;
    BEGIN
      IF ItemJnlLine."Entry Type" <> ItemJnlLine."Entry Type"::Purchase THEN
        EXIT(FALSE);
      IF ItemJnlLine."Value Entry Type" <> ItemJnlLine."Value Entry Type"::"Direct Cost" THEN
        EXIT(FALSE);
      IF ItemJnlLine."Item Charge No." = '' THEN
        EXIT(FALSE);
      ItemLedgEntry.GET(ItemJnlLine."Item Shpt. Entry No.");
      EXIT(ItemLedgEntry."Entry Type" = ItemLedgEntry."Entry Type"::Sale);
    END;

    PROCEDURE InsertCountryCode@81(VAR NewItemLedgEntry@1000 : Record 32;ItemLedgEntry@1001 : Record 32);
    BEGIN
      IF ItemLedgEntry."Location Code" = '' THEN
        EXIT;
      IF NewItemLedgEntry."Location Code" = '' THEN BEGIN
        Location.GET(ItemLedgEntry."Location Code");
        NewItemLedgEntry."Country/Region Code" := Location."Country/Region Code";
      END ELSE BEGIN
        Location.GET(NewItemLedgEntry."Location Code");
        IF NOT Location."Use As In-Transit" THEN BEGIN
          Location.GET(ItemLedgEntry."Location Code");
          IF NOT Location."Use As In-Transit" THEN
            NewItemLedgEntry."Country/Region Code" := Location."Country/Region Code";
        END;
      END;
    END;

    PROCEDURE ReservationPreventsApplication@82(ApplicationEntry@1001 : Integer;ItemNo@1002 : Code[20];ReservationsEntry@1003 : Record 32);
    VAR
      ReservationEntries@1000 : Record 337;
      ReservEngineMgt@1005 : Codeunit 99000831;
      ReserveItemLedgEntry@1004 : Codeunit 99000841;
    BEGIN
      ReservEngineMgt.InitFilterAndSortingLookupFor(ReservationEntries,TRUE);
      ReserveItemLedgEntry.FilterReservFor(ReservationEntries,ReservationsEntry);
      IF ReservationEntries.FINDFIRST THEN;
      ERROR(
        Text029,
        ReservationsEntry.FIELDCAPTION("Applies-to Entry"),
        ApplicationEntry,
        Item.FIELDCAPTION("No."),
        ItemNo,
        ReservEngineMgt.CreateForText(ReservationEntries));
    END;

    LOCAL PROCEDURE CheckItemTrackingOfComp@83(TempHandlingSpecification@1000 : Record 336;ItemJnlLine@1001 : Record 83);
    BEGIN
      IF SNRequired THEN
        ItemJnlLine.TESTFIELD("Serial No.",TempHandlingSpecification."Serial No.");
      IF LotRequired THEN
        ItemJnlLine.TESTFIELD("Lot No.",TempHandlingSpecification."Lot No.");
    END;

    PROCEDURE GetSourceNo@97(ItemJnlLine@1102601000 : Record 83) : Code[20];
    BEGIN
      IF ItemJnlLine."Invoice-to Source No." <> '' THEN
        EXIT(ItemJnlLine."Invoice-to Source No.");
      EXIT(ItemJnlLine."Source No.");
    END;

    BEGIN
    END.
  }
}
